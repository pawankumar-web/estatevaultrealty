! function(e, t) {
	"object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).THREE = {})
}(this, (function(e) {
	function t() {}

	function i(e, t) {
		this.x = e || 0, this.y = t || 0
	}

	function n(e, t, i, n) {
		this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
	}

	function r(e, t, i) {
		this.x = e || 0, this.y = t || 0, this.z = i || 0
	}

	function o() {
		this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
	}

	function s(e, t, n, r, a, l, c, h, u, d) {
		Object.defineProperty(this, "id", {
			value: mo++
		}), this.uuid = uo.generateUUID(), this.name = "", this.image = void 0 !== e ? e : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : s.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== a ? a : 1006, this.minFilter = void 0 !== l ? l : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== h ? h : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null
	}

	function a(e, t, i, n) {
		this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
	}

	function l(e, t, i) {
		this.width = e, this.height = t, this.scissor = new a(0, 0, e, t), this.scissorTest = !1, this.viewport = new a(0, 0, e, t), i = i || {}, this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
	}

	function c(e, t, i) {
		l.call(this, e, t, i), this.samples = 4
	}

	function h(e, t, i) {
		l.call(this, e, t, i)
	}

	function u(e, t, i, n, r, o, a, l, c, h, u, d) {
		s.call(this, null, o, a, l, c, h, n, r, u, d), this.image = {
			data: e,
			width: t,
			height: i
		}, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
	}

	function d(e, t) {
		this.min = void 0 !== e ? e : new r(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new r(-1 / 0, -1 / 0, -1 / 0)
	}

	function p(e, t) {
		this.center = void 0 !== e ? e : new r, this.radius = void 0 !== t ? t : 0
	}

	function f(e, t) {
		this.normal = void 0 !== e ? e : new r(1, 0, 0), this.constant = void 0 !== t ? t : 0
	}

	function m(e, t, i, n, r, o) {
		this.planes = [void 0 !== e ? e : new f, void 0 !== t ? t : new f, void 0 !== i ? i : new f, void 0 !== n ? n : new f, void 0 !== r ? r : new f, void 0 !== o ? o : new f]
	}

	function g() {
		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
	}

	function v(e) {
		var t, i = {};
		for (t in e)
			for (var n in i[t] = {}, e[t]) {
				var r = e[t][n];
				r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[t][n] = r.clone() : Array.isArray(r) ? i[t][n] = r.slice() : i[t][n] = r
			}
		return i
	}

	function y(e) {
		for (var t = {}, i = 0; i < e.length; i++) {
			var n, r = v(e[i]);
			for (n in r) t[n] = r[n]
		}
		return t
	}

	function b(e, t, i) {
		return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
	}

	function w() {
		function e(r, o) {
			!1 !== i && (n(r, o), t.requestAnimationFrame(e))
		}
		var t = null,
			i = !1,
			n = null;
		return {
			start: function() {
				!0 !== i && null !== n && (t.requestAnimationFrame(e), i = !0)
			},
			stop: function() {
				i = !1
			},
			setAnimationLoop: function(e) {
				n = e
			},
			setContext: function(e) {
				t = e
			}
		}
	}

	function x(e) {
		var t = new WeakMap;
		return {
			get: function(e) {
				return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
			},
			remove: function(i) {
				i.isInterleavedBufferAttribute && (i = i.data);
				var n = t.get(i);
				n && (e.deleteBuffer(n.buffer), t.delete(i))
			},
			update: function(i, n) {
				i.isInterleavedBufferAttribute && (i = i.data);
				var r = t.get(i);
				if (void 0 === r) t.set(i, function(t, i) {
					var n = t.array,
						r = t.dynamic ? 35048 : 35044,
						o = e.createBuffer();
					return e.bindBuffer(i, o), e.bufferData(i, n, r), t.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), {
						buffer: o,
						type: i,
						bytesPerElement: n.BYTES_PER_ELEMENT,
						version: t.version
					}
				}(i, n));
				else if (r.version < i.version) {
					var o = i,
						s = o.array,
						a = o.updateRange;
					e.bindBuffer(n, r.buffer), !1 === o.dynamic ? e.bufferData(n, s, 35044) : -1 === a.count ? e.bufferSubData(n, 0, s) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)), a.count = -1), r.version = i.version
				}
			}
		}
	}

	function _(e, t, i, n, o, s) {
		this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new r, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new b, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== s ? s : 0
	}

	function E(e, t, i, n) {
		this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || E.DefaultOrder
	}

	function M() {
		this.mask = 1
	}

	function S() {
		Object.defineProperty(this, "id", {
			value: xo++
		}), this.uuid = uo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = S.DefaultUp.clone();
		var e = new r,
			t = new E,
			i = new n,
			s = new r(1, 1, 1);
		t.onChange((function() {
			i.setFromEuler(t, !1)
		})), i.onChange((function() {
			t.setFromQuaternion(i, void 0, !1)
		})), Object.defineProperties(this, {
			position: {
				configurable: !0,
				enumerable: !0,
				value: e
			},
			rotation: {
				configurable: !0,
				enumerable: !0,
				value: t
			},
			quaternion: {
				configurable: !0,
				enumerable: !0,
				value: i
			},
			scale: {
				configurable: !0,
				enumerable: !0,
				value: s
			},
			modelViewMatrix: {
				value: new g
			},
			normalMatrix: {
				value: new o
			}
		}), this.matrix = new g, this.matrixWorld = new g, this.matrixAutoUpdate = S.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new M, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
	}

	function T() {
		Object.defineProperty(this, "id", {
			value: _o += 2
		}), this.uuid = uo.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
			[]
		], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
	}

	function A(e, t, i) {
		if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
			offset: 0,
			count: -1
		}, this.version = 0
	}

	function L(e, t, i) {
		A.call(this, new Int8Array(e), t, i)
	}

	function C(e, t, i) {
		A.call(this, new Uint8Array(e), t, i)
	}

	function P(e, t, i) {
		A.call(this, new Uint8ClampedArray(e), t, i)
	}

	function I(e, t, i) {
		A.call(this, new Int16Array(e), t, i)
	}

	function R(e, t, i) {
		A.call(this, new Uint16Array(e), t, i)
	}

	function O(e, t, i) {
		A.call(this, new Int32Array(e), t, i)
	}

	function D(e, t, i) {
		A.call(this, new Uint32Array(e), t, i)
	}

	function z(e, t, i) {
		A.call(this, new Float32Array(e), t, i)
	}

	function k(e, t, i) {
		A.call(this, new Float64Array(e), t, i)
	}

	function N() {
		this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
	}

	function B(e) {
		if (0 === e.length) return -1 / 0;
		for (var t = e[0], i = 1, n = e.length; i < n; ++i) e[i] > t && (t = e[i]);
		return t
	}

	function H() {
		Object.defineProperty(this, "id", {
			value: Eo += 2
		}), this.uuid = uo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
			start: 0,
			count: 1 / 0
		}, this.userData = {}
	}

	function F(e, t, i, n, r, o) {
		T.call(this), this.type = "BoxGeometry", this.parameters = {
			width: e,
			height: t,
			depth: i,
			widthSegments: n,
			heightSegments: r,
			depthSegments: o
		}, this.fromBufferGeometry(new U(e, t, i, n, r, o)), this.mergeVertices()
	}

	function U(e, t, i, n, o, s) {
		function a(e, t, i, n, o, s, a, m, g, v, y) {
			var b = s / g,
				w = a / v,
				x = s / 2,
				_ = a / 2,
				E = m / 2;
			a = g + 1;
			var M, S, T = v + 1,
				A = s = 0,
				L = new r;
			for (S = 0; S < T; S++) {
				var C = S * w - _;
				for (M = 0; M < a; M++) L[e] = (M * b - x) * n, L[t] = C * o, L[i] = E, h.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[i] = 0 < m ? 1 : -1, u.push(L.x, L.y, L.z), d.push(M / g), d.push(1 - S / v), s += 1
			}
			for (S = 0; S < v; S++)
				for (M = 0; M < g; M++) e = p + M + a * (S + 1), t = p + (M + 1) + a * (S + 1), i = p + (M + 1) + a * S, c.push(p + M + a * S, e, i), c.push(e, t, i), A += 6;
			l.addGroup(f, A, y), f += A, p += s
		}
		H.call(this), this.type = "BoxBufferGeometry", this.parameters = {
			width: e,
			height: t,
			depth: i,
			widthSegments: n,
			heightSegments: o,
			depthSegments: s
		};
		var l = this;
		e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, s = Math.floor(s) || 1;
		var c = [],
			h = [],
			u = [],
			d = [],
			p = 0,
			f = 0;
		a("z", "y", "x", -1, -1, i, t, e, s, o, 0), a("z", "y", "x", 1, -1, i, t, -e, s, o, 1), a("x", "z", "y", 1, 1, e, i, t, n, s, 2), a("x", "z", "y", 1, -1, e, i, -t, n, s, 3), a("x", "y", "z", 1, -1, e, t, i, n, o, 4), a("x", "y", "z", -1, -1, e, t, -i, n, o, 5), this.setIndex(c), this.addAttribute("position", new z(h, 3)), this.addAttribute("normal", new z(u, 3)), this.addAttribute("uv", new z(d, 2))
	}

	function j(e, t, i, n) {
		T.call(this), this.type = "PlaneGeometry", this.parameters = {
			width: e,
			height: t,
			widthSegments: i,
			heightSegments: n
		}, this.fromBufferGeometry(new G(e, t, i, n)), this.mergeVertices()
	}

	function G(e, t, i, n) {
		H.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
			width: e,
			height: t,
			widthSegments: i,
			heightSegments: n
		};
		var r = (e = e || 1) / 2,
			o = (t = t || 1) / 2,
			s = (i = Math.floor(i) || 1) + 1,
			a = (n = Math.floor(n) || 1) + 1,
			l = e / i,
			c = t / n,
			h = [],
			u = [],
			d = [],
			p = [];
		for (e = 0; e < a; e++) {
			var f = e * c - o;
			for (t = 0; t < s; t++) u.push(t * l - r, -f, 0), d.push(0, 0, 1), p.push(t / i), p.push(1 - e / n)
		}
		for (e = 0; e < n; e++)
			for (t = 0; t < i; t++) r = t + s * (e + 1), o = t + 1 + s * (e + 1), a = t + 1 + s * e, h.push(t + s * e, r, a), h.push(r, o, a);
		this.setIndex(h), this.addAttribute("position", new z(u, 3)), this.addAttribute("normal", new z(d, 3)), this.addAttribute("uv", new z(p, 2))
	}

	function V() {
		Object.defineProperty(this, "id", {
			value: Mo++
		}), this.uuid = uo.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
	}

	function W(e) {
		V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
			derivatives: !1,
			fragDepth: !1,
			drawBuffers: !1,
			shaderTextureLOD: !1
		}, this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0]
		}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
	}

	function q(e, t) {
		this.origin = void 0 !== e ? e : new r, this.direction = void 0 !== t ? t : new r
	}

	function X(e, t, i) {
		this.a = void 0 !== e ? e : new r, this.b = void 0 !== t ? t : new r, this.c = void 0 !== i ? i : new r
	}

	function Y(e) {
		V.call(this), this.type = "MeshBasicMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(e)
	}

	function Z(e, t) {
		S.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new H, this.material = void 0 !== t ? t : new Y({
			color: 16777215 * Math.random()
		}), this.drawMode = 0, this.updateMorphTargets()
	}

	function Q(e, t, i, n) {
		function r(e, i) {
			t.buffers.color.setClear(e.r, e.g, e.b, i, n)
		}
		var o, s, a = new b(0),
			l = 0,
			c = null,
			h = 0;
		return {
			getClearColor: function() {
				return a
			},
			setClearColor: function(e, t) {
				a.set(e), r(a, l = void 0 !== t ? t : 1)
			},
			getClearAlpha: function() {
				return l
			},
			setClearAlpha: function(e) {
				r(a, l = e)
			},
			render: function(t, n, u, d) {
				n = n.background, (u = (u = e.vr).getSession && u.getSession()) && "additive" === u.environmentBlendMode && (n = null), null === n ? (r(a, l), c = null, h = 0) : n && n.isColor && (r(n, 1), d = !0, c = null, h = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === s && ((s = new Z(new U(1, 1, 1), new W({
					type: "BackgroundCubeMaterial",
					uniforms: v(wo.cube.uniforms),
					vertexShader: wo.cube.vertexShader,
					fragmentShader: wo.cube.fragmentShader,
					side: 1,
					depthTest: !1,
					depthWrite: !1,
					fog: !1
				}))).geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function(e, t, i) {
					this.matrixWorld.copyPosition(i.matrixWorld)
				}, Object.defineProperty(s.material, "map", {
					get: function() {
						return this.uniforms.tCube.value
					}
				}), i.update(s)), d = n.isWebGLRenderTargetCube ? n.texture : n, s.material.uniforms.tCube.value = d, s.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, c === n && h === d.version || (s.material.needsUpdate = !0, c = n, h = d.version), t.unshift(s, s.geometry, s.material, 0, 0, null)) : n && n.isTexture && (void 0 === o && ((o = new Z(new G(2, 2), new W({
					type: "BackgroundMaterial",
					uniforms: v(wo.background.uniforms),
					vertexShader: wo.background.vertexShader,
					fragmentShader: wo.background.fragmentShader,
					side: 0,
					depthTest: !1,
					depthWrite: !1,
					fog: !1
				}))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", {
					get: function() {
						return this.uniforms.t2D.value
					}
				}), i.update(o)), o.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), o.material.uniforms.uvTransform.value.copy(n.matrix), c === n && h === n.version || (o.material.needsUpdate = !0, c = n, h = n.version), t.unshift(o, o.geometry, o.material, 0, 0, null))
			}
		}
	}

	function J(e, t, i, n) {
		var r;
		this.setMode = function(e) {
			r = e
		}, this.render = function(t, n) {
			e.drawArrays(r, t, n), i.update(n, r)
		}, this.renderInstances = function(o, s, a) {
			if (n.isWebGL2) var l = e;
			else if (null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
			l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, s, a, o.maxInstancedCount), i.update(a, r, o.maxInstancedCount)
		}
	}

	function K(e, t, i) {
		function n(t) {
			if ("highp" === t) {
				if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
				t = "mediump"
			}
			return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
		}
		var r, o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
			s = void 0 !== i.precision ? i.precision : "highp",
			a = n(s);
		a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a), i = !0 === i.logarithmicDepthBuffer, a = e.getParameter(34930);
		var l = e.getParameter(35660),
			c = e.getParameter(3379),
			h = e.getParameter(34076),
			u = e.getParameter(34921),
			d = e.getParameter(36347),
			p = e.getParameter(36348),
			f = e.getParameter(36349),
			m = 0 < l,
			g = o || !!t.get("OES_texture_float");
		return {
			isWebGL2: o,
			getMaxAnisotropy: function() {
				if (void 0 !== r) return r;
				var i = t.get("EXT_texture_filter_anisotropic");
				return r = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
			},
			getMaxPrecision: n,
			precision: s,
			logarithmicDepthBuffer: i,
			maxTextures: a,
			maxVertexTextures: l,
			maxTextureSize: c,
			maxCubemapSize: h,
			maxAttributes: u,
			maxVertexUniforms: d,
			maxVaryings: p,
			maxFragmentUniforms: f,
			vertexTextures: m,
			floatFragmentTextures: g,
			floatVertexTextures: m && g,
			maxSamples: o ? e.getParameter(36183) : 0
		}
	}

	function $() {
		function e() {
			h.value !== n && (h.value = n, h.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
		}

		function t(e, t, n, r) {
			var o = null !== e ? e.length : 0,
				s = null;
			if (0 !== o) {
				if (s = h.value, !0 !== r || null === s)
					for (r = n + 4 * o, t = t.matrixWorldInverse, c.getNormalMatrix(t), (null === s || s.length < r) && (s = new Float32Array(r)), r = 0; r !== o; ++r, n += 4) l.copy(e[r]).applyMatrix4(t, c), l.normal.toArray(s, n), s[n + 3] = l.constant;
				h.value = s, h.needsUpdate = !0
			}
			return i.numPlanes = o, s
		}
		var i = this,
			n = null,
			r = 0,
			s = !1,
			a = !1,
			l = new f,
			c = new o,
			h = {
				value: null,
				needsUpdate: !1
			};
		this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function(e, i, o) {
			var a = 0 !== e.length || i || 0 !== r || s;
			return s = i, n = t(e, o, 0), r = e.length, a
		}, this.beginShadows = function() {
			a = !0, t(null)
		}, this.endShadows = function() {
			a = !1, e()
		}, this.setState = function(i, o, l, c, u, d) {
			if (!s || null === i || 0 === i.length || a && !l) a ? t(null) : e();
			else {
				var p = 4 * (l = a ? 0 : r),
					f = u.clippingState || null;
				for (h.value = f, f = t(i, c, p, d), i = 0; i !== p; ++i) f[i] = n[i];
				u.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += l
			}
		}
	}

	function ee(e) {
		var t = {};
		return {
			get: function(i) {
				if (void 0 !== t[i]) return t[i];
				switch (i) {
					case "WEBGL_depth_texture":
						var n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
						break;
					case "EXT_texture_filter_anisotropic":
						n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
						break;
					case "WEBGL_compressed_texture_s3tc":
						n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
						break;
					case "WEBGL_compressed_texture_pvrtc":
						n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
						break;
					default:
						n = e.getExtension(i)
				}
				return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n
			}
		}
	}

	function te(e, t, i) {
		function n(e) {
			var s = e.target;
			for (var a in null !== (e = r[s.id]).index && t.remove(e.index), e.attributes) t.remove(e.attributes[a]);
			s.removeEventListener("dispose", n), delete r[s.id], (a = o[e.id]) && (t.remove(a), delete o[e.id]), i.memory.geometries--
		}
		var r = {},
			o = {};
		return {
			get: function(e, t) {
				var o = r[t.id];
				return o || (t.addEventListener("dispose", n), t.isBufferGeometry ? o = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new H).setFromObject(e)), o = t._bufferGeometry), r[t.id] = o, i.memory.geometries++, o)
			},
			update: function(e) {
				var i = e.index,
					n = e.attributes;
				for (var r in null !== i && t.update(i, 34963), n) t.update(n[r], 34962);
				for (r in e = e.morphAttributes) {
					n = 0;
					for (var o = (i = e[r]).length; n < o; n++) t.update(i[n], 34962)
				}
			},
			getWireframeAttribute: function(e) {
				var i = o[e.id];
				if (i) return i;
				i = [];
				var n = e.index,
					r = e.attributes;
				if (null !== n) {
					r = 0;
					for (var s = (n = n.array).length; r < s; r += 3) {
						var a = n[r + 0],
							l = n[r + 1],
							c = n[r + 2];
						i.push(a, l, l, c, c, a)
					}
				} else
					for (n = r.position.array, r = 0, s = n.length / 3 - 1; r < s; r += 3) a = r + 0, l = r + 1, c = r + 2, i.push(a, l, l, c, c, a);
				return i = new(65535 < B(i) ? D : R)(i, 1), t.update(i, 34963), o[e.id] = i
			}
		}
	}

	function ie(e, t, i, n) {
		var r, o, s;
		this.setMode = function(e) {
			r = e
		}, this.setIndex = function(e) {
			o = e.type, s = e.bytesPerElement
		}, this.render = function(t, n) {
			e.drawElements(r, n, o, t * s), i.update(n, r)
		}, this.renderInstances = function(a, l, c) {
			if (n.isWebGL2) var h = e;
			else if (null === (h = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
			h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, o, l * s, a.maxInstancedCount), i.update(c, r, a.maxInstancedCount)
		}
	}

	function ne(e) {
		var t = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};
		return {
			memory: {
				geometries: 0,
				textures: 0
			},
			render: t,
			programs: null,
			autoReset: !0,
			reset: function() {
				t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
			},
			update: function(e, i, n) {
				switch (n = n || 1, t.calls++, i) {
					case 4:
						t.triangles += e / 3 * n;
						break;
					case 5:
					case 6:
						t.triangles += n * (e - 2);
						break;
					case 1:
						t.lines += e / 2 * n;
						break;
					case 3:
						t.lines += n * (e - 1);
						break;
					case 2:
						t.lines += n * e;
						break;
					case 0:
						t.points += n * e;
						break;
					default:
						console.error("THREE.WebGLInfo: Unknown draw mode:", i)
				}
			}
		}
	}

	function re(e, t) {
		return Math.abs(t[1]) - Math.abs(e[1])
	}

	function oe(e) {
		var t = {},
			i = new Float32Array(8);
		return {
			update: function(n, r, o, s) {
				var a = n.morphTargetInfluences,
					l = a.length;
				if (void 0 === (n = t[r.id])) {
					n = [];
					for (var c = 0; c < l; c++) n[c] = [c, 0];
					t[r.id] = n
				}
				var h = o.morphTargets && r.morphAttributes.position;
				for (o = o.morphNormals && r.morphAttributes.normal, c = 0; c < l; c++) {
					var u = n[c];
					0 !== u[1] && (h && r.removeAttribute("morphTarget" + c), o && r.removeAttribute("morphNormal" + c))
				}
				for (c = 0; c < l; c++)(u = n[c])[0] = c, u[1] = a[c];
				for (n.sort(re), c = 0; 8 > c; c++)(u = n[c]) && (a = u[0], l = u[1]) ? (h && r.addAttribute("morphTarget" + c, h[a]), o && r.addAttribute("morphNormal" + c, o[a]), i[c] = l) : i[c] = 0;
				s.getUniforms().setValue(e, "morphTargetInfluences", i)
			}
		}
	}

	function se(e, t) {
		var i = {};
		return {
			update: function(n) {
				var r = t.render.frame,
					o = n.geometry,
					s = e.get(n, o);
				return i[s.id] !== r && (o.isGeometry && s.updateFromObject(n), e.update(s), i[s.id] = r), s
			},
			dispose: function() {
				i = {}
			}
		}
	}

	function ae(e, t, i, n, r, o, a, l, c, h) {
		e = void 0 !== e ? e : [], s.call(this, e, void 0 !== t ? t : 301, i, n, r, o, void 0 !== a ? a : 1022, l, c, h), this.flipY = !1
	}

	function le(e, t, i, n) {
		s.call(this, null), this.image = {
			data: e,
			width: t,
			height: i,
			depth: n
		}, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
	}

	function ce(e, t, i, n) {
		s.call(this, null), this.image = {
			data: e,
			width: t,
			height: i,
			depth: n
		}, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1
	}

	function he(e, t, i) {
		var n = e[0];
		if (0 >= n || 0 < n) return e;
		var r = t * i,
			o = Co[r];
		if (void 0 === o && (o = new Float32Array(r), Co[r] = o), 0 !== t)
			for (n.toArray(o, 0), n = 1, r = 0; n !== t; ++n) r += i, e[n].toArray(o, r);
		return o
	}

	function ue(e, t) {
		if (e.length !== t.length) return !1;
		for (var i = 0, n = e.length; i < n; i++)
			if (e[i] !== t[i]) return !1;
		return !0
	}

	function de(e, t) {
		for (var i = 0, n = t.length; i < n; i++) e[i] = t[i]
	}

	function pe(e, t) {
		var i = Po[t];
		void 0 === i && (i = new Int32Array(t), Po[t] = i);
		for (var n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
		return i
	}

	function fe(e, t) {
		var i = this.cache;
		i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
	}

	function me(e, t) {
		var i = this.cache;
		void 0 !== t.x ? i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y) : ue(i, t) || (e.uniform2fv(this.addr, t), de(i, t))
	}

	function ge(e, t) {
		var i = this.cache;
		void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z) : void 0 !== t.r ? i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b) : ue(i, t) || (e.uniform3fv(this.addr, t), de(i, t))
	}

	function ve(e, t) {
		var i = this.cache;
		void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w) : ue(i, t) || (e.uniform4fv(this.addr, t), de(i, t))
	}

	function ye(e, t) {
		var i = this.cache,
			n = t.elements;
		void 0 === n ? ue(i, t) || (e.uniformMatrix2fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Oo.set(n), e.uniformMatrix2fv(this.addr, !1, Oo), de(i, n))
	}

	function be(e, t) {
		var i = this.cache,
			n = t.elements;
		void 0 === n ? ue(i, t) || (e.uniformMatrix3fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Ro.set(n), e.uniformMatrix3fv(this.addr, !1, Ro), de(i, n))
	}

	function we(e, t) {
		var i = this.cache,
			n = t.elements;
		void 0 === n ? ue(i, t) || (e.uniformMatrix4fv(this.addr, !1, t), de(i, t)) : ue(i, n) || (Io.set(n), e.uniformMatrix4fv(this.addr, !1, Io), de(i, n))
	}

	function xe(e, t, i) {
		var n = this.cache,
			r = i.allocateTextureUnit();
		n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(t || So, r)
	}

	function _e(e, t, i) {
		var n = this.cache,
			r = i.allocateTextureUnit();
		n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || To, r)
	}

	function Ee(e, t, i) {
		var n = this.cache,
			r = i.allocateTextureUnit();
		n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || Ao, r)
	}

	function Me(e, t, i) {
		var n = this.cache,
			r = i.allocateTextureUnit();
		n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(t || Lo, r)
	}

	function Se(e, t) {
		var i = this.cache;
		i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
	}

	function Te(e, t) {
		var i = this.cache;
		ue(i, t) || (e.uniform2iv(this.addr, t), de(i, t))
	}

	function Ae(e, t) {
		var i = this.cache;
		ue(i, t) || (e.uniform3iv(this.addr, t), de(i, t))
	}

	function Le(e, t) {
		var i = this.cache;
		ue(i, t) || (e.uniform4iv(this.addr, t), de(i, t))
	}

	function Ce(e, t) {
		e.uniform1fv(this.addr, t)
	}

	function Pe(e, t) {
		e.uniform1iv(this.addr, t)
	}

	function Ie(e, t) {
		e.uniform2iv(this.addr, t)
	}

	function Re(e, t) {
		e.uniform3iv(this.addr, t)
	}

	function Oe(e, t) {
		e.uniform4iv(this.addr, t)
	}

	function De(e, t) {
		t = he(t, this.size, 2), e.uniform2fv(this.addr, t)
	}

	function ze(e, t) {
		t = he(t, this.size, 3), e.uniform3fv(this.addr, t)
	}

	function ke(e, t) {
		t = he(t, this.size, 4), e.uniform4fv(this.addr, t)
	}

	function Ne(e, t) {
		t = he(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t)
	}

	function Be(e, t) {
		t = he(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t)
	}

	function He(e, t) {
		t = he(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t)
	}

	function Fe(e, t, i) {
		var n = t.length,
			r = pe(i, n);
		for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTexture2D(t[e] || So, r[e])
	}

	function Ue(e, t, i) {
		var n = t.length,
			r = pe(i, n);
		for (e.uniform1iv(this.addr, r), e = 0; e !== n; ++e) i.safeSetTextureCube(t[e] || Lo, r[e])
	}

	function je(e, t, i) {
		this.id = e, this.addr = i, this.cache = [], this.setValue = function(e) {
			switch (e) {
				case 5126:
					return fe;
				case 35664:
					return me;
				case 35665:
					return ge;
				case 35666:
					return ve;
				case 35674:
					return ye;
				case 35675:
					return be;
				case 35676:
					return we;
				case 35678:
				case 36198:
					return xe;
				case 35679:
					return Ee;
				case 35680:
					return Me;
				case 36289:
					return _e;
				case 5124:
				case 35670:
					return Se;
				case 35667:
				case 35671:
					return Te;
				case 35668:
				case 35672:
					return Ae;
				case 35669:
				case 35673:
					return Le
			}
		}(t.type)
	}

	function Ge(e, t, i) {
		this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function(e) {
			switch (e) {
				case 5126:
					return Ce;
				case 35664:
					return De;
				case 35665:
					return ze;
				case 35666:
					return ke;
				case 35674:
					return Ne;
				case 35675:
					return Be;
				case 35676:
					return He;
				case 35678:
					return Fe;
				case 35680:
					return Ue;
				case 5124:
				case 35670:
					return Pe;
				case 35667:
				case 35671:
					return Ie;
				case 35668:
				case 35672:
					return Re;
				case 35669:
				case 35673:
					return Oe
			}
		}(t.type)
	}

	function Ve(e) {
		this.id = e, this.seq = [], this.map = {}
	}

	function We(e, t) {
		this.seq = [], this.map = {};
		for (var i = e.getProgramParameter(t, 35718), n = 0; n < i; ++n) {
			var r = e.getActiveUniform(t, n),
				o = e.getUniformLocation(t, r.name),
				s = this,
				a = r.name,
				l = a.length;
			for (Do.lastIndex = 0;;) {
				var c = Do.exec(a),
					h = Do.lastIndex,
					u = c[1],
					d = c[3];
				if ("]" === c[2] && (u |= 0), void 0 === d || "[" === d && h + 2 === l) {
					a = s, r = void 0 === d ? new je(u, r, o) : new Ge(u, r, o), a.seq.push(r), a.map[r.id] = r;
					break
				}
				void 0 === (d = s.map[u]) && (d = new Ve(u), u = s, s = d, u.seq.push(s), u.map[s.id] = s), s = d
			}
		}
	}

	function qe(e, t, i, n) {
		var r = e.createShader(t);
		return e.shaderSource(r, i), e.compileShader(r), !0 === n && (!1 === e.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(r), function(e) {
			e = e.split("\n");
			for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
			return e.join("\n")
		}(i))), r
	}

	function Xe(e) {
		switch (e) {
			case 3e3:
				return ["Linear", "( value )"];
			case 3001:
				return ["sRGB", "( value )"];
			case 3002:
				return ["RGBE", "( value )"];
			case 3004:
				return ["RGBM", "( value, 7.0 )"];
			case 3005:
				return ["RGBM", "( value, 16.0 )"];
			case 3006:
				return ["RGBD", "( value, 256.0 )"];
			case 3007:
				return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
			default:
				throw Error("unsupported encoding: " + e)
		}
	}

	function Ye(e, t) {
		return "vec4 " + e + "( vec4 value ) { return " + (t = Xe(t))[0] + "ToLinear" + t[1] + "; }"
	}

	function Ze(e, t) {
		return "vec4 " + e + "( vec4 value ) { return LinearTo" + (t = Xe(t))[0] + t[1] + "; }"
	}

	function Qe(e, t) {
		switch (t) {
			case 1:
				t = "Linear";
				break;
			case 2:
				t = "Reinhard";
				break;
			case 3:
				t = "Uncharted2";
				break;
			case 4:
				t = "OptimizedCineon";
				break;
			case 5:
				t = "ACESFilmic";
				break;
			default:
				throw Error("unsupported toneMapping: " + t)
		}
		return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
	}

	function Je(e) {
		return "" !== e
	}

	function Ke(e, t) {
		return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
	}

	function $e(e, t) {
		return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
	}

	function et(e) {
		return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function(e, t) {
			if (void 0 === (e = go[t])) throw Error("Can not resolve #include <" + t + ">");
			return et(e)
		}))
	}

	function tt(e) {
		return e.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function(e, t, i, n) {
			for (e = "", t = parseInt(t); t < parseInt(i); t++) e += n.replace(/\[ i \]/g, "[ " + t + " ]");
			return e
		}))
	}

	function it(e, t, i, n, r, o, s, a) {
		var l = e.context,
			c = n.defines,
			h = r.vertexShader,
			u = r.fragmentShader,
			d = "SHADOWMAP_TYPE_BASIC";
		1 === o.shadowMapType ? d = "SHADOWMAP_TYPE_PCF" : 2 === o.shadowMapType && (d = "SHADOWMAP_TYPE_PCF_SOFT");
		var p = "ENVMAP_TYPE_CUBE",
			f = "ENVMAP_MODE_REFLECTION",
			m = "ENVMAP_BLENDING_MULTIPLY";
		if (o.envMap) {
			switch (n.envMap.mapping) {
				case 301:
				case 302:
					p = "ENVMAP_TYPE_CUBE";
					break;
				case 306:
				case 307:
					p = "ENVMAP_TYPE_CUBE_UV";
					break;
				case 303:
				case 304:
					p = "ENVMAP_TYPE_EQUIREC";
					break;
				case 305:
					p = "ENVMAP_TYPE_SPHERE"
			}
			switch (n.envMap.mapping) {
				case 302:
				case 304:
					f = "ENVMAP_MODE_REFRACTION"
			}
			switch (n.combine) {
				case 0:
					m = "ENVMAP_BLENDING_MULTIPLY";
					break;
				case 1:
					m = "ENVMAP_BLENDING_MIX";
					break;
				case 2:
					m = "ENVMAP_BLENDING_ADD"
			}
		}
		var g, v, y = 0 < e.gammaFactor ? e.gammaFactor : 1,
			b = s.isWebGL2 ? "" : function(e, t, i) {
				return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Je).join("\n")
			}(n.extensions, o, t),
			w = function(e) {
				var t, i = [];
				for (t in e) {
					var n = e[t];
					!1 !== n && i.push("#define " + t + " " + n)
				}
				return i.join("\n")
			}(c),
			x = l.createProgram();
		return n.isRawShaderMaterial ? (0 < (c = [w].filter(Je).join("\n")).length && (c += "\n"), 0 < (t = [b, w].filter(Je).join("\n")).length && (t += "\n")) : (c = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, w, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (s.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Je).join("\n"), t = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, w, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (s.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (s.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? go.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? Qe("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? go.encodings_pars_fragment : "", o.mapEncoding ? Ye("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Ye("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Ye("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Ye("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? Ze("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Je).join("\n")), h = $e(h = Ke(h = et(h), o), o), u = $e(u = Ke(u = et(u), o), o), h = tt(h), u = tt(u), s.isWebGL2 && !n.isRawShaderMaterial && (s = !1, d = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== h.match(d) && null !== u.match(d) && (s = !0, h = h.replace(d, ""), u = u.replace(d, "")), c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c, t = ["#version 300 es\n\n#define varying in", s ? "" : "out highp vec4 pc_fragColor;", s ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + t), u = t + u, h = qe(l, 35633, c + h, e.debug.checkShaderErrors), u = qe(l, 35632, u, e.debug.checkShaderErrors), l.attachShader(x, h), l.attachShader(x, u), void 0 !== n.index0AttributeName ? l.bindAttribLocation(x, 0, n.index0AttributeName) : !0 === o.morphTargets && l.bindAttribLocation(x, 0, "position"), l.linkProgram(x), e.debug.checkShaderErrors && (e = l.getProgramInfoLog(x).trim(), o = l.getShaderInfoLog(h).trim(), s = l.getShaderInfoLog(u).trim(), p = d = !0, !1 === l.getProgramParameter(x, 35714) ? (d = !1, console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(x, 35715), "gl.getProgramInfoLog", e, o, s)) : "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== o && "" !== s || (p = !1), p && (this.diagnostics = {
			runnable: d,
			material: n,
			programLog: e,
			vertexShader: {
				log: o,
				prefix: c
			},
			fragmentShader: {
				log: s,
				prefix: t
			}
		})), l.deleteShader(h), l.deleteShader(u), this.getUniforms = function() {
			return void 0 === g && (g = new We(l, x, a)), g
		}, this.getAttributes = function() {
			if (void 0 === v) {
				for (var e = {}, t = l.getProgramParameter(x, 35721), i = 0; i < t; i++) {
					var n = l.getActiveAttrib(x, i).name;
					e[n] = l.getAttribLocation(x, n)
				}
				v = e
			}
			return v
		}, this.destroy = function() {
			l.deleteProgram(x), this.program = void 0
		}, Object.defineProperties(this, {
			uniforms: {
				get: function() {
					return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
				}
			},
			attributes: {
				get: function() {
					return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
				}
			}
		}), this.name = r.name, this.id = zo++, this.code = i, this.usedTimes = 1, this.program = x, this.vertexShader = h, this.fragmentShader = u, this
	}

	function nt(e, t, i, n) {
		function r(e, t) {
			if (e) e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding);
			else var i = 3e3;
			return 3e3 === i && t && (i = 3007), i
		}
		var o = [],
			s = {
				MeshDepthMaterial: "depth",
				MeshDistanceMaterial: "distanceRGBA",
				MeshNormalMaterial: "normal",
				MeshBasicMaterial: "basic",
				MeshLambertMaterial: "lambert",
				MeshPhongMaterial: "phong",
				MeshToonMaterial: "phong",
				MeshStandardMaterial: "physical",
				MeshPhysicalMaterial: "physical",
				MeshMatcapMaterial: "matcap",
				LineBasicMaterial: "basic",
				LineDashedMaterial: "dashed",
				PointsMaterial: "points",
				ShadowMaterial: "shadow",
				SpriteMaterial: "sprite"
			},
			a = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
		this.getParameters = function(t, n, o, a, l, c, h) {
			var u = s[t.type];
			if (h.isSkinnedMesh) {
				var d = h.skeleton.bones;
				if (i.floatVertexTextures) d = 1024;
				else {
					var p = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), d.length);
					p < d.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + d.length + " bones. This GPU supports " + p + "."), d = 0) : d = p
				}
			} else d = 0;
			p = i.precision, null !== t.precision && (p = i.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", p, "instead.");
			var f = e.getRenderTarget();
			return {
				shaderID: u,
				precision: p,
				supportsVertexTextures: i.vertexTextures,
				outputEncoding: r(f ? f.texture : null, e.gammaOutput),
				map: !!t.map,
				mapEncoding: r(t.map, e.gammaInput),
				matcap: !!t.matcap,
				matcapEncoding: r(t.matcap, e.gammaInput),
				envMap: !!t.envMap,
				envMapMode: t.envMap && t.envMap.mapping,
				envMapEncoding: r(t.envMap, e.gammaInput),
				envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping),
				lightMap: !!t.lightMap,
				aoMap: !!t.aoMap,
				emissiveMap: !!t.emissiveMap,
				emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
				bumpMap: !!t.bumpMap,
				normalMap: !!t.normalMap,
				objectSpaceNormalMap: 1 === t.normalMapType,
				displacementMap: !!t.displacementMap,
				roughnessMap: !!t.roughnessMap,
				metalnessMap: !!t.metalnessMap,
				specularMap: !!t.specularMap,
				alphaMap: !!t.alphaMap,
				gradientMap: !!t.gradientMap,
				combine: t.combine,
				vertexTangents: t.normalMap && t.vertexTangents,
				vertexColors: t.vertexColors,
				fog: !!a,
				useFog: t.fog,
				fogExp: a && a.isFogExp2,
				flatShading: t.flatShading,
				sizeAttenuation: t.sizeAttenuation,
				logarithmicDepthBuffer: i.logarithmicDepthBuffer,
				skinning: t.skinning && 0 < d,
				maxBones: d,
				useVertexTexture: i.floatVertexTextures,
				morphTargets: t.morphTargets,
				morphNormals: t.morphNormals,
				maxMorphTargets: e.maxMorphTargets,
				maxMorphNormals: e.maxMorphNormals,
				numDirLights: n.directional.length,
				numPointLights: n.point.length,
				numSpotLights: n.spot.length,
				numRectAreaLights: n.rectArea.length,
				numHemiLights: n.hemi.length,
				numClippingPlanes: l,
				numClipIntersection: c,
				dithering: t.dithering,
				shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && 0 < o.length,
				shadowMapType: e.shadowMap.type,
				toneMapping: e.toneMapping,
				physicallyCorrectLights: e.physicallyCorrectLights,
				premultipliedAlpha: t.premultipliedAlpha,
				alphaTest: t.alphaTest,
				doubleSided: 2 === t.side,
				flipSided: 1 === t.side,
				depthPacking: void 0 !== t.depthPacking && t.depthPacking
			}
		}, this.getProgramCode = function(t, i) {
			var n = [];
			if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)
				for (var r in t.defines) n.push(r), n.push(t.defines[r]);
			for (r = 0; r < a.length; r++) n.push(i[a[r]]);
			return n.push(t.onBeforeCompile.toString()), n.push(e.gammaOutput), n.push(e.gammaFactor), n.join()
		}, this.acquireProgram = function(r, s, a, l) {
			for (var c, h = 0, u = o.length; h < u; h++) {
				var d = o[h];
				if (d.code === l) {
					++(c = d).usedTimes;
					break
				}
			}
			return void 0 === c && (c = new it(e, t, l, r, s, a, i, n), o.push(c)), c
		}, this.releaseProgram = function(e) {
			if (0 == --e.usedTimes) {
				var t = o.indexOf(e);
				o[t] = o[o.length - 1], o.pop(), e.destroy()
			}
		}, this.programs = o
	}

	function rt() {
		var e = new WeakMap;
		return {
			get: function(t) {
				var i = e.get(t);
				return void 0 === i && (i = {}, e.set(t, i)), i
			},
			remove: function(t) {
				e.delete(t)
			},
			update: function(t, i, n) {
				e.get(t)[i] = n
			},
			dispose: function() {
				e = new WeakMap
			}
		}
	}

	function ot(e, t) {
		return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
	}

	function st(e, t) {
		return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
	}

	function at() {
		function e(e, n, r, s, a, l) {
			var c = t[i];
			return void 0 === c ? (c = {
				id: e.id,
				object: e,
				geometry: n,
				material: r,
				program: r.program || o,
				groupOrder: s,
				renderOrder: e.renderOrder,
				z: a,
				group: l
			}, t[i] = c) : (c.id = e.id, c.object = e, c.geometry = n, c.material = r, c.program = r.program || o, c.groupOrder = s, c.renderOrder = e.renderOrder, c.z = a, c.group = l), i++, c
		}
		var t = [],
			i = 0,
			n = [],
			r = [],
			o = {
				id: -1
			};
		return {
			opaque: n,
			transparent: r,
			init: function() {
				i = 0, n.length = 0, r.length = 0
			},
			push: function(t, i, o, s, a, l) {
				t = e(t, i, o, s, a, l), (!0 === o.transparent ? r : n).push(t)
			},
			unshift: function(t, i, o, s, a, l) {
				t = e(t, i, o, s, a, l), (!0 === o.transparent ? r : n).unshift(t)
			},
			sort: function() {
				1 < n.length && n.sort(ot), 1 < r.length && r.sort(st)
			}
		}
	}

	function lt() {
		function e(i) {
			(i = i.target).removeEventListener("dispose", e), delete t[i.id]
		}
		var t = {};
		return {
			get: function(i, n) {
				var r = t[i.id];
				if (void 0 === r) {
					var o = new at;
					t[i.id] = {}, t[i.id][n.id] = o, i.addEventListener("dispose", e)
				} else void 0 === (o = r[n.id]) && (o = new at, r[n.id] = o);
				return o
			},
			dispose: function() {
				t = {}
			}
		}
	}

	function ct() {
		var e = {};
		return {
			get: function(t) {
				if (void 0 !== e[t.id]) return e[t.id];
				switch (t.type) {
					case "DirectionalLight":
						var n = {
							direction: new r,
							color: new b,
							shadow: !1,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new i
						};
						break;
					case "SpotLight":
						n = {
							position: new r,
							direction: new r,
							color: new b,
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,
							shadow: !1,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new i
						};
						break;
					case "PointLight":
						n = {
							position: new r,
							color: new b,
							distance: 0,
							decay: 0,
							shadow: !1,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new i,
							shadowCameraNear: 1,
							shadowCameraFar: 1e3
						};
						break;
					case "HemisphereLight":
						n = {
							direction: new r,
							skyColor: new b,
							groundColor: new b
						};
						break;
					case "RectAreaLight":
						n = {
							color: new b,
							position: new r,
							halfWidth: new r,
							halfHeight: new r
						}
				}
				return e[t.id] = n
			}
		}
	}

	function ht() {
		for (var e = new ct, t = {
				id: ko++,
				hash: {
					stateID: -1,
					directionalLength: -1,
					pointLength: -1,
					spotLength: -1,
					rectAreaLength: -1,
					hemiLength: -1,
					shadowsLength: -1
				},
				ambient: [0, 0, 0],
				probe: [],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				rectArea: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: []
			}, i = 0; 9 > i; i++) t.probe.push(new r);
		var n = new r,
			o = new g,
			s = new g;
		return {
			setup: function(i, r, a) {
				for (var l = 0, c = 0, h = 0, u = 0; 9 > u; u++) t.probe[u].set(0, 0, 0);
				var d = 0,
					p = 0,
					f = 0,
					m = 0,
					g = 0;
				a = a.matrixWorldInverse, u = 0;
				for (var v = i.length; u < v; u++) {
					var y = i[u],
						b = y.color,
						w = y.intensity,
						x = y.distance,
						_ = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
					if (y.isAmbientLight) l += b.r * w, c += b.g * w, h += b.b * w;
					else if (y.isLightProbe)
						for (_ = 0; 9 > _; _++) t.probe[_].addScaledVector(y.sh.coefficients[_], w);
					else if (y.isDirectionalLight) {
						var E = e.get(y);
						E.color.copy(y.color).multiplyScalar(y.intensity), E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(a), (E.shadow = y.castShadow) && (w = y.shadow, E.shadowBias = w.bias, E.shadowRadius = w.radius, E.shadowMapSize = w.mapSize), t.directionalShadowMap[d] = _, t.directionalShadowMatrix[d] = y.shadow.matrix, t.directional[d] = E, d++
					} else y.isSpotLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(a), E.color.copy(b).multiplyScalar(w), E.distance = x, E.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(a), E.coneCos = Math.cos(y.angle), E.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), E.decay = y.decay, (E.shadow = y.castShadow) && (w = y.shadow, E.shadowBias = w.bias, E.shadowRadius = w.radius, E.shadowMapSize = w.mapSize), t.spotShadowMap[f] = _, t.spotShadowMatrix[f] = y.shadow.matrix, t.spot[f] = E, f++) : y.isRectAreaLight ? ((E = e.get(y)).color.copy(b).multiplyScalar(w), E.position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(a), s.identity(), o.copy(y.matrixWorld), o.premultiply(a), s.extractRotation(o), E.halfWidth.set(.5 * y.width, 0, 0), E.halfHeight.set(0, .5 * y.height, 0), E.halfWidth.applyMatrix4(s), E.halfHeight.applyMatrix4(s), t.rectArea[m] = E, m++) : y.isPointLight ? ((E = e.get(y)).position.setFromMatrixPosition(y.matrixWorld), E.position.applyMatrix4(a), E.color.copy(y.color).multiplyScalar(y.intensity), E.distance = y.distance, E.decay = y.decay, (E.shadow = y.castShadow) && (w = y.shadow, E.shadowBias = w.bias, E.shadowRadius = w.radius, E.shadowMapSize = w.mapSize, E.shadowCameraNear = w.camera.near, E.shadowCameraFar = w.camera.far), t.pointShadowMap[p] = _, t.pointShadowMatrix[p] = y.shadow.matrix, t.point[p] = E, p++) : y.isHemisphereLight && ((E = e.get(y)).direction.setFromMatrixPosition(y.matrixWorld), E.direction.transformDirection(a), E.direction.normalize(), E.skyColor.copy(y.color).multiplyScalar(w), E.groundColor.copy(y.groundColor).multiplyScalar(w), t.hemi[g] = E, g++)
				}
				t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = h, t.directional.length = d, t.spot.length = f, t.rectArea.length = m, t.point.length = p, t.hemi.length = g, t.hash.stateID = t.id, t.hash.directionalLength = d, t.hash.pointLength = p, t.hash.spotLength = f, t.hash.rectAreaLength = m, t.hash.hemiLength = g, t.hash.shadowsLength = r.length
			},
			state: t
		}
	}

	function ut() {
		var e = new ht,
			t = [],
			i = [];
		return {
			init: function() {
				t.length = 0, i.length = 0
			},
			state: {
				lightsArray: t,
				shadowsArray: i,
				lights: e
			},
			setupLights: function(n) {
				e.setup(t, i, n)
			},
			pushLight: function(e) {
				t.push(e)
			},
			pushShadow: function(e) {
				i.push(e)
			}
		}
	}

	function dt() {
		function e(i) {
			(i = i.target).removeEventListener("dispose", e), delete t[i.id]
		}
		var t = {};
		return {
			get: function(i, n) {
				if (void 0 === t[i.id]) {
					var r = new ut;
					t[i.id] = {}, t[i.id][n.id] = r, i.addEventListener("dispose", e)
				} else void 0 === t[i.id][n.id] ? (r = new ut, t[i.id][n.id] = r) : r = t[i.id][n.id];
				return r
			},
			dispose: function() {
				t = {}
			}
		}
	}

	function pt(e) {
		V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(e)
	}

	function ft(e) {
		V.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new r, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(e)
	}

	function mt(e, t, n) {
		function o(t, i, n, r, o, s) {
			var a = t.geometry,
				l = v,
				c = t.customDepthMaterial;
			return n && (l = y, c = t.customDistanceMaterial), c ? l = c : (c = !1, i.morphTargets && (a && a.isBufferGeometry ? c = a.morphAttributes && a.morphAttributes.position && 0 < a.morphAttributes.position.length : a && a.isGeometry && (c = a.morphTargets && 0 < a.morphTargets.length)), t.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t), a = 0, c && (a |= 1), (t = t.isSkinnedMesh && i.skinning) && (a |= 2), l = l[a]), e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (a = l.uuid, c = i.uuid, void 0 === (t = b[a]) && (t = {}, b[a] = t), void 0 === (a = t[c]) && (a = l.clone(), t[c] = a), l = a), l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : w[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = o, l.farDistance = s), l
		}

		function s(i, n, r, a) {
			if (!1 !== i.visible) {
				if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || c.intersectsObject(i))) {
					i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
					var l = t.update(i),
						h = i.material;
					if (Array.isArray(h))
						for (var u = l.groups, d = 0, p = u.length; d < p; d++) {
							var m = u[d],
								g = h[m.materialIndex];
							g && g.visible && (g = o(i, g, a, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, m))
						} else h.visible && (g = o(i, h, a, f, r.near, r.far), e.renderBufferDirect(r, null, l, g, i, null))
				}
				for (l = 0, h = (i = i.children).length; l < h; l++) s(i[l], n, r, a)
			}
		}
		var c = new m,
			h = new g,
			u = new i,
			d = new i(n, n),
			p = new r,
			f = new r,
			v = Array(4),
			y = Array(4),
			b = {},
			w = {
				0: 1,
				1: 0,
				2: 2
			},
			x = [new r(1, 0, 0), new r(-1, 0, 0), new r(0, 0, 1), new r(0, 0, -1), new r(0, 1, 0), new r(0, -1, 0)],
			_ = [new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 0, 1), new r(0, 0, -1)],
			E = [new a, new a, new a, new a, new a, new a];
		for (n = 0; 4 !== n; ++n) {
			var M = 0 != (1 & n),
				S = 0 != (2 & n),
				T = new pt({
					depthPacking: 3201,
					morphTargets: M,
					skinning: S
				});
			v[n] = T, M = new ft({
				morphTargets: M,
				skinning: S
			}), y[n] = M
		}
		var A = this;
		this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(t, i, n) {
			if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== t.length) {
				var r = e.getRenderTarget(),
					o = e.getActiveCubeFace(),
					a = e.getActiveMipMapLevel(),
					m = e.state;
				m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1);
				for (var g, v = 0, y = t.length; v < y; v++) {
					var b = t[v];
					g = b.shadow;
					var w = b && b.isPointLight;
					if (void 0 === g) console.warn("THREE.WebGLShadowMap:", b, "has no shadow.");
					else {
						var M = g.camera;
						if (u.copy(g.mapSize), u.min(d), w) {
							var S = u.x,
								T = u.y;
							E[0].set(2 * S, T, S, T), E[1].set(0, T, S, T), E[2].set(3 * S, T, S, T), E[3].set(S, T, S, T), E[4].set(3 * S, 0, S, T), E[5].set(S, 0, S, T), u.x *= 4, u.y *= 2
						}
						for (null === g.map && (g.map = new l(u.x, u.y, {
								minFilter: 1003,
								magFilter: 1003,
								format: 1023
							}), g.map.texture.name = b.name + ".shadowMap", M.updateProjectionMatrix()), g.isSpotLightShadow && g.update(b), S = g.map, T = g.matrix, f.setFromMatrixPosition(b.matrixWorld), M.position.copy(f), w ? (g = 6, T.makeTranslation(-f.x, -f.y, -f.z)) : (g = 1, p.setFromMatrixPosition(b.target.matrixWorld), M.lookAt(p), M.updateMatrixWorld(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), T.multiply(M.projectionMatrix), T.multiply(M.matrixWorldInverse)), e.setRenderTarget(S), e.clear(), b = 0; b < g; b++) w && (p.copy(M.position), p.add(x[b]), M.up.copy(_[b]), M.lookAt(p), M.updateMatrixWorld(), m.viewport(E[b])), h.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), c.setFromMatrix(h), s(i, n, M, w)
					}
				}
				A.needsUpdate = !1, e.setRenderTarget(r, o, a)
			}
		}
	}

	function gt(e, t, i, n) {
		function r(t, i, n) {
			var r = new Uint8Array(4),
				o = e.createTexture();
			for (e.bindTexture(t, o), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728), t = 0; t < n; t++) e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
			return o
		}

		function o(i, r) {
			y[i] = 1, 0 === b[i] && (e.enableVertexAttribArray(i), b[i] = 1), w[i] !== r && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), w[i] = r)
		}

		function s(t) {
			!0 !== x[t] && (e.enable(t), x[t] = !0)
		}

		function l(t) {
			!1 !== x[t] && (e.disable(t), x[t] = !1)
		}

		function c(t, n, r, o, a, c, h, u) {
			if (0 === t) M && (l(3042), M = !1);
			else if (M || (s(3042), M = !0), 5 !== t) {
				if (t !== S || u !== R) {
					if (100 === T && 100 === C || (e.blendEquation(32774), C = T = 100), u) switch (t) {
						case 1:
							e.blendFuncSeparate(1, 771, 1, 771);
							break;
						case 2:
							e.blendFunc(1, 1);
							break;
						case 3:
							e.blendFuncSeparate(0, 0, 769, 771);
							break;
						case 4:
							e.blendFuncSeparate(0, 768, 0, 770);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", t)
					} else switch (t) {
						case 1:
							e.blendFuncSeparate(770, 771, 1, 771);
							break;
						case 2:
							e.blendFunc(770, 1);
							break;
						case 3:
							e.blendFunc(0, 769);
							break;
						case 4:
							e.blendFunc(0, 768);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", t)
					}
					I = P = L = A = null, S = t, R = u
				}
			} else a = a || n, c = c || r, h = h || o, n === T && a === C || (e.blendEquationSeparate(i.convert(n), i.convert(a)), T = n, C = a), r === A && o === L && c === P && h === I || (e.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(c), i.convert(h)), A = r, L = o, P = c, I = h), S = t, R = null
		}

		function h(t) {
			O !== t && (t ? e.frontFace(2304) : e.frontFace(2305), O = t)
		}

		function u(t) {
			0 !== t ? (s(2884), t !== D && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : l(2884), D = t
		}

		function d(t, i, n) {
			t ? (s(32823), (k !== i || N !== n) && (e.polygonOffset(i, n), k = i, N = n)) : l(32823)
		}

		function p(t) {
			void 0 === t && (t = 33984 + B - 1), F !== t && (e.activeTexture(t), F = t)
		}
		var f = new function() {
				var t = !1,
					i = new a,
					n = null,
					r = new a(0, 0, 0, 0);
				return {
					setMask: function(i) {
						n === i || t || (e.colorMask(i, i, i, i), n = i)
					},
					setLocked: function(e) {
						t = e
					},
					setClear: function(t, n, o, s, a) {
						!0 === a && (t *= s, n *= s, o *= s), i.set(t, n, o, s), !1 === r.equals(i) && (e.clearColor(t, n, o, s), r.copy(i))
					},
					reset: function() {
						t = !1, n = null, r.set(-1, 0, 0, 0)
					}
				}
			},
			m = new function() {
				var t = !1,
					i = null,
					n = null,
					r = null;
				return {
					setTest: function(e) {
						e ? s(2929) : l(2929)
					},
					setMask: function(n) {
						i === n || t || (e.depthMask(n), i = n)
					},
					setFunc: function(t) {
						if (n !== t) {
							if (t) switch (t) {
								case 0:
									e.depthFunc(512);
									break;
								case 1:
									e.depthFunc(519);
									break;
								case 2:
									e.depthFunc(513);
									break;
								case 3:
									e.depthFunc(515);
									break;
								case 4:
									e.depthFunc(514);
									break;
								case 5:
									e.depthFunc(518);
									break;
								case 6:
									e.depthFunc(516);
									break;
								case 7:
									e.depthFunc(517);
									break;
								default:
									e.depthFunc(515)
							} else e.depthFunc(515);
							n = t
						}
					},
					setLocked: function(e) {
						t = e
					},
					setClear: function(t) {
						r !== t && (e.clearDepth(t), r = t)
					},
					reset: function() {
						t = !1, r = n = i = null
					}
				}
			},
			g = new function() {
				var t = !1,
					i = null,
					n = null,
					r = null,
					o = null,
					a = null,
					c = null,
					h = null,
					u = null;
				return {
					setTest: function(e) {
						e ? s(2960) : l(2960)
					},
					setMask: function(n) {
						i === n || t || (e.stencilMask(n), i = n)
					},
					setFunc: function(t, i, s) {
						n === t && r === i && o === s || (e.stencilFunc(t, i, s), n = t, r = i, o = s)
					},
					setOp: function(t, i, n) {
						a === t && c === i && h === n || (e.stencilOp(t, i, n), a = t, c = i, h = n)
					},
					setLocked: function(e) {
						t = e
					},
					setClear: function(t) {
						u !== t && (e.clearStencil(t), u = t)
					},
					reset: function() {
						t = !1, u = h = c = a = o = r = n = i = null
					}
				}
			},
			v = e.getParameter(34921),
			y = new Uint8Array(v),
			b = new Uint8Array(v),
			w = new Uint8Array(v),
			x = {},
			_ = null,
			E = null,
			M = null,
			S = null,
			T = null,
			A = null,
			L = null,
			C = null,
			P = null,
			I = null,
			R = !1,
			O = null,
			D = null,
			z = null,
			k = null,
			N = null,
			B = e.getParameter(35661),
			H = !1;
		v = 0, -1 !== (v = e.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), H = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), H = 2 <= v);
		var F = null,
			U = {},
			j = new a,
			G = new a,
			V = {};
		return V[3553] = r(3553, 3553, 1), V[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), s(2929), m.setFunc(3), h(!1), u(1), s(2884), c(0), {
			buffers: {
				color: f,
				depth: m,
				stencil: g
			},
			initAttributes: function() {
				for (var e = 0, t = y.length; e < t; e++) y[e] = 0
			},
			enableAttribute: function(e) {
				o(e, 0)
			},
			enableAttributeAndDivisor: o,
			disableUnusedAttributes: function() {
				for (var t = 0, i = b.length; t !== i; ++t) b[t] !== y[t] && (e.disableVertexAttribArray(t), b[t] = 0)
			},
			enable: s,
			disable: l,
			getCompressedTextureFormats: function() {
				if (null === _ && (_ = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
					for (var i = e.getParameter(34467), n = 0; n < i.length; n++) _.push(i[n]);
				return _
			},
			useProgram: function(t) {
				return E !== t && (e.useProgram(t), E = t, !0)
			},
			setBlending: c,
			setMaterial: function(e, t) {
				2 === e.side ? l(2884) : s(2884);
				var i = 1 === e.side;
				t && (i = !i), h(i), 1 === e.blending && !1 === e.transparent ? c(0) : c(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), m.setFunc(e.depthFunc), m.setTest(e.depthTest), m.setMask(e.depthWrite), f.setMask(e.colorWrite), d(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
			},
			setFlipSided: h,
			setCullFace: u,
			setLineWidth: function(t) {
				t !== z && (H && e.lineWidth(t), z = t)
			},
			setPolygonOffset: d,
			setScissorTest: function(e) {
				e ? s(3089) : l(3089)
			},
			activeTexture: p,
			bindTexture: function(t, i) {
				null === F && p();
				var n = U[F];
				void 0 === n && (n = {
					type: void 0,
					texture: void 0
				}, U[F] = n), n.type === t && n.texture === i || (e.bindTexture(t, i || V[t]), n.type = t, n.texture = i)
			},
			compressedTexImage2D: function() {
				try {
					e.compressedTexImage2D.apply(e, arguments)
				} catch (e) {
					console.error("THREE.WebGLState:", e)
				}
			},
			texImage2D: function() {
				try {
					e.texImage2D.apply(e, arguments)
				} catch (e) {
					console.error("THREE.WebGLState:", e)
				}
			},
			texImage3D: function() {
				try {
					e.texImage3D.apply(e, arguments)
				} catch (e) {
					console.error("THREE.WebGLState:", e)
				}
			},
			scissor: function(t) {
				!1 === j.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), j.copy(t))
			},
			viewport: function(t) {
				!1 === G.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), G.copy(t))
			},
			reset: function() {
				for (var t = 0; t < b.length; t++) 1 === b[t] && (e.disableVertexAttribArray(t), b[t] = 0);
				x = {}, F = _ = null, U = {}, D = O = S = E = null, f.reset(), m.reset(), g.reset()
			}
		}
	}

	function vt(e, t, i, n, r, o, s) {
		function a(e, t) {
			return A ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
		}

		function l(e, t, i, n) {
			var r = 1;
			if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), 1 > r || !0 === t) {
				if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) return t = (n = t ? uo.floorPowerOfTwo : Math.floor)(r * e.width), r = n(r * e.height), void 0 === S && (S = a(t, r)), (i = i ? a(t, r) : S).width = t, i.height = r, i.getContext("2d").drawImage(e, 0, 0, t, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + t + "x" + r + ")."), i;
				"data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
			}
			return e
		}

		function c(e) {
			return uo.isPowerOfTwo(e.width) && uo.isPowerOfTwo(e.height)
		}

		function h(e, t) {
			return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
		}

		function u(t, i, r, o) {
			e.generateMipmap(t), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
		}

		function d(e, i) {
			if (!r.isWebGL2) return e;
			var n = e;
			return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? t.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
		}

		function p(e) {
			return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
		}

		function f(t) {
			(t = t.target).removeEventListener("dispose", f);
			var i = n.get(t);
			void 0 !== i.__webglInit && (e.deleteTexture(i.__webglTexture), n.remove(t)), t.isVideoTexture && delete T[t.id], s.memory.textures--
		}

		function m(t) {
			(t = t.target).removeEventListener("dispose", m);
			var i = n.get(t),
				r = n.get(t.texture);
			if (t) {
				if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
					for (r = 0; 6 > r; r++) e.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[r]);
				else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer);
				n.remove(t.texture), n.remove(t)
			}
			s.memory.textures--
		}

		function g(e, t) {
			var r = n.get(e);
			if (e.isVideoTexture) {
				var o = e.id,
					a = s.render.frame;
				T[o] !== a && (T[o] = a, e.update())
			}
			if (0 < e.version && r.__version !== e.version)
				if (void 0 === (o = e.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
				else {
					if (!1 !== o.complete) return void x(r, e, t);
					console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
				} i.activeTexture(33984 + t), i.bindTexture(3553, r.__webglTexture)
		}

		function v(t, s) {
			var a = n.get(t);
			if (6 === t.image.length)
				if (0 < t.version && a.__version !== t.version) {
					w(a, t), i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture), e.pixelStorei(37440, t.flipY), s = t && t.isCompressedTexture;
					for (var p = t.image[0] && t.image[0].isDataTexture, f = [], m = 0; 6 > m; m++) f[m] = s || p ? p ? t.image[m].image : t.image[m] : l(t.image[m], !1, !0, r.maxCubemapSize);
					var g = f[0],
						v = c(g) || r.isWebGL2,
						y = o.convert(t.format),
						x = o.convert(t.type),
						_ = d(y, x);
					for (b(34067, t, v), m = 0; 6 > m; m++)
						if (s)
							for (var E, M = f[m].mipmaps, S = 0, T = M.length; S < T; S++) E = M[S], 1023 !== t.format && 1022 !== t.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(34069 + m, S, _, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + m, S, _, E.width, E.height, 0, y, x, E.data);
						else p ? i.texImage2D(34069 + m, 0, _, f[m].width, f[m].height, 0, y, x, f[m].data) : i.texImage2D(34069 + m, 0, _, y, x, f[m]);
					a.__maxMipLevel = s ? M.length - 1 : 0, h(t, v) && u(34067, t, g.width, g.height), a.__version = t.version, t.onUpdate && t.onUpdate(t)
				} else i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture)
		}

		function y(e, t) {
			i.activeTexture(33984 + t), i.bindTexture(34067, n.get(e).__webglTexture)
		}

		function b(i, s, a) {
			a ? (e.texParameteri(i, 10242, o.convert(s.wrapS)), e.texParameteri(i, 10243, o.convert(s.wrapT)), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, o.convert(s.wrapR)), e.texParameteri(i, 10240, o.convert(s.magFilter)), e.texParameteri(i, 10241, o.convert(s.minFilter))) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), 1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, p(s.magFilter)), e.texParameteri(i, 10241, p(s.minFilter)), 1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(a = t.get("EXT_texture_filter_anisotropic")) || 1015 === s.type && null === t.get("OES_texture_float_linear") || 1016 === s.type && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear")) || !(1 < s.anisotropy || n.get(s).__currentAnisotropy) || (e.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy)
		}

		function w(t, i) {
			void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), s.memory.textures++)
		}

		function x(t, n, s) {
			var a = 3553;
			n.isDataTexture2DArray && (a = 35866), n.isDataTexture3D && (a = 32879), w(t, n), i.activeTexture(33984 + s), i.bindTexture(a, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment), s = (s = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === c(n.image);
			var p = c(s = l(n.image, s, !1, r.maxTextureSize)) || r.isWebGL2,
				f = o.convert(n.format),
				m = o.convert(n.type),
				g = d(f, m);
			b(a, n, p);
			var v = n.mipmaps;
			if (n.isDepthTexture) {
				if (g = 6402, 1015 === n.type) {
					if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
					g = 36012
				} else r.isWebGL2 && (g = 33189);
				1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = o.convert(n.type)), 1027 === n.format && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = o.convert(n.type))), i.texImage2D(3553, 0, g, s.width, s.height, 0, f, m, null)
			} else if (n.isDataTexture)
				if (0 < v.length && p) {
					for (var y = 0, x = v.length; y < x; y++) a = v[y], i.texImage2D(3553, y, g, a.width, a.height, 0, f, m, a.data);
					n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
				} else i.texImage2D(3553, 0, g, s.width, s.height, 0, f, m, s.data), t.__maxMipLevel = 0;
			else if (n.isCompressedTexture) {
				for (y = 0, x = v.length; y < x; y++) a = v[y], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) ? i.compressedTexImage2D(3553, y, g, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, y, g, a.width, a.height, 0, f, m, a.data);
				t.__maxMipLevel = v.length - 1
			} else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, s.width, s.height, s.depth, 0, f, m, s.data), t.__maxMipLevel = 0;
			else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, s.width, s.height, s.depth, 0, f, m, s.data), t.__maxMipLevel = 0;
			else if (0 < v.length && p) {
				for (y = 0, x = v.length; y < x; y++) a = v[y], i.texImage2D(3553, y, g, f, m, a);
				n.generateMipmaps = !1, t.__maxMipLevel = v.length - 1
			} else i.texImage2D(3553, 0, g, f, m, s), t.__maxMipLevel = 0;
			h(n, p) && u(3553, n, s.width, s.height), t.__version = n.version, n.onUpdate && n.onUpdate(n)
		}

		function _(t, r, s, a) {
			var l = o.convert(r.texture.format),
				c = o.convert(r.texture.type),
				h = d(l, c);
			i.texImage2D(a, 0, h, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, s, a, n.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
		}

		function E(t, i, n) {
			e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer ? (n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : e.renderbufferStorage(36161, 33189, i.width, i.height), e.framebufferRenderbuffer(36160, 36096, 36161, t)) : i.depthBuffer && i.stencilBuffer ? (n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : e.renderbufferStorage(36161, 34041, i.width, i.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)) : (t = d(t = o.convert(i.texture.format), o.convert(i.texture.type)), n ? (n = M(i), e.renderbufferStorageMultisample(36161, n, t, i.width, i.height)) : e.renderbufferStorage(36161, t, i.width, i.height)), e.bindRenderbuffer(36161, null)
		}

		function M(e) {
			return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0
		}
		var S, T = {},
			A = "undefined" != typeof OffscreenCanvas,
			L = 0,
			C = !1,
			P = !1;
		this.allocateTextureUnit = function() {
			var e = L;
			return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), L += 1, e
		}, this.resetTextureUnits = function() {
			L = 0
		}, this.setTexture2D = g, this.setTexture2DArray = function(e, t) {
			var r = n.get(e);
			0 < e.version && r.__version !== e.version ? x(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, r.__webglTexture))
		}, this.setTexture3D = function(e, t) {
			var r = n.get(e);
			0 < e.version && r.__version !== e.version ? x(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, r.__webglTexture))
		}, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function(t) {
			var a = n.get(t),
				l = n.get(t.texture);
			t.addEventListener("dispose", m), l.__webglTexture = e.createTexture(), s.memory.textures++;
			var p = !0 === t.isWebGLRenderTargetCube,
				f = !0 === t.isWebGLMultisampleRenderTarget,
				v = c(t) || r.isWebGL2;
			if (p)
				for (a.__webglFramebuffer = [], f = 0; 6 > f; f++) a.__webglFramebuffer[f] = e.createFramebuffer();
			else if (a.__webglFramebuffer = e.createFramebuffer(), f)
				if (r.isWebGL2) {
					a.__webglMultisampledFramebuffer = e.createFramebuffer(), a.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, a.__webglColorRenderbuffer), f = o.convert(t.texture.format);
					var y = o.convert(t.texture.type);
					f = d(f, y), y = M(t), e.renderbufferStorageMultisample(36161, y, f, t.width, t.height), e.bindFramebuffer(36160, a.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, a.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (a.__webglDepthRenderbuffer = e.createRenderbuffer(), E(a.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
				} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
			if (p) {
				for (i.bindTexture(34067, l.__webglTexture), b(34067, t.texture, v), f = 0; 6 > f; f++) _(a.__webglFramebuffer[f], t, 36064, 34069 + f);
				h(t.texture, v) && u(34067, t.texture, t.width, t.height), i.bindTexture(34067, null)
			} else i.bindTexture(3553, l.__webglTexture), b(3553, t.texture, v), _(a.__webglFramebuffer, t, 36064, 3553), h(t.texture, v) && u(3553, t.texture, t.width, t.height), i.bindTexture(3553, null);
			if (t.depthBuffer) {
				if (a = n.get(t), l = !0 === t.isWebGLRenderTargetCube, t.depthTexture) {
					if (l) throw Error("target.depthTexture not supported in Cube render targets");
					if (t && t.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
					if (e.bindFramebuffer(36160, a.__webglFramebuffer), !t.depthTexture || !t.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
					if (n.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), g(t.depthTexture, 0), a = n.get(t.depthTexture).__webglTexture, 1026 === t.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, a, 0);
					else {
						if (1027 !== t.depthTexture.format) throw Error("Unknown depthTexture format");
						e.framebufferTexture2D(36160, 33306, 3553, a, 0)
					}
				} else if (l)
					for (a.__webglDepthbuffer = [], l = 0; 6 > l; l++) e.bindFramebuffer(36160, a.__webglFramebuffer[l]), a.__webglDepthbuffer[l] = e.createRenderbuffer(), E(a.__webglDepthbuffer[l], t);
				else e.bindFramebuffer(36160, a.__webglFramebuffer), a.__webglDepthbuffer = e.createRenderbuffer(), E(a.__webglDepthbuffer, t);
				e.bindFramebuffer(36160, null)
			}
		}, this.updateRenderTargetMipmap = function(e) {
			var t = e.texture,
				o = c(e) || r.isWebGL2;
			if (h(t, o)) {
				o = e.isWebGLRenderTargetCube ? 34067 : 3553;
				var s = n.get(t).__webglTexture;
				i.bindTexture(o, s), u(o, t, e.width, e.height), i.bindTexture(o, null)
			}
		}, this.updateMultisampleRenderTarget = function(t) {
			if (t.isWebGLMultisampleRenderTarget)
				if (r.isWebGL2) {
					var i = n.get(t);
					e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, i.__webglFramebuffer), i = t.width;
					var o = t.height,
						s = 16384;
					t.depthBuffer && (s |= 256), t.stencilBuffer && (s |= 1024), e.blitFramebuffer(0, 0, i, o, 0, 0, i, o, s, 9728)
				} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
		}, this.safeSetTexture2D = function(e, t) {
			e && e.isWebGLRenderTarget && (!1 === C && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), C = !0), e = e.texture), g(e, t)
		}, this.safeSetTextureCube = function(e, t) {
			e && e.isWebGLRenderTargetCube && (!1 === P && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), P = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? v(e, t) : y(e, t)
		}
	}

	function yt(e, t, i) {
		return {
			convert: function(e) {
				if (1e3 === e) return 10497;
				if (1001 === e) return 33071;
				if (1002 === e) return 33648;
				if (1003 === e) return 9728;
				if (1004 === e) return 9984;
				if (1005 === e) return 9986;
				if (1006 === e) return 9729;
				if (1007 === e) return 9985;
				if (1008 === e) return 9987;
				if (1009 === e) return 5121;
				if (1017 === e) return 32819;
				if (1018 === e) return 32820;
				if (1019 === e) return 33635;
				if (1010 === e) return 5120;
				if (1011 === e) return 5122;
				if (1012 === e) return 5123;
				if (1013 === e) return 5124;
				if (1014 === e) return 5125;
				if (1015 === e) return 5126;
				if (1016 === e) {
					if (i.isWebGL2) return 5131;
					var n = t.get("OES_texture_half_float");
					if (null !== n) return n.HALF_FLOAT_OES
				}
				if (1021 === e) return 6406;
				if (1022 === e) return 6407;
				if (1023 === e) return 6408;
				if (1024 === e) return 6409;
				if (1025 === e) return 6410;
				if (1026 === e) return 6402;
				if (1027 === e) return 34041;
				if (1028 === e) return 6403;
				if (100 === e) return 32774;
				if (101 === e) return 32778;
				if (102 === e) return 32779;
				if (200 === e) return 0;
				if (201 === e) return 1;
				if (202 === e) return 768;
				if (203 === e) return 769;
				if (204 === e) return 770;
				if (205 === e) return 771;
				if (206 === e) return 772;
				if (207 === e) return 773;
				if (208 === e) return 774;
				if (209 === e) return 775;
				if (210 === e) return 776;
				if ((33776 === e || 33777 === e || 33778 === e || 33779 === e) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) {
					if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
				}
				if ((35840 === e || 35841 === e || 35842 === e || 35843 === e) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) {
					if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
				}
				if (36196 === e && null !== (n = t.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
				if ((37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) && null !== (n = t.get("WEBGL_compressed_texture_astc"))) return e;
				if (103 === e || 104 === e) {
					if (i.isWebGL2) {
						if (103 === e) return 32775;
						if (104 === e) return 32776
					}
					if (null !== (n = t.get("EXT_blend_minmax"))) {
						if (103 === e) return n.MIN_EXT;
						if (104 === e) return n.MAX_EXT
					}
				}
				if (1020 === e) {
					if (i.isWebGL2) return 34042;
					if (null !== (n = t.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
				}
				return 0
			}
		}
	}

	function bt() {
		S.call(this), this.type = "Group"
	}

	function wt() {
		S.call(this), this.type = "Camera", this.matrixWorldInverse = new g, this.projectionMatrix = new g, this.projectionMatrixInverse = new g
	}

	function xt(e, t, i, n) {
		wt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
	}

	function _t(e) {
		xt.call(this), this.cameras = e || []
	}

	function Et(e, t, i) {
		Bo.setFromMatrixPosition(t.matrixWorld), Ho.setFromMatrixPosition(i.matrixWorld);
		var n = Bo.distanceTo(Ho),
			r = t.projectionMatrix.elements,
			o = i.projectionMatrix.elements,
			s = r[14] / (r[10] - 1);
		i = r[14] / (r[10] + 1);
		var a = (r[9] + 1) / r[5],
			l = (r[9] - 1) / r[5],
			c = (r[8] - 1) / r[0],
			h = (o[8] + 1) / o[0];
		r = s * c, o = s * h, c = (h = n / (-c + h)) * -c, t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(c), e.translateZ(h), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld), t = s + h, s = i + h, e.projectionMatrix.makePerspective(r - c, o + (n - c), a * i / s * t, l * i / s * t, t, s)
	}

	function Mt(e) {
		function t() {
			return null !== u && !0 === u.isPresenting
		}

		function o() {
			if (t()) {
				var i = u.getEyeParameters("left");
				l = 2 * i.renderWidth * y, c = i.renderHeight * y, A = e.getPixelRatio(), e.getSize(L), e.setDrawingBufferSize(l, c, 1), M.viewport.set(0, 0, l / 2, c), S.viewport.set(l / 2, 0, l / 2, c), P.start()
			} else h.enabled && e.setDrawingBufferSize(L.width, L.height, A), P.stop()
		}

		function s(e, t) {
			null !== t && 4 === t.length && e.set(t[0] * l, t[1] * c, t[2] * l, t[3] * c)
		}
		var l, c, h = this,
			u = null,
			d = null,
			p = null,
			f = [],
			m = new g,
			v = new g,
			y = 1,
			b = "local-floor";
		"undefined" != typeof window && "VRFrameData" in window && (d = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1));
		var x = new g,
			_ = new n,
			E = new r,
			M = new xt;
		M.viewport = new a, M.layers.enable(1);
		var S = new xt;
		S.viewport = new a, S.layers.enable(2);
		var T = new _t([M, S]);
		T.layers.enable(1), T.layers.enable(2);
		var A, L = new i,
			C = [];
		this.enabled = !1, this.getController = function(e) {
			var t = f[e];
			return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, f[e] = t), t
		}, this.getDevice = function() {
			return u
		}, this.setDevice = function(e) {
			void 0 !== e && (u = e), P.setContext(e)
		}, this.setFramebufferScaleFactor = function(e) {
			y = e
		}, this.setReferenceSpaceType = function(e) {
			b = e
		}, this.setPoseTarget = function(e) {
			void 0 !== e && (p = e)
		}, this.getCamera = function(e) {
			var i = "local-floor" === b ? 1.6 : 0;
			if (!1 === t()) return e.position.set(0, i, 0), e.rotation.set(0, 0, 0), e;
			if (u.depthNear = e.near, u.depthFar = e.far, u.getFrameData(d), "local-floor" === b) {
				var n = u.stageParameters;
				n ? m.fromArray(n.sittingToStandingTransform) : m.makeTranslation(0, i, 0)
			}
			i = d.pose, (n = null !== p ? p : e).matrix.copy(m), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== i.orientation && (_.fromArray(i.orientation), n.quaternion.multiply(_)), null !== i.position && (_.setFromRotationMatrix(m), E.fromArray(i.position), E.applyQuaternion(_), n.position.add(E)), n.updateMatrixWorld(), M.near = e.near, S.near = e.near, M.far = e.far, S.far = e.far, M.matrixWorldInverse.fromArray(d.leftViewMatrix), S.matrixWorldInverse.fromArray(d.rightViewMatrix), v.getInverse(m), "local-floor" === b && (M.matrixWorldInverse.multiply(v), S.matrixWorldInverse.multiply(v)), null !== (e = n.parent) && (x.getInverse(e.matrixWorld), M.matrixWorldInverse.multiply(x), S.matrixWorldInverse.multiply(x)), M.matrixWorld.getInverse(M.matrixWorldInverse), S.matrixWorld.getInverse(S.matrixWorldInverse), M.projectionMatrix.fromArray(d.leftProjectionMatrix), S.projectionMatrix.fromArray(d.rightProjectionMatrix), Et(T, M, S), (e = u.getLayers()).length && (e = e[0], s(M.viewport, e.leftBounds), s(S.viewport, e.rightBounds));
			e: for (e = 0; e < f.length; e++) {
				i = f[e];
				t: {
					n = e;
					for (var r = navigator.getGamepads && navigator.getGamepads(), o = 0, a = 0, l = r.length; o < l; o++) {
						var c = r[o];
						if (c && ("Daydream Controller" === c.id || "Gear VR Controller" === c.id || "Oculus Go Controller" === c.id || "OpenVR Gamepad" === c.id || c.id.startsWith("Oculus Touch") || c.id.startsWith("Spatial Controller"))) {
							if (a === n) {
								n = c;
								break t
							}
							a++
						}
					}
					n = void 0
				}
				if (void 0 !== n && void 0 !== n.pose) {
					if (null === n.pose) break e;
					!1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05), null !== r.position && i.position.fromArray(r.position), null !== r.orientation && i.quaternion.fromArray(r.orientation), i.matrix.compose(i.position, i.quaternion, i.scale), i.matrix.premultiply(m), i.matrix.decompose(i.position, i.quaternion, i.scale), i.matrixWorldNeedsUpdate = !0, i.visible = !0, r = "Daydream Controller" === n.id ? 0 : 1, void 0 === C[e] && (C[e] = !1), C[e] !== n.buttons[r].pressed && (C[e] = n.buttons[r].pressed, !0 === C[e] ? i.dispatchEvent({
						type: "selectstart"
					}) : (i.dispatchEvent({
						type: "selectend"
					}), i.dispatchEvent({
						type: "select"
					})))
				} else i.visible = !1
			}
			return T
		}, this.getStandingMatrix = function() {
			return m
		}, this.isPresenting = t;
		var P = new w;
		this.setAnimationLoop = function(e) {
			P.setAnimationLoop(e), t() && P.start()
		}, this.submitFrame = function() {
			t() && u.submitFrame()
		}, this.dispose = function() {
			"undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o)
		}, this.setFrameOfReferenceType = function() {
			console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
		}
	}

	function St(e) {
		function t() {
			return null !== l && null !== c
		}

		function i(e) {
			for (var t = 0; t < d.length; t++) p[t] === e.inputSource && d[t].dispatchEvent({
				type: e.type
			})
		}

		function n() {
			e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), b.stop()
		}

		function r(e) {
			c = e, b.setContext(l), b.start()
		}

		function o(e, t) {
			null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
		}
		var s = e.context,
			l = null,
			c = null,
			h = "local-floor",
			u = null,
			d = [],
			p = [],
			f = new xt;
		f.layers.enable(1), f.viewport = new a;
		var m = new xt;
		m.layers.enable(2), m.viewport = new a;
		var v = new _t([f, m]);
		v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function(e) {
			var t = d[e];
			return void 0 === t && ((t = new bt).matrixAutoUpdate = !1, t.visible = !1, d[e] = t), t
		}, this.setFramebufferScaleFactor = function(e) {}, this.setReferenceSpaceType = function(e) {
			h = e
		}, this.setSession = function(e) {
			null !== (l = e) && (l.addEventListener("select", i), l.addEventListener("selectstart", i), l.addEventListener("selectend", i), l.addEventListener("end", n), l.updateRenderState({
				baseLayer: new XRWebGLLayer(l, s)
			}), l.requestReferenceSpace(h).then(r), p = l.inputSources, l.addEventListener("inputsourceschange", (function() {
				p = l.inputSources, console.log(p);
				for (var e = 0; e < d.length; e++) d[e].userData.inputSource = p[e]
			})))
		}, this.getCamera = function(e) {
			if (t()) {
				var i = e.parent,
					n = v.cameras;
				o(v, i);
				for (var r = 0; r < n.length; r++) o(n[r], i);
				for (e.matrixWorld.copy(v.matrixWorld), r = 0, i = (e = e.children).length; r < i; r++) e[r].updateMatrixWorld(!0);
				return Et(v, f, m), v
			}
			return e
		}, this.isPresenting = t;
		var y = null,
			b = new w;
		b.setAnimationLoop((function(t, i) {
			if (null !== (u = i.getViewerPose(c))) {
				var n = u.views,
					r = l.renderState.baseLayer;
				e.setFramebuffer(r.framebuffer);
				for (var o = 0; o < n.length; o++) {
					var s = n[o],
						a = r.getViewport(s),
						h = v.cameras[o];
					h.matrix.fromArray(s.transform.inverse.matrix).getInverse(h.matrix), h.projectionMatrix.fromArray(s.projectionMatrix), h.viewport.set(a.x, a.y, a.width, a.height), 0 === o && v.matrix.copy(h.matrix)
				}
			}
			for (o = 0; o < d.length; o++) n = d[o], (r = p[o]) && null !== (r = i.getPose(r.targetRaySpace, c)) ? (n.matrix.fromArray(r.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1;
			y && y(t)
		})), this.setAnimationLoop = function(e) {
			y = e
		}, this.dispose = function() {}, this.getStandingMatrix = function() {
			return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new g
		}, this.getDevice = function() {
			console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
		}, this.setDevice = function() {
			console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
		}, this.setFrameOfReferenceType = function() {
			console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
		}, this.submitFrame = function() {}
	}

	function Tt(e) {
		var t;

		function n() {
			z = new ee(ze), (k = new K(ze, z, e)).isWebGL2 || (z.get("WEBGL_depth_texture"), z.get("OES_texture_float"), z.get("OES_texture_half_float"), z.get("OES_texture_half_float_linear"), z.get("OES_standard_derivatives"), z.get("OES_element_index_uint"), z.get("ANGLE_instanced_arrays")), z.get("OES_texture_float_linear"), ae = new yt(ze, z, k), (N = new gt(ze, z, ae, k)).scissor(xe.copy(Ae).multiplyScalar(Se)), N.viewport(we.copy(Te).multiplyScalar(Se)), B = new ne(ze), H = new rt, F = new vt(ze, z, N, H, k, ae, B), U = new x(ze), j = new te(ze, U, B), G = new se(j, B), Y = new oe(ze), V = new nt(le, z, k, F), W = new lt, q = new dt, X = new Q(le, N, G, C), Z = new J(ze, z, B, k), re = new ie(ze, z, B, k), B.programs = V.programs, le.context = ze, le.capabilities = k, le.extensions = z, le.properties = H, le.renderLists = W, le.state = N, le.info = B
		}

		function o(e) {
			e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ce = !0
		}

		function s() {
			console.log("THREE.WebGLRenderer: Context Restored."), ce = !1, n()
		}

		function l(e) {
			(e = e.target).removeEventListener("dispose", l), c(e), H.remove(e)
		}

		function c(e) {
			var t = H.get(e).program;
			e.program = void 0, void 0 !== t && V.releaseProgram(t)
		}

		function h(e, t, i, n) {
			for (var r = 0, o = e.length; r < o; r++) {
				var s = e[r],
					a = s.object,
					l = s.geometry,
					c = void 0 === n ? s.material : n;
				if (s = s.group, i.isArrayCamera) {
					be = i;
					for (var h = i.cameras, u = 0, p = h.length; u < p; u++) {
						var f = h[u];
						a.layers.test(f.layers) && (N.viewport(we.copy(f.viewport)), D.setupLights(f), d(a, t, f, l, c, s))
					}
				} else be = null, d(a, t, i, l, c, s)
			}
		}

		function d(e, i, n, r, o, s) {
			if (e.onBeforeRender(le, i, n, r, o, s), D = q.get(i, be || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
				N.setMaterial(o);
				var a = f(n, i.fog, o, e);
				ge = t = null, ve = !1,
					function(e, t) {
						e.render((function(e) {
							le.renderBufferImmediate(e, t)
						}))
					}(e, a)
			} else le.renderBufferDirect(n, i.fog, r, o, e, s);
			e.onAfterRender(le, i, n, r, o, s), D = q.get(i, be || n)
		}

		function p(e, t, i) {
			var n = H.get(e),
				r = D.state.lights,
				o = n.lightsHash,
				s = r.state.hash;
			i = V.getParameters(e, r.state, D.state.shadowsArray, t, Pe.numPlanes, Pe.numIntersection, i);
			var a = V.getProgramCode(e, i),
				h = n.program,
				u = !0;
			if (void 0 === h) e.addEventListener("dispose", l);
			else if (h.code !== a) c(e);
			else {
				if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength;
				else if (void 0 !== i.shaderID) return;
				u = !1
			}
			if (u && (i.shaderID ? (a = wo[i.shaderID], n.shader = {
					name: e.type,
					uniforms: v(a.uniforms),
					vertexShader: a.vertexShader,
					fragmentShader: a.fragmentShader
				}) : n.shader = {
					name: e.type,
					uniforms: e.uniforms,
					vertexShader: e.vertexShader,
					fragmentShader: e.fragmentShader
				}, e.onBeforeCompile(n.shader, le), a = V.getProgramCode(e, i), h = V.acquireProgram(e, n.shader, i, a), n.program = h, e.program = h), i = h.getAttributes(), e.morphTargets)
				for (a = e.numSupportedMorphTargets = 0; a < le.maxMorphTargets; a++) 0 <= i["morphTarget" + a] && e.numSupportedMorphTargets++;
			if (e.morphNormals)
				for (a = e.numSupportedMorphNormals = 0; a < le.maxMorphNormals; a++) 0 <= i["morphNormal" + a] && e.numSupportedMorphNormals++;
			i = n.shader.uniforms, (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = Pe.numPlanes, n.numIntersection = Pe.numIntersection, i.clippingPlanes = Pe.uniform), n.fog = t, void 0 === o && (n.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, e.lights && (i.ambientLightColor.value = r.state.ambient, i.lightProbe.value = r.state.probe, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), e = n.program.getUniforms(), e = We.seqWithValue(e.seq, i), n.uniformsList = e
		}

		function f(e, t, i, n) {
			F.resetTextureUnits();
			var r = H.get(i),
				o = r.lightsHash,
				s = D.state.lights.state.hash;
			Ie && (Re || e !== ye) && Pe.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, e === ye && i.id === me), !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === Pe.numPlanes && r.numIntersection === Pe.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (p(i, t, n), i.needsUpdate = !1);
			var a = !1,
				l = !1,
				c = !1;
			s = (o = r.program).getUniforms();
			var h = r.shader.uniforms;
			if (N.useProgram(o.program) && (c = l = a = !0), i.id !== me && (me = i.id, l = !0), (a || ye !== e) && (s.setValue(ze, "projectionMatrix", e.projectionMatrix), k.logarithmicDepthBuffer && s.setValue(ze, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), ye !== e && (ye = e, c = l = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && void 0 !== (a = s.map.cameraPosition) && a.setValue(ze, De.setFromMatrixPosition(e.matrixWorld)), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && s.setValue(ze, "viewMatrix", e.matrixWorldInverse)), i.skinning && (s.setOptional(ze, n, "bindMatrix"), s.setOptional(ze, n, "bindMatrixInverse"), e = n.skeleton))
				if (a = e.bones, k.floatVertexTextures) {
					if (void 0 === e.boneTexture) {
						a = Math.sqrt(4 * a.length), a = uo.ceilPowerOfTwo(a), a = Math.max(a, 4);
						var d = new Float32Array(a * a * 4);
						d.set(e.boneMatrices);
						var f = new u(d, a, a, 1023, 1015);
						f.needsUpdate = !0, e.boneMatrices = d, e.boneTexture = f, e.boneTextureSize = a
					}
					s.setValue(ze, "boneTexture", e.boneTexture, F), s.setValue(ze, "boneTextureSize", e.boneTextureSize)
				} else s.setOptional(ze, e, "boneMatrices");
			return l && (s.setValue(ze, "toneMappingExposure", le.toneMappingExposure), s.setValue(ze, "toneMappingWhitePoint", le.toneMappingWhitePoint), i.lights && (l = c, h.ambientLightColor.needsUpdate = l, h.lightProbe.needsUpdate = l, h.directionalLights.needsUpdate = l, h.pointLights.needsUpdate = l, h.spotLights.needsUpdate = l, h.rectAreaLights.needsUpdate = l, h.hemisphereLights.needsUpdate = l), t && i.fog && (h.fogColor.value.copy(t.color), t.isFog ? (h.fogNear.value = t.near, h.fogFar.value = t.far) : t.isFogExp2 && (h.fogDensity.value = t.density)), i.isMeshBasicMaterial ? y(h, i) : i.isMeshLambertMaterial ? (y(h, i), i.emissiveMap && (h.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (y(h, i), i.isMeshToonMaterial ? (b(h, i), i.gradientMap && (h.gradientMap.value = i.gradientMap)) : b(h, i)) : i.isMeshStandardMaterial ? (y(h, i), i.isMeshPhysicalMaterial ? (_(h, i), h.reflectivity.value = i.reflectivity, h.clearCoat.value = i.clearCoat, h.clearCoatRoughness.value = i.clearCoatRoughness) : _(h, i)) : i.isMeshMatcapMaterial ? (y(h, i), i.matcap && (h.matcap.value = i.matcap), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (y(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (y(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias), h.referencePosition.value.copy(i.referencePosition), h.nearDistance.value = i.nearDistance, h.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (y(h, i), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, i.isLineDashedMaterial && (h.dashSize.value = i.dashSize, h.totalSize.value = i.dashSize + i.gapSize, h.scale.value = i.scale)) : i.isPointsMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.size.value = i.size * Se, h.scale.value = .5 * Me, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (h.diffuse.value.copy(i.color), h.opacity.value = i.opacity, h.rotation.value = i.rotation, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (h.color.value.copy(i.color), h.opacity.value = i.opacity), void 0 !== h.ltc_1 && (h.ltc_1.value = bo.LTC_1), void 0 !== h.ltc_2 && (h.ltc_2.value = bo.LTC_2), We.upload(ze, r.uniformsList, h, F)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (We.upload(ze, r.uniformsList, h, F), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && s.setValue(ze, "center", n.center), s.setValue(ze, "modelViewMatrix", n.modelViewMatrix), s.setValue(ze, "normalMatrix", n.normalMatrix), s.setValue(ze, "modelMatrix", n.matrixWorld), o
		}

		function y(e, t) {
			if (e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = H.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map) var i = t.map;
			else t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap);
			void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
		}

		function b(e, t) {
			e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
		}

		function _(e, t) {
			e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
		}
		console.log("THREE.WebGLRenderer", "105");
		var E = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
			M = void 0 !== e.context ? e.context : null,
			S = void 0 !== e.alpha && e.alpha,
			T = void 0 === e.depth || e.depth,
			A = void 0 === e.stencil || e.stencil,
			L = void 0 !== e.antialias && e.antialias,
			C = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
			P = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
			I = void 0 !== e.powerPreference ? e.powerPreference : "default",
			R = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat,
			O = null,
			D = null;
		this.domElement = E, this.context = null, this.debug = {
			checkShaderErrors: !0
		}, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
		var z, k, N, B, H, F, U, j, G, V, W, q, X, Y, Z, re, ae, le = this,
			ce = !1,
			he = null,
			ue = 0,
			de = 0,
			pe = null,
			fe = null,
			me = -1,
			ge = t = null,
			ve = !1,
			ye = null,
			be = null,
			we = new a,
			xe = new a,
			_e = null,
			Ee = E.width,
			Me = E.height,
			Se = 1,
			Te = new a(0, 0, Ee, Me),
			Ae = new a(0, 0, Ee, Me),
			Le = !1,
			Ce = new m,
			Pe = new $,
			Ie = !1,
			Re = !1,
			Oe = new g,
			De = new r;
		try {
			S = {
				alpha: S,
				depth: T,
				stencil: A,
				antialias: L,
				premultipliedAlpha: C,
				preserveDrawingBuffer: P,
				powerPreference: I,
				failIfMajorPerformanceCaveat: R,
				xrCompatible: !0
			}, E.addEventListener("webglcontextlost", o, !1), E.addEventListener("webglcontextrestored", s, !1);
			var ze = M || E.getContext("webgl", S) || E.getContext("experimental-webgl", S);
			if (null === ze) {
				if (null !== E.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
				throw Error("Error creating WebGL context.")
			}
			void 0 === ze.getShaderPrecisionFormat && (ze.getShaderPrecisionFormat = function() {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			})
		} catch (e) {
			throw console.error("THREE.WebGLRenderer: " + e.message), e
		}
		n();
		var ke = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new St(le) : new Mt(le);
		this.vr = ke;
		var Ne = new mt(le, G, k.maxTextureSize);
		this.shadowMap = Ne, this.getContext = function() {
			return ze
		}, this.getContextAttributes = function() {
			return ze.getContextAttributes()
		}, this.forceContextLoss = function() {
			var e = z.get("WEBGL_lose_context");
			e && e.loseContext()
		}, this.forceContextRestore = function() {
			var e = z.get("WEBGL_lose_context");
			e && e.restoreContext()
		}, this.getPixelRatio = function() {
			return Se
		}, this.setPixelRatio = function(e) {
			void 0 !== e && (Se = e, this.setSize(Ee, Me, !1))
		}, this.getSize = function(e) {
			return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new i), e.set(Ee, Me)
		}, this.setSize = function(e, t, i) {
			ke.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Ee = e, Me = t, E.width = e * Se, E.height = t * Se, !1 !== i && (E.style.width = e + "px", E.style.height = t + "px"), this.setViewport(0, 0, e, t))
		}, this.getDrawingBufferSize = function(e) {
			return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new i), e.set(Ee * Se, Me * Se)
		}, this.setDrawingBufferSize = function(e, t, i) {
			Ee = e, Me = t, Se = i, E.width = e * i, E.height = t * i, this.setViewport(0, 0, e, t)
		}, this.getCurrentViewport = function(e) {
			return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new a), e.copy(we)
		}, this.getViewport = function(e) {
			return e.copy(Te)
		}, this.setViewport = function(e, t, i, n) {
			e.isVector4 ? Te.set(e.x, e.y, e.z, e.w) : Te.set(e, t, i, n), N.viewport(we.copy(Te).multiplyScalar(Se))
		}, this.getScissor = function(e) {
			return e.copy(Ae)
		}, this.setScissor = function(e, t, i, n) {
			e.isVector4 ? Ae.set(e.x, e.y, e.z, e.w) : Ae.set(e, t, i, n), N.scissor(xe.copy(Ae).multiplyScalar(Se))
		}, this.getScissorTest = function() {
			return Le
		}, this.setScissorTest = function(e) {
			N.setScissorTest(Le = e)
		}, this.getClearColor = function() {
			return X.getClearColor()
		}, this.setClearColor = function() {
			X.setClearColor.apply(X, arguments)
		}, this.getClearAlpha = function() {
			return X.getClearAlpha()
		}, this.setClearAlpha = function() {
			X.setClearAlpha.apply(X, arguments)
		}, this.clear = function(e, t, i) {
			var n = 0;
			(void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), ze.clear(n)
		}, this.clearColor = function() {
			this.clear(!0, !1, !1)
		}, this.clearDepth = function() {
			this.clear(!1, !0, !1)
		}, this.clearStencil = function() {
			this.clear(!1, !1, !0)
		}, this.dispose = function() {
			E.removeEventListener("webglcontextlost", o, !1), E.removeEventListener("webglcontextrestored", s, !1), W.dispose(), q.dispose(), H.dispose(), G.dispose(), ke.dispose(), He.stop()
		}, this.renderBufferImmediate = function(e, t) {
			N.initAttributes();
			var i = H.get(e);
			e.hasPositions && !i.position && (i.position = ze.createBuffer()), e.hasNormals && !i.normal && (i.normal = ze.createBuffer()), e.hasUvs && !i.uv && (i.uv = ze.createBuffer()), e.hasColors && !i.color && (i.color = ze.createBuffer()), t = t.getAttributes(), e.hasPositions && (ze.bindBuffer(34962, i.position), ze.bufferData(34962, e.positionArray, 35048), N.enableAttribute(t.position), ze.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (ze.bindBuffer(34962, i.normal), ze.bufferData(34962, e.normalArray, 35048), N.enableAttribute(t.normal), ze.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (ze.bindBuffer(34962, i.uv), ze.bufferData(34962, e.uvArray, 35048), N.enableAttribute(t.uv), ze.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (ze.bindBuffer(34962, i.color), ze.bufferData(34962, e.colorArray, 35048), N.enableAttribute(t.color), ze.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), N.disableUnusedAttributes(), ze.drawArrays(4, 0, e.count), e.count = 0
		}, this.renderBufferDirect = function(e, i, n, r, o, s) {
			var a = o.isMesh && 0 > o.matrixWorld.determinant();
			N.setMaterial(r, a);
			var l = f(e, i, r, o),
				c = !1;
			t === n.id && ge === l.id && ve === (!0 === r.wireframe) || (t = n.id, ge = l.id, ve = !0 === r.wireframe, c = !0), o.morphTargetInfluences && (Y.update(o, n, r, l), c = !0), a = n.index;
			var h = n.attributes.position;
			if (i = 1, !0 === r.wireframe && (a = j.getWireframeAttribute(n), i = 2), e = Z, null !== a) {
				var u = U.get(a);
				(e = re).setIndex(u)
			}
			if (c) {
				if (n && n.isInstancedBufferGeometry && !k.isWebGL2 && null === z.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				else {
					N.initAttributes(), c = n.attributes, l = l.getAttributes();
					var d = r.defaultAttributeValues;
					for (E in l) {
						var p = l[E];
						if (0 <= p) {
							var m = c[E];
							if (void 0 !== m) {
								var g = m.normalized,
									v = m.itemSize,
									y = U.get(m);
								if (void 0 !== y) {
									var b = y.buffer,
										w = y.type;
									if (y = y.bytesPerElement, m.isInterleavedBufferAttribute) {
										var x = m.data,
											_ = x.stride;
										m = m.offset, x && x.isInstancedInterleavedBuffer ? (N.enableAttributeAndDivisor(p, x.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = x.meshPerAttribute * x.count)) : N.enableAttribute(p), ze.bindBuffer(34962, b), ze.vertexAttribPointer(p, v, w, g, _ * y, m * y)
									} else m.isInstancedBufferAttribute ? (N.enableAttributeAndDivisor(p, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : N.enableAttribute(p), ze.bindBuffer(34962, b), ze.vertexAttribPointer(p, v, w, g, 0, 0)
								}
							} else if (void 0 !== d && void 0 !== (g = d[E])) switch (g.length) {
								case 2:
									ze.vertexAttrib2fv(p, g);
									break;
								case 3:
									ze.vertexAttrib3fv(p, g);
									break;
								case 4:
									ze.vertexAttrib4fv(p, g);
									break;
								default:
									ze.vertexAttrib1fv(p, g)
							}
						}
					}
					N.disableUnusedAttributes()
				}
				null !== a && ze.bindBuffer(34963, u.buffer)
			}
			u = 1 / 0, null !== a ? u = a.count : void 0 !== h && (u = h.count), a = n.drawRange.start * i, h = null !== s ? s.start * i : 0;
			var E = Math.max(a, h);
			if (0 !== (s = Math.max(0, Math.min(u, a + n.drawRange.count * i, h + (null !== s ? s.count * i : 1 / 0)) - 1 - E + 1))) {
				if (o.isMesh)
					if (!0 === r.wireframe) N.setLineWidth(r.wireframeLinewidth * (null === pe ? Se : 1)), e.setMode(1);
					else switch (o.drawMode) {
						case 0:
							e.setMode(4);
							break;
						case 1:
							e.setMode(5);
							break;
						case 2:
							e.setMode(6)
					} else o.isLine ? (void 0 === (r = r.linewidth) && (r = 1), N.setLineWidth(r * (null === pe ? Se : 1)), o.isLineSegments ? e.setMode(1) : o.isLineLoop ? e.setMode(2) : e.setMode(3)) : o.isPoints ? e.setMode(0) : o.isSprite && e.setMode(4);
				n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && e.renderInstances(n, E, s) : e.render(E, s)
			}
		}, this.compile = function(e, t) {
			(D = q.get(e, t)).init(), e.traverse((function(e) {
				e.isLight && (D.pushLight(e), e.castShadow && D.pushShadow(e))
			})), D.setupLights(t), e.traverse((function(t) {
				if (t.material)
					if (Array.isArray(t.material))
						for (var i = 0; i < t.material.length; i++) p(t.material[i], e.fog, t);
					else p(t.material, e.fog, t)
			}))
		};
		var Be = null,
			He = new w;
		He.setAnimationLoop((function(e) {
			ke.isPresenting() || Be && Be(e)
		})), "undefined" != typeof window && He.setContext(window), this.setAnimationLoop = function(e) {
			Be = e, ke.setAnimationLoop(e), He.start()
		}, this.render = function(e, i, n, r) {
			if (void 0 !== n) {
				console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
				var o = n
			}
			if (void 0 !== r) {
				console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
				var s = r
			}
			i && i.isCamera ? ce || (ge = t = null, ve = !1, me = -1, ye = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === i.parent && i.updateMatrixWorld(), ke.enabled && (i = ke.getCamera(i)), (D = q.get(e, i)).init(), e.onBeforeRender(le, e, i, o || pe), Oe.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), Ce.setFromMatrix(Oe), Re = this.localClippingEnabled, Ie = Pe.init(this.clippingPlanes, Re, i), (O = W.get(e, i)).init(), function e(t, i, n, r) {
				if (!1 !== t.visible) {
					if (t.layers.test(i.layers))
						if (t.isGroup) n = t.renderOrder;
						else if (t.isLight) D.pushLight(t), t.castShadow && D.pushShadow(t);
					else if (t.isSprite) {
						if (!t.frustumCulled || Ce.intersectsSprite(t)) {
							r && De.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Oe);
							var o = G.update(t),
								s = t.material;
							s.visible && O.push(t, o, s, n, De.z, null)
						}
					} else if (t.isImmediateRenderObject) r && De.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Oe), O.push(t, null, t.material, n, De.z, null);
					else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || Ce.intersectsObject(t)))
						if (r && De.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Oe), o = G.update(t), s = t.material, Array.isArray(s))
							for (var a = o.groups, l = 0, c = a.length; l < c; l++) {
								var h = a[l],
									u = s[h.materialIndex];
								u && u.visible && O.push(t, o, u, n, De.z, h)
							} else s.visible && O.push(t, o, s, n, De.z, null);
					for (l = 0, c = (t = t.children).length; l < c; l++) e(t[l], i, n, r)
				}
			}(e, i, 0, le.sortObjects), !0 === le.sortObjects && O.sort(), Ie && Pe.beginShadows(), Ne.render(D.state.shadowsArray, e, i), D.setupLights(i), Ie && Pe.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== o && this.setRenderTarget(o), X.render(O, e, i, s), n = O.opaque, r = O.transparent, e.overrideMaterial ? (o = e.overrideMaterial, n.length && h(n, e, i, o), r.length && h(r, e, i, o)) : (n.length && h(n, e, i), r.length && h(r, e, i)), e.onAfterRender(le, e, i), null !== pe && (F.updateRenderTargetMipmap(pe), F.updateMultisampleRenderTarget(pe)), N.buffers.depth.setTest(!0), N.buffers.depth.setMask(!0), N.buffers.color.setMask(!0), N.setPolygonOffset(!1), ke.enabled && ke.submitFrame(), D = O = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
		}, this.setFramebuffer = function(e) {
			he !== e && ze.bindFramebuffer(36160, e), he = e
		}, this.getActiveCubeFace = function() {
			return ue
		}, this.getActiveMipMapLevel = function() {
			return de
		}, this.getRenderTarget = function() {
			return pe
		}, this.setRenderTarget = function(e, t, i) {
			pe = e, ue = t, de = i, e && void 0 === H.get(e).__webglFramebuffer && F.setupRenderTarget(e);
			var n = he,
				r = !1;
			e ? (n = H.get(e).__webglFramebuffer, e.isWebGLRenderTargetCube ? (n = n[t || 0], r = !0) : n = e.isWebGLMultisampleRenderTarget ? H.get(e).__webglMultisampledFramebuffer : n, we.copy(e.viewport), xe.copy(e.scissor), _e = e.scissorTest) : (we.copy(Te).multiplyScalar(Se), xe.copy(Ae).multiplyScalar(Se), _e = Le), fe !== n && (ze.bindFramebuffer(36160, n), fe = n), N.viewport(we), N.scissor(xe), N.setScissorTest(_e), r && (e = H.get(e.texture), ze.framebufferTexture2D(36160, 36064, 34069 + (t || 0), e.__webglTexture, i || 0))
		}, this.readRenderTargetPixels = function(e, t, i, n, r, o, s) {
			if (e && e.isWebGLRenderTarget) {
				var a = H.get(e).__webglFramebuffer;
				if (e.isWebGLRenderTargetCube && void 0 !== s && (a = a[s]), a) {
					s = !1, a !== fe && (ze.bindFramebuffer(36160, a), s = !0);
					try {
						var l = e.texture,
							c = l.format,
							h = l.type;
						1023 !== c && ae.convert(c) !== ze.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || ae.convert(h) === ze.getParameter(35738) || 1015 === h && (k.isWebGL2 || z.get("OES_texture_float") || z.get("WEBGL_color_buffer_float")) || 1016 === h && (k.isWebGL2 ? z.get("EXT_color_buffer_float") : z.get("EXT_color_buffer_half_float")) ? 36053 === ze.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && ze.readPixels(t, i, n, r, ae.convert(c), ae.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
					} finally {
						s && ze.bindFramebuffer(36160, fe)
					}
				}
			} else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
		}, this.copyFramebufferToTexture = function(e, t, i) {
			var n = t.image.width,
				r = t.image.height,
				o = ae.convert(t.format);
			F.setTexture2D(t, 0), ze.copyTexImage2D(3553, i || 0, o, e.x, e.y, n, r, 0)
		}, this.copyTextureToTexture = function(e, t, i, n) {
			var r = t.image.width,
				o = t.image.height,
				s = ae.convert(i.format),
				a = ae.convert(i.type);
			F.setTexture2D(i, 0), t.isDataTexture ? ze.texSubImage2D(3553, n || 0, e.x, e.y, r, o, s, a, t.image.data) : ze.texSubImage2D(3553, n || 0, e.x, e.y, s, a, t.image)
		}
	}

	function At(e, t) {
		this.name = "", this.color = new b(e), this.density = void 0 !== t ? t : 25e-5
	}

	function Lt(e, t, i) {
		this.name = "", this.color = new b(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
	}

	function Ct() {
		S.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
	}

	function Pt(e, t) {
		this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
			offset: 0,
			count: -1
		}, this.version = 0
	}

	function It(e, t, i, n) {
		this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
	}

	function Rt(e) {
		V.call(this), this.type = "SpriteMaterial", this.color = new b(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
	}

	function Ot(e) {
		if (S.call(this), this.type = "Sprite", void 0 === No) {
			No = new H;
			var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
			t = new Pt(t, 5), No.setIndex([0, 1, 2, 0, 2, 3]), No.addAttribute("position", new It(t, 3, 0, !1)), No.addAttribute("uv", new It(t, 2, 3, !1))
		}
		this.geometry = No, this.material = void 0 !== e ? e : new Rt, this.center = new i(.5, .5)
	}

	function Dt() {
		S.call(this), this.type = "LOD", Object.defineProperties(this, {
			levels: {
				enumerable: !0,
				value: []
			}
		})
	}

	function zt(e, t) {
		e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new g, this.bindMatrixInverse = new g
	}

	function kt(e, t) {
		if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
		else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
		else
			for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new g)
	}

	function Nt() {
		S.call(this), this.type = "Bone"
	}

	function Bt(e) {
		V.call(this), this.type = "LineBasicMaterial", this.color = new b(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(e)
	}

	function Ht(e, t, i) {
		1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), S.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new H, this.material = void 0 !== t ? t : new Bt({
			color: 16777215 * Math.random()
		})
	}

	function Ft(e, t) {
		Ht.call(this, e, t), this.type = "LineSegments"
	}

	function Ut(e, t) {
		Ht.call(this, e, t), this.type = "LineLoop"
	}

	function jt(e) {
		V.call(this), this.type = "PointsMaterial", this.color = new b(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(e)
	}

	function Gt(e, t) {
		S.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new H, this.material = void 0 !== t ? t : new jt({
			color: 16777215 * Math.random()
		})
	}

	function Vt(e, t, i, n, r, o, a, l, c) {
		s.call(this, e, t, i, n, r, o, a, l, c), this.format = void 0 !== a ? a : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
	}

	function Wt(e, t, i, n, r, o, a, l, c, h, u, d) {
		s.call(this, null, o, a, l, c, h, n, r, u, d), this.image = {
			width: t,
			height: i
		}, this.mipmaps = e, this.generateMipmaps = this.flipY = !1
	}

	function qt(e, t, i, n, r, o, a, l, c) {
		s.call(this, e, t, i, n, r, o, a, l, c), this.needsUpdate = !0
	}

	function Xt(e, t, i, n, r, o, a, l, c, h) {
		if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), s.call(this, null, n, r, o, a, l, h, i, c), this.image = {
			width: e,
			height: t
		}, this.magFilter = void 0 !== a ? a : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
	}

	function Yt(e) {
		H.call(this), this.type = "WireframeGeometry";
		var t, i, n, o = [],
			s = [0, 0],
			a = {},
			l = ["a", "b", "c"];
		if (e && e.isGeometry) {
			var c = e.faces,
				h = 0;
			for (i = c.length; h < i; h++) {
				var u = c[h];
				for (t = 0; 3 > t; t++) {
					var d = u[l[t]],
						p = u[l[(t + 1) % 3]];
					s[0] = Math.min(d, p), s[1] = Math.max(d, p), void 0 === a[d = s[0] + "," + s[1]] && (a[d] = {
						index1: s[0],
						index2: s[1]
					})
				}
			}
			for (d in a) h = a[d], l = e.vertices[h.index1], o.push(l.x, l.y, l.z), l = e.vertices[h.index2], o.push(l.x, l.y, l.z)
		} else if (e && e.isBufferGeometry)
			if (l = new r, null !== e.index) {
				c = e.attributes.position, u = e.index;
				var f = e.groups;
				for (0 === f.length && (f = [{
						start: 0,
						count: u.count,
						materialIndex: 0
					}]), e = 0, n = f.length; e < n; ++e)
					for (t = (h = f[e]).start, i = h.count, h = t, i = t + i; h < i; h += 3)
						for (t = 0; 3 > t; t++) d = u.getX(h + t), p = u.getX(h + (t + 1) % 3), s[0] = Math.min(d, p), s[1] = Math.max(d, p), void 0 === a[d = s[0] + "," + s[1]] && (a[d] = {
							index1: s[0],
							index2: s[1]
						});
				for (d in a) h = a[d], l.fromBufferAttribute(c, h.index1), o.push(l.x, l.y, l.z), l.fromBufferAttribute(c, h.index2), o.push(l.x, l.y, l.z)
			} else
				for (h = 0, i = (c = e.attributes.position).count / 3; h < i; h++)
					for (t = 0; 3 > t; t++) a = 3 * h + t, l.fromBufferAttribute(c, a), o.push(l.x, l.y, l.z), a = 3 * h + (t + 1) % 3, l.fromBufferAttribute(c, a), o.push(l.x, l.y, l.z);
		this.addAttribute("position", new z(o, 3))
	}

	function Zt(e, t, i) {
		T.call(this), this.type = "ParametricGeometry", this.parameters = {
			func: e,
			slices: t,
			stacks: i
		}, this.fromBufferGeometry(new Qt(e, t, i)), this.mergeVertices()
	}

	function Qt(e, t, i) {
		H.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
			func: e,
			slices: t,
			stacks: i
		};
		var n, o, s = [],
			a = [],
			l = [],
			c = [],
			h = new r,
			u = new r,
			d = new r,
			p = new r,
			f = new r;
		3 > e.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
		var m = t + 1;
		for (n = 0; n <= i; n++) {
			var g = n / i;
			for (o = 0; o <= t; o++) {
				var v = o / t;
				e(v, g, u), a.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (e(v - 1e-5, g, d), p.subVectors(u, d)) : (e(v + 1e-5, g, d), p.subVectors(d, u)), 0 <= g - 1e-5 ? (e(v, g - 1e-5, d), f.subVectors(u, d)) : (e(v, g + 1e-5, d), f.subVectors(d, u)), h.crossVectors(p, f).normalize(), l.push(h.x, h.y, h.z), c.push(v, g)
			}
		}
		for (n = 0; n < i; n++)
			for (o = 0; o < t; o++) e = n * m + o + 1, h = (n + 1) * m + o + 1, u = (n + 1) * m + o, s.push(n * m + o, e, u), s.push(e, h, u);
		this.setIndex(s), this.addAttribute("position", new z(a, 3)), this.addAttribute("normal", new z(l, 3)), this.addAttribute("uv", new z(c, 2))
	}

	function Jt(e, t, i, n) {
		T.call(this), this.type = "PolyhedronGeometry", this.parameters = {
			vertices: e,
			indices: t,
			radius: i,
			detail: n
		}, this.fromBufferGeometry(new Kt(e, t, i, n)), this.mergeVertices()
	}

	function Kt(e, t, n, o) {
		function s(e) {
			c.push(e.x, e.y, e.z)
		}

		function a(t, i) {
			t *= 3, i.x = e[t + 0], i.y = e[t + 1], i.z = e[t + 2]
		}

		function l(e, t, i, n) {
			0 > n && 1 === e.x && (h[t] = e.x - 1), 0 === i.x && 0 === i.z && (h[t] = n / 2 / Math.PI + .5)
		}
		H.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
			vertices: e,
			indices: t,
			radius: n,
			detail: o
		}, n = n || 1;
		var c = [],
			h = [];
		! function(e) {
			for (var i = new r, n = new r, o = new r, l = 0; l < t.length; l += 3) {
				a(t[l + 0], i), a(t[l + 1], n), a(t[l + 2], o);
				var c, h, u = i,
					d = n,
					p = o,
					f = Math.pow(2, e),
					m = [];
				for (h = 0; h <= f; h++) {
					m[h] = [];
					var g = u.clone().lerp(p, h / f),
						v = d.clone().lerp(p, h / f),
						y = f - h;
					for (c = 0; c <= y; c++) m[h][c] = 0 === c && h === f ? g : g.clone().lerp(v, c / y)
				}
				for (h = 0; h < f; h++)
					for (c = 0; c < 2 * (f - h) - 1; c++) u = Math.floor(c / 2), 0 == c % 2 ? (s(m[h][u + 1]), s(m[h + 1][u]), s(m[h][u])) : (s(m[h][u + 1]), s(m[h + 1][u + 1]), s(m[h + 1][u]))
			}
		}(o = o || 0),
		function(e) {
			for (var t = new r, i = 0; i < c.length; i += 3) t.x = c[i + 0], t.y = c[i + 1], t.z = c[i + 2], t.normalize().multiplyScalar(e), c[i + 0] = t.x, c[i + 1] = t.y, c[i + 2] = t.z
		}(n),
		function() {
			for (var e = new r, t = 0; t < c.length; t += 3) e.x = c[t + 0], e.y = c[t + 1], e.z = c[t + 2], h.push(Math.atan2(e.z, -e.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5));
			e = new r, t = new r;
			for (var n = new r, o = new r, s = new i, a = new i, u = new i, d = 0, p = 0; d < c.length; d += 9, p += 6) {
				e.set(c[d + 0], c[d + 1], c[d + 2]), t.set(c[d + 3], c[d + 4], c[d + 5]), n.set(c[d + 6], c[d + 7], c[d + 8]), s.set(h[p + 0], h[p + 1]), a.set(h[p + 2], h[p + 3]), u.set(h[p + 4], h[p + 5]), o.copy(e).add(t).add(n).divideScalar(3);
				var f = Math.atan2(o.z, -o.x);
				l(s, p + 0, e, f), l(a, p + 2, t, f), l(u, p + 4, n, f)
			}
			for (e = 0; e < h.length; e += 6) t = h[e + 0], n = h[e + 2], o = h[e + 4], s = Math.min(t, n, o), .9 < Math.max(t, n, o) && .1 > s && (.2 > t && (h[e + 0] += 1), .2 > n && (h[e + 2] += 1), .2 > o && (h[e + 4] += 1))
		}(), this.addAttribute("position", new z(c, 3)), this.addAttribute("normal", new z(c.slice(), 3)), this.addAttribute("uv", new z(h, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals()
	}

	function $t(e, t) {
		T.call(this), this.type = "TetrahedronGeometry", this.parameters = {
			radius: e,
			detail: t
		}, this.fromBufferGeometry(new ei(e, t)), this.mergeVertices()
	}

	function ei(e, t) {
		Kt.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
			radius: e,
			detail: t
		}
	}

	function ti(e, t) {
		T.call(this), this.type = "OctahedronGeometry", this.parameters = {
			radius: e,
			detail: t
		}, this.fromBufferGeometry(new ii(e, t)), this.mergeVertices()
	}

	function ii(e, t) {
		Kt.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
			radius: e,
			detail: t
		}
	}

	function ni(e, t) {
		T.call(this), this.type = "IcosahedronGeometry", this.parameters = {
			radius: e,
			detail: t
		}, this.fromBufferGeometry(new ri(e, t)), this.mergeVertices()
	}

	function ri(e, t) {
		var i = (1 + Math.sqrt(5)) / 2;
		Kt.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
			radius: e,
			detail: t
		}
	}

	function oi(e, t) {
		T.call(this), this.type = "DodecahedronGeometry", this.parameters = {
			radius: e,
			detail: t
		}, this.fromBufferGeometry(new si(e, t)), this.mergeVertices()
	}

	function si(e, t) {
		var i = (1 + Math.sqrt(5)) / 2,
			n = 1 / i;
		Kt.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
			radius: e,
			detail: t
		}
	}

	function ai(e, t, i, n, r, o) {
		T.call(this), this.type = "TubeGeometry", this.parameters = {
			path: e,
			tubularSegments: t,
			radius: i,
			radialSegments: n,
			closed: r
		}, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), e = new li(e, t, i, n, r), this.tangents = e.tangents, this.normals = e.normals, this.binormals = e.binormals, this.fromBufferGeometry(e), this.mergeVertices()
	}

	function li(e, t, n, o, s) {
		function a(i) {
			f = e.getPointAt(i / t, f);
			var r = l.normals[i];
			for (i = l.binormals[i], h = 0; h <= o; h++) {
				var s = h / o * Math.PI * 2,
					a = Math.sin(s);
				s = -Math.cos(s), d.x = s * r.x + a * i.x, d.y = s * r.y + a * i.y, d.z = s * r.z + a * i.z, d.normalize(), g.push(d.x, d.y, d.z), u.x = f.x + n * d.x, u.y = f.y + n * d.y, u.z = f.z + n * d.z, m.push(u.x, u.y, u.z)
			}
		}
		H.call(this), this.type = "TubeBufferGeometry", this.parameters = {
			path: e,
			tubularSegments: t,
			radius: n,
			radialSegments: o,
			closed: s
		}, t = t || 64, n = n || 1, o = o || 8, s = s || !1;
		var l = e.computeFrenetFrames(t, s);
		this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
		var c, h, u = new r,
			d = new r,
			p = new i,
			f = new r,
			m = [],
			g = [],
			v = [],
			y = [];
		for (c = 0; c < t; c++) a(c);
		for (a(!1 === s ? t : 0), c = 0; c <= t; c++)
			for (h = 0; h <= o; h++) p.x = c / t, p.y = h / o, v.push(p.x, p.y);
		! function() {
			for (h = 1; h <= t; h++)
				for (c = 1; c <= o; c++) {
					var e = (o + 1) * h + (c - 1),
						i = (o + 1) * h + c,
						n = (o + 1) * (h - 1) + c;
					y.push((o + 1) * (h - 1) + (c - 1), e, n), y.push(e, i, n)
				}
		}(), this.setIndex(y), this.addAttribute("position", new z(m, 3)), this.addAttribute("normal", new z(g, 3)), this.addAttribute("uv", new z(v, 2))
	}

	function ci(e, t, i, n, r, o, s) {
		T.call(this), this.type = "TorusKnotGeometry", this.parameters = {
			radius: e,
			tube: t,
			tubularSegments: i,
			radialSegments: n,
			p: r,
			q: o
		}, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new hi(e, t, i, n, r, o)), this.mergeVertices()
	}

	function hi(e, t, i, n, o, s) {
		function a(e, t, i, n, r) {
			var o = Math.sin(e);
			t = i / t * e, i = Math.cos(t), r.x = n * (2 + i) * .5 * Math.cos(e), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(t) * .5
		}
		H.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
			radius: e,
			tube: t,
			tubularSegments: i,
			radialSegments: n,
			p: o,
			q: s
		}, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, s = s || 3;
		var l, c = [],
			h = [],
			u = [],
			d = [],
			p = new r,
			f = new r,
			m = new r,
			g = new r,
			v = new r,
			y = new r,
			b = new r;
		for (l = 0; l <= i; ++l) {
			var w = l / i * o * Math.PI * 2;
			for (a(w, o, s, e, m), a(w + .01, o, s, e, g), y.subVectors(g, m), b.addVectors(g, m), v.crossVectors(y, b), b.crossVectors(v, y), v.normalize(), b.normalize(), w = 0; w <= n; ++w) {
				var x = w / n * Math.PI * 2,
					_ = -t * Math.cos(x);
				x = t * Math.sin(x), p.x = m.x + (_ * b.x + x * v.x), p.y = m.y + (_ * b.y + x * v.y), p.z = m.z + (_ * b.z + x * v.z), h.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), u.push(f.x, f.y, f.z), d.push(l / i), d.push(w / n)
			}
		}
		for (w = 1; w <= i; w++)
			for (l = 1; l <= n; l++) e = (n + 1) * w + (l - 1), t = (n + 1) * w + l, o = (n + 1) * (w - 1) + l, c.push((n + 1) * (w - 1) + (l - 1), e, o), c.push(e, t, o);
		this.setIndex(c), this.addAttribute("position", new z(h, 3)), this.addAttribute("normal", new z(u, 3)), this.addAttribute("uv", new z(d, 2))
	}

	function ui(e, t, i, n, r) {
		T.call(this), this.type = "TorusGeometry", this.parameters = {
			radius: e,
			tube: t,
			radialSegments: i,
			tubularSegments: n,
			arc: r
		}, this.fromBufferGeometry(new di(e, t, i, n, r)), this.mergeVertices()
	}

	function di(e, t, i, n, o) {
		H.call(this), this.type = "TorusBufferGeometry", this.parameters = {
			radius: e,
			tube: t,
			radialSegments: i,
			tubularSegments: n,
			arc: o
		}, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
		var s, a, l = [],
			c = [],
			h = [],
			u = [],
			d = new r,
			p = new r,
			f = new r;
		for (s = 0; s <= i; s++)
			for (a = 0; a <= n; a++) {
				var m = a / n * o,
					g = s / i * Math.PI * 2;
				p.x = (e + t * Math.cos(g)) * Math.cos(m), p.y = (e + t * Math.cos(g)) * Math.sin(m), p.z = t * Math.sin(g), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), h.push(f.x, f.y, f.z), u.push(a / n), u.push(s / i)
			}
		for (s = 1; s <= i; s++)
			for (a = 1; a <= n; a++) e = (n + 1) * (s - 1) + a - 1, t = (n + 1) * (s - 1) + a, o = (n + 1) * s + a, l.push((n + 1) * s + a - 1, e, o), l.push(e, t, o);
		this.setIndex(l), this.addAttribute("position", new z(c, 3)), this.addAttribute("normal", new z(h, 3)), this.addAttribute("uv", new z(u, 2))
	}

	function pi(e, t, i, n, r) {
		for (var o, s = 0, a = t, l = i - n; a < i; a += n) s += (e[l] - e[a]) * (e[a + 1] + e[l + 1]), l = a;
		if (r === 0 < s)
			for (r = t; r < i; r += n) o = Si(r, e[r], e[r + 1], o);
		else
			for (r = i - n; r >= t; r -= n) o = Si(r, e[r], e[r + 1], o);
		return o && xi(o, o.next) && (Ti(o), o = o.next), o
	}

	function fi(e, t) {
		if (!e) return e;
		t || (t = e);
		do {
			var i = !1;
			if (e.steiner || !xi(e, e.next) && 0 !== wi(e.prev, e, e.next)) e = e.next;
			else {
				if (Ti(e), (e = t = e.prev) === e.next) break;
				i = !0
			}
		} while (i || e !== t);
		return t
	}

	function mi(e, t) {
		return e.x - t.x
	}

	function gi(e, t) {
		var i = t,
			n = e.x,
			r = e.y,
			o = -1 / 0;
		do {
			if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
				var s = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
				if (s <= n && s > o) {
					if (o = s, s === n) {
						if (r === i.y) return i;
						if (r === i.next.y) return i.next
					}
					var a = i.x < i.next.x ? i : i.next
				}
			}
			i = i.next
		} while (i !== t);
		if (!a) return null;
		if (n === o) return a.prev;
		t = a, s = a.x;
		var l = a.y,
			c = 1 / 0;
		for (i = a.next; i !== t;) {
			if (n >= i.x && i.x >= s && n !== i.x && bi(r < l ? n : o, r, s, l, r < l ? o : n, r, i.x, i.y)) {
				var h = Math.abs(r - i.y) / (n - i.x);
				(h < c || h === c && i.x > a.x) && Ei(i, e) && (a = i, c = h)
			}
			i = i.next
		}
		return a
	}

	function vi(e, t, i, n, r) {
		return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
	}

	function yi(e) {
		var t = e,
			i = e;
		do {
			t.x < i.x && (i = t), t = t.next
		} while (t !== e);
		return i
	}

	function bi(e, t, i, n, r, o, s, a) {
		return 0 <= (r - s) * (t - a) - (e - s) * (o - a) && 0 <= (e - s) * (n - a) - (i - s) * (t - a) && 0 <= (i - s) * (o - a) - (r - s) * (n - a)
	}

	function wi(e, t, i) {
		return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
	}

	function xi(e, t) {
		return e.x === t.x && e.y === t.y
	}

	function _i(e, t, i, n) {
		return !!(xi(e, t) && xi(i, n) || xi(e, n) && xi(i, t)) || 0 < wi(e, t, i) != 0 < wi(e, t, n) && 0 < wi(i, n, e) != 0 < wi(i, n, t)
	}

	function Ei(e, t) {
		return 0 > wi(e.prev, e, e.next) ? 0 <= wi(e, t, e.next) && 0 <= wi(e, e.prev, t) : 0 > wi(e, t, e.prev) || 0 > wi(e, e.next, t)
	}

	function Mi(e, t) {
		var i = new Ai(e.i, e.x, e.y),
			n = new Ai(t.i, t.x, t.y),
			r = e.next,
			o = t.prev;
		return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
	}

	function Si(e, t, i, n) {
		return e = new Ai(e, t, i), n ? (e.next = n.next, e.prev = n, n.next.prev = e, n.next = e) : (e.prev = e, e.next = e), e
	}

	function Ti(e) {
		e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
	}

	function Ai(e, t, i) {
		this.i = e, this.x = t, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
	}

	function Li(e) {
		var t = e.length;
		2 < t && e[t - 1].equals(e[0]) && e.pop()
	}

	function Ci(e, t) {
		for (var i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
	}

	function Pi(e, t) {
		T.call(this), this.type = "ExtrudeGeometry", this.parameters = {
			shapes: e,
			options: t
		}, this.fromBufferGeometry(new Ii(e, t)), this.mergeVertices()
	}

	function Ii(e, t) {
		function n(e) {
			function n(e, t, i) {
				return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
			}

			function l(e, t, n) {
				var r = e.x - t.x,
					o = e.y - t.y,
					s = n.x - e.x,
					a = n.y - e.y,
					l = r * r + o * o;
				if (Math.abs(r * a - o * s) > Number.EPSILON) {
					var c = Math.sqrt(l),
						h = Math.sqrt(s * s + a * a);
					if (l = t.x - o / c, t = t.y + r / c, 2 >= (o = (s = l + r * (a = ((n.x - a / h - l) * a - (n.y + s / h - t) * s) / (r * a - o * s)) - e.x) * s + (r = t + o * a - e.y) * r)) return new i(s, r);
					o = Math.sqrt(o / 2)
				} else e = !1, r > Number.EPSILON ? s > Number.EPSILON && (e = !0) : r < -Number.EPSILON ? s < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(a) && (e = !0), e ? (s = -o, o = Math.sqrt(l)) : (s = r, r = o, o = Math.sqrt(l / 2));
				return new i(s / o, r / o)
			}

			function c(e, t) {
				for (U = e.length; 0 <= --U;) {
					var i = U,
						n = U - 1;
					0 > n && (n = e.length - 1);
					var r, a = g + 2 * _;
					for (r = 0; r < a; r++) {
						var l = H * r,
							c = H * (r + 1),
							h = t + n + l,
							u = t + n + c;
						c = t + i + c, d(t + i + l), d(h), d(c), d(h), d(u), d(c), l = s.length / 3, p((l = M.generateSideWallUV(o, s, l - 6, l - 3, l - 2, l - 1))[0]), p(l[1]), p(l[3]), p(l[1]), p(l[2]), p(l[3])
					}
				}
			}

			function h(e, t, i) {
				f.push(e), f.push(t), f.push(i)
			}

			function u(e, t, i) {
				d(e), d(t), d(i), e = s.length / 3, p((e = M.generateTopUV(o, s, e - 3, e - 2, e - 1))[0]), p(e[1]), p(e[2])
			}

			function d(e) {
				s.push(f[3 * e]), s.push(f[3 * e + 1]), s.push(f[3 * e + 2])
			}

			function p(e) {
				a.push(e.x), a.push(e.y)
			}
			var f = [],
				m = void 0 !== t.curveSegments ? t.curveSegments : 12,
				g = void 0 !== t.steps ? t.steps : 1,
				v = void 0 !== t.depth ? t.depth : 100,
				y = void 0 === t.bevelEnabled || t.bevelEnabled,
				b = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
				w = void 0 !== t.bevelSize ? t.bevelSize : b - 2,
				x = void 0 !== t.bevelOffset ? t.bevelOffset : 0,
				_ = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
				E = t.extrudePath,
				M = void 0 !== t.UVGenerator ? t.UVGenerator : Uo;
			void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = t.amount);
			var S, T = !1;
			if (E) {
				var A = E.getSpacedPoints(g);
				T = !0, y = !1;
				var L = E.computeFrenetFrames(g, !1),
					C = new r,
					P = new r,
					I = new r
			}
			y || (x = w = b = _ = 0), m = e.extractPoints(m), e = m.shape;
			var R = m.holes;
			if (!Fo.isClockWise(e)) {
				e = e.reverse();
				var O = 0;
				for (S = R.length; O < S; O++) {
					var D = R[O];
					Fo.isClockWise(D) && (R[O] = D.reverse())
				}
			}
			var z = Fo.triangulateShape(e, R),
				k = e;
			for (O = 0, S = R.length; O < S; O++) D = R[O], e = e.concat(D);
			var N, B, H = e.length,
				F = z.length;
			m = [];
			var U = 0,
				j = k.length,
				G = j - 1;
			for (N = U + 1; U < j; U++, G++, N++) G === j && (G = 0), N === j && (N = 0), m[U] = l(k[U], k[G], k[N]);
			E = [];
			var V = m.concat();
			for (O = 0, S = R.length; O < S; O++) {
				D = R[O];
				var W = [];
				for (U = 0, G = (j = D.length) - 1, N = U + 1; U < j; U++, G++, N++) G === j && (G = 0), N === j && (N = 0), W[U] = l(D[U], D[G], D[N]);
				E.push(W), V = V.concat(W)
			}
			for (G = 0; G < _; G++) {
				j = G / _;
				var q = b * Math.cos(j * Math.PI / 2);
				for (N = w * Math.sin(j * Math.PI / 2) + x, U = 0, j = k.length; U < j; U++) {
					var X = n(k[U], m[U], N);
					h(X.x, X.y, -q)
				}
				for (O = 0, S = R.length; O < S; O++)
					for (D = R[O], W = E[O], U = 0, j = D.length; U < j; U++) h((X = n(D[U], W[U], N)).x, X.y, -q)
			}
			for (N = w + x, U = 0; U < H; U++) X = y ? n(e[U], V[U], N) : e[U], T ? (P.copy(L.normals[0]).multiplyScalar(X.x), C.copy(L.binormals[0]).multiplyScalar(X.y), I.copy(A[0]).add(P).add(C), h(I.x, I.y, I.z)) : h(X.x, X.y, 0);
			for (j = 1; j <= g; j++)
				for (U = 0; U < H; U++) X = y ? n(e[U], V[U], N) : e[U], T ? (P.copy(L.normals[j]).multiplyScalar(X.x), C.copy(L.binormals[j]).multiplyScalar(X.y), I.copy(A[j]).add(P).add(C), h(I.x, I.y, I.z)) : h(X.x, X.y, v / g * j);
			for (G = _ - 1; 0 <= G; G--) {
				for (j = G / _, q = b * Math.cos(j * Math.PI / 2), N = w * Math.sin(j * Math.PI / 2) + x, U = 0, j = k.length; U < j; U++) h((X = n(k[U], m[U], N)).x, X.y, v + q);
				for (O = 0, S = R.length; O < S; O++)
					for (D = R[O], W = E[O], U = 0, j = D.length; U < j; U++) X = n(D[U], W[U], N), T ? h(X.x, X.y + A[g - 1].y, A[g - 1].x + q) : h(X.x, X.y, v + q)
			}! function() {
				var e = s.length / 3;
				if (y) {
					var t = 0 * H;
					for (U = 0; U < F; U++) u((B = z[U])[2] + t, B[1] + t, B[0] + t);
					for (t = H * (g + 2 * _), U = 0; U < F; U++) u((B = z[U])[0] + t, B[1] + t, B[2] + t)
				} else {
					for (U = 0; U < F; U++) u((B = z[U])[2], B[1], B[0]);
					for (U = 0; U < F; U++) u((B = z[U])[0] + H * g, B[1] + H * g, B[2] + H * g)
				}
				o.addGroup(e, s.length / 3 - e, 0)
			}(),
			function() {
				var e = s.length / 3,
					t = 0;
				for (c(k, t), t += k.length, O = 0, S = R.length; O < S; O++) c(D = R[O], t), t += D.length;
				o.addGroup(e, s.length / 3 - e, 1)
			}()
		}
		H.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
			shapes: e,
			options: t
		}, e = Array.isArray(e) ? e : [e];
		for (var o = this, s = [], a = [], l = 0, c = e.length; l < c; l++) n(e[l]);
		this.addAttribute("position", new z(s, 3)), this.addAttribute("uv", new z(a, 2)), this.computeVertexNormals()
	}

	function Ri(e, t, i) {
		if (i.shapes = [], Array.isArray(e))
			for (var n = 0, r = e.length; n < r; n++) i.shapes.push(e[n].uuid);
		else i.shapes.push(e.uuid);
		return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i
	}

	function Oi(e, t) {
		T.call(this), this.type = "TextGeometry", this.parameters = {
			text: e,
			parameters: t
		}, this.fromBufferGeometry(new Di(e, t)), this.mergeVertices()
	}

	function Di(e, t) {
		var i = (t = t || {}).font;
		if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new T;
		e = i.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Ii.call(this, e, t), this.type = "TextBufferGeometry"
	}

	function zi(e, t, i, n, r, o, s) {
		T.call(this), this.type = "SphereGeometry", this.parameters = {
			radius: e,
			widthSegments: t,
			heightSegments: i,
			phiStart: n,
			phiLength: r,
			thetaStart: o,
			thetaLength: s
		}, this.fromBufferGeometry(new ki(e, t, i, n, r, o, s)), this.mergeVertices()
	}

	function ki(e, t, i, n, o, s, a) {
		H.call(this), this.type = "SphereBufferGeometry", this.parameters = {
			radius: e,
			widthSegments: t,
			heightSegments: i,
			phiStart: n,
			phiLength: o,
			thetaStart: s,
			thetaLength: a
		}, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : Math.PI;
		var l, c, h = Math.min(s + a, Math.PI),
			u = 0,
			d = [],
			p = new r,
			f = new r,
			m = [],
			g = [],
			v = [],
			y = [];
		for (c = 0; c <= i; c++) {
			var b = [],
				w = c / i,
				x = 0;
			for (0 == c && 0 == s ? x = .5 / t : c == i && h == Math.PI && (x = -.5 / t), l = 0; l <= t; l++) {
				var _ = l / t;
				p.x = -e * Math.cos(n + _ * o) * Math.sin(s + w * a), p.y = e * Math.cos(s + w * a), p.z = e * Math.sin(n + _ * o) * Math.sin(s + w * a), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(_ + x, 1 - w), b.push(u++)
			}
			d.push(b)
		}
		for (c = 0; c < i; c++)
			for (l = 0; l < t; l++) e = d[c][l + 1], n = d[c][l], o = d[c + 1][l], a = d[c + 1][l + 1], (0 !== c || 0 < s) && m.push(e, n, a), (c !== i - 1 || h < Math.PI) && m.push(n, o, a);
		this.setIndex(m), this.addAttribute("position", new z(g, 3)), this.addAttribute("normal", new z(v, 3)), this.addAttribute("uv", new z(y, 2))
	}

	function Ni(e, t, i, n, r, o) {
		T.call(this), this.type = "RingGeometry", this.parameters = {
			innerRadius: e,
			outerRadius: t,
			thetaSegments: i,
			phiSegments: n,
			thetaStart: r,
			thetaLength: o
		}, this.fromBufferGeometry(new Bi(e, t, i, n, r, o)), this.mergeVertices()
	}

	function Bi(e, t, n, o, s, a) {
		H.call(this), this.type = "RingBufferGeometry", this.parameters = {
			innerRadius: e,
			outerRadius: t,
			thetaSegments: n,
			phiSegments: o,
			thetaStart: s,
			thetaLength: a
		}, e = e || .5, t = t || 1, s = void 0 !== s ? s : 0, a = void 0 !== a ? a : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
		var l, c, h = [],
			u = [],
			d = [],
			p = [],
			f = e,
			m = (t - e) / (o = void 0 !== o ? Math.max(1, o) : 1),
			g = new r,
			v = new i;
		for (l = 0; l <= o; l++) {
			for (c = 0; c <= n; c++) e = s + c / n * a, g.x = f * Math.cos(e), g.y = f * Math.sin(e), u.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, p.push(v.x, v.y);
			f += m
		}
		for (l = 0; l < o; l++)
			for (t = l * (n + 1), c = 0; c < n; c++) s = (e = c + t) + n + 1, a = e + n + 2, f = e + 1, h.push(e, s, f), h.push(s, a, f);
		this.setIndex(h), this.addAttribute("position", new z(u, 3)), this.addAttribute("normal", new z(d, 3)), this.addAttribute("uv", new z(p, 2))
	}

	function Hi(e, t, i, n) {
		T.call(this), this.type = "LatheGeometry", this.parameters = {
			points: e,
			segments: t,
			phiStart: i,
			phiLength: n
		}, this.fromBufferGeometry(new Fi(e, t, i, n)), this.mergeVertices()
	}

	function Fi(e, t, n, o) {
		H.call(this), this.type = "LatheBufferGeometry", this.parameters = {
			points: e,
			segments: t,
			phiStart: n,
			phiLength: o
		}, t = Math.floor(t) || 12, n = n || 0, o = o || 2 * Math.PI, o = uo.clamp(o, 0, 2 * Math.PI);
		var s, a = [],
			l = [],
			c = [],
			h = 1 / t,
			u = new r,
			d = new i;
		for (s = 0; s <= t; s++) {
			var p = n + s * h * o,
				f = Math.sin(p),
				m = Math.cos(p);
			for (p = 0; p <= e.length - 1; p++) u.x = e[p].x * f, u.y = e[p].y, u.z = e[p].x * m, l.push(u.x, u.y, u.z), d.x = s / t, d.y = p / (e.length - 1), c.push(d.x, d.y)
		}
		for (s = 0; s < t; s++)
			for (p = 0; p < e.length - 1; p++) h = (n = p + s * e.length) + e.length, u = n + e.length + 1, d = n + 1, a.push(n, h, d), a.push(h, u, d);
		if (this.setIndex(a), this.addAttribute("position", new z(l, 3)), this.addAttribute("uv", new z(c, 2)), this.computeVertexNormals(), o === 2 * Math.PI)
			for (o = this.attributes.normal.array, a = new r, l = new r, c = new r, n = t * e.length * 3, p = s = 0; s < e.length; s++, p += 3) a.x = o[p + 0], a.y = o[p + 1], a.z = o[p + 2], l.x = o[n + p + 0], l.y = o[n + p + 1], l.z = o[n + p + 2], c.addVectors(a, l).normalize(), o[p + 0] = o[n + p + 0] = c.x, o[p + 1] = o[n + p + 1] = c.y, o[p + 2] = o[n + p + 2] = c.z
	}

	function Ui(e, t) {
		T.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
			shapes: e,
			curveSegments: t
		}, this.fromBufferGeometry(new ji(e, t)), this.mergeVertices()
	}

	function ji(e, t) {
		function i(e) {
			var i, a = r.length / 3,
				c = (e = e.extractPoints(t)).shape,
				h = e.holes;
			for (!1 === Fo.isClockWise(c) && (c = c.reverse()), e = 0, i = h.length; e < i; e++) {
				var u = h[e];
				!0 === Fo.isClockWise(u) && (h[e] = u.reverse())
			}
			var d = Fo.triangulateShape(c, h);
			for (e = 0, i = h.length; e < i; e++) u = h[e], c = c.concat(u);
			for (e = 0, i = c.length; e < i; e++) u = c[e], r.push(u.x, u.y, 0), o.push(0, 0, 1), s.push(u.x, u.y);
			for (e = 0, i = d.length; e < i; e++) c = d[e], n.push(c[0] + a, c[1] + a, c[2] + a), l += 3
		}
		H.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
			shapes: e,
			curveSegments: t
		}, t = t || 12;
		var n = [],
			r = [],
			o = [],
			s = [],
			a = 0,
			l = 0;
		if (!1 === Array.isArray(e)) i(e);
		else
			for (var c = 0; c < e.length; c++) i(e[c]), this.addGroup(a, l, c), a += l, l = 0;
		this.setIndex(n), this.addAttribute("position", new z(r, 3)), this.addAttribute("normal", new z(o, 3)), this.addAttribute("uv", new z(s, 2))
	}

	function Gi(e, t) {
		if (t.shapes = [], Array.isArray(e))
			for (var i = 0, n = e.length; i < n; i++) t.shapes.push(e[i].uuid);
		else t.shapes.push(e.uuid);
		return t
	}

	function Vi(e, t) {
		H.call(this), this.type = "EdgesGeometry", this.parameters = {
			thresholdAngle: t
		};
		var i = [];
		t = Math.cos(uo.DEG2RAD * (void 0 !== t ? t : 1));
		var n = [0, 0],
			r = {},
			o = ["a", "b", "c"];
		if (e.isBufferGeometry) {
			var s = new T;
			s.fromBufferGeometry(e)
		} else s = e.clone();
		s.mergeVertices(), s.computeFaceNormals(), e = s.vertices;
		for (var a = 0, l = (s = s.faces).length; a < l; a++)
			for (var c = s[a], h = 0; 3 > h; h++) {
				var u = c[o[h]],
					d = c[o[(h + 1) % 3]];
				n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] ? r[u] = {
					index1: n[0],
					index2: n[1],
					face1: a,
					face2: void 0
				} : r[u].face2 = a
			}
		for (u in r)(void 0 === (n = r[u]).face2 || s[n.face1].normal.dot(s[n.face2].normal) <= t) && (o = e[n.index1], i.push(o.x, o.y, o.z), o = e[n.index2], i.push(o.x, o.y, o.z));
		this.addAttribute("position", new z(i, 3))
	}

	function Wi(e, t, i, n, r, o, s, a) {
		T.call(this), this.type = "CylinderGeometry", this.parameters = {
			radiusTop: e,
			radiusBottom: t,
			height: i,
			radialSegments: n,
			heightSegments: r,
			openEnded: o,
			thetaStart: s,
			thetaLength: a
		}, this.fromBufferGeometry(new qi(e, t, i, n, r, o, s, a)), this.mergeVertices()
	}

	function qi(e, t, n, o, s, a, l, c) {
		function h(n) {
			var s, a = new i,
				h = new r,
				v = 0,
				w = !0 === n ? e : t,
				x = !0 === n ? 1 : -1,
				_ = g;
			for (s = 1; s <= o; s++) p.push(0, y * x, 0), f.push(0, x, 0), m.push(.5, .5), g++;
			var E = g;
			for (s = 0; s <= o; s++) {
				var M = s / o * c + l,
					S = Math.cos(M);
				M = Math.sin(M), h.x = w * M, h.y = y * x, h.z = w * S, p.push(h.x, h.y, h.z), f.push(0, x, 0), a.x = .5 * S + .5, a.y = .5 * M * x + .5, m.push(a.x, a.y), g++
			}
			for (s = 0; s < o; s++) a = _ + s, h = E + s, !0 === n ? d.push(h, h + 1, a) : d.push(h + 1, h, a), v += 3;
			u.addGroup(b, v, !0 === n ? 1 : 2), b += v
		}
		H.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
			radiusTop: e,
			radiusBottom: t,
			height: n,
			radialSegments: o,
			heightSegments: s,
			openEnded: a,
			thetaStart: l,
			thetaLength: c
		};
		var u = this;
		e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, n = n || 1, o = Math.floor(o) || 8, s = Math.floor(s) || 1, a = void 0 !== a && a, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
		var d = [],
			p = [],
			f = [],
			m = [],
			g = 0,
			v = [],
			y = n / 2,
			b = 0;
		! function() {
			var i, a, h = new r,
				w = new r,
				x = 0,
				_ = (t - e) / n;
			for (a = 0; a <= s; a++) {
				var E = [],
					M = a / s,
					S = M * (t - e) + e;
				for (i = 0; i <= o; i++) {
					var T = i / o,
						A = T * c + l,
						L = Math.sin(A);
					A = Math.cos(A), w.x = S * L, w.y = -M * n + y, w.z = S * A, p.push(w.x, w.y, w.z), h.set(L, _, A).normalize(), f.push(h.x, h.y, h.z), m.push(T, 1 - M), E.push(g++)
				}
				v.push(E)
			}
			for (i = 0; i < o; i++)
				for (a = 0; a < s; a++) h = v[a + 1][i], w = v[a + 1][i + 1], _ = v[a][i + 1], d.push(v[a][i], h, _), d.push(h, w, _), x += 6;
			u.addGroup(b, x, 0), b += x
		}(), !1 === a && (0 < e && h(!0), 0 < t && h(!1)), this.setIndex(d), this.addAttribute("position", new z(p, 3)), this.addAttribute("normal", new z(f, 3)), this.addAttribute("uv", new z(m, 2))
	}

	function Xi(e, t, i, n, r, o, s) {
		Wi.call(this, 0, e, t, i, n, r, o, s), this.type = "ConeGeometry", this.parameters = {
			radius: e,
			height: t,
			radialSegments: i,
			heightSegments: n,
			openEnded: r,
			thetaStart: o,
			thetaLength: s
		}
	}

	function Yi(e, t, i, n, r, o, s) {
		qi.call(this, 0, e, t, i, n, r, o, s), this.type = "ConeBufferGeometry", this.parameters = {
			radius: e,
			height: t,
			radialSegments: i,
			heightSegments: n,
			openEnded: r,
			thetaStart: o,
			thetaLength: s
		}
	}

	function Zi(e, t, i, n) {
		T.call(this), this.type = "CircleGeometry", this.parameters = {
			radius: e,
			segments: t,
			thetaStart: i,
			thetaLength: n
		}, this.fromBufferGeometry(new Qi(e, t, i, n)), this.mergeVertices()
	}

	function Qi(e, t, n, o) {
		H.call(this), this.type = "CircleBufferGeometry", this.parameters = {
			radius: e,
			segments: t,
			thetaStart: n,
			thetaLength: o
		}, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI;
		var s, a = [],
			l = [],
			c = [],
			h = [],
			u = new r,
			d = new i;
		l.push(0, 0, 0), c.push(0, 0, 1), h.push(.5, .5);
		var p = 0;
		for (s = 3; p <= t; p++, s += 3) {
			var f = n + p / t * o;
			u.x = e * Math.cos(f), u.y = e * Math.sin(f), l.push(u.x, u.y, u.z), c.push(0, 0, 1), d.x = (l[s] / e + 1) / 2, d.y = (l[s + 1] / e + 1) / 2, h.push(d.x, d.y)
		}
		for (s = 1; s <= t; s++) a.push(s, s + 1, 0);
		this.setIndex(a), this.addAttribute("position", new z(l, 3)), this.addAttribute("normal", new z(c, 3)), this.addAttribute("uv", new z(h, 2))
	}

	function Ji(e) {
		V.call(this), this.type = "ShadowMaterial", this.color = new b(0), this.transparent = !0, this.setValues(e)
	}

	function Ki(e) {
		W.call(this, e), this.type = "RawShaderMaterial"
	}

	function $i(e) {
		V.call(this), this.defines = {
			STANDARD: ""
		}, this.type = "MeshStandardMaterial", this.color = new b(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}

	function en(e) {
		$i.call(this), this.defines = {
			PHYSICAL: ""
		}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(e)
	}

	function tn(e) {
		V.call(this), this.type = "MeshPhongMaterial", this.color = new b(16777215), this.specular = new b(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}

	function nn(e) {
		tn.call(this), this.defines = {
			TOON: ""
		}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
	}

	function rn(e) {
		V.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(e)
	}

	function on(e) {
		V.call(this), this.type = "MeshLambertMaterial", this.color = new b(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new b(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}

	function sn(e) {
		V.call(this), this.defines = {
			MATCAP: ""
		}, this.type = "MeshMatcapMaterial", this.color = new b(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(e)
	}

	function an(e) {
		Bt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
	}

	function ln(e, t, i, n) {
		this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i
	}

	function cn(e, t, i, n) {
		ln.call(this, e, t, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
	}

	function hn(e, t, i, n) {
		ln.call(this, e, t, i, n)
	}

	function un(e, t, i, n) {
		ln.call(this, e, t, i, n)
	}

	function dn(e, t, i, n) {
		if (void 0 === e) throw Error("THREE.KeyframeTrack: track name is undefined");
		if (void 0 === t || 0 === t.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
		this.name = e, this.times = Vo.convertArray(t, this.TimeBufferType), this.values = Vo.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
	}

	function pn(e, t, i) {
		dn.call(this, e, t, i)
	}

	function fn(e, t, i, n) {
		dn.call(this, e, t, i, n)
	}

	function mn(e, t, i, n) {
		dn.call(this, e, t, i, n)
	}

	function gn(e, t, i, n) {
		ln.call(this, e, t, i, n)
	}

	function vn(e, t, i, n) {
		dn.call(this, e, t, i, n)
	}

	function yn(e, t, i, n) {
		dn.call(this, e, t, i, n)
	}

	function bn(e, t, i, n) {
		dn.call(this, e, t, i, n)
	}

	function wn(e, t, i) {
		this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = uo.generateUUID(), 0 > this.duration && this.resetDuration()
	}

	function xn(e) {
		if (void 0 === e.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
		var t = function(e) {
			switch (e.toLowerCase()) {
				case "scalar":
				case "double":
				case "float":
				case "number":
				case "integer":
					return mn;
				case "vector":
				case "vector2":
				case "vector3":
				case "vector4":
					return bn;
				case "color":
					return fn;
				case "quaternion":
					return vn;
				case "bool":
				case "boolean":
					return pn;
				case "string":
					return yn
			}
			throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
		}(e.type);
		if (void 0 === e.times) {
			var i = [],
				n = [];
			Vo.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
		}
		return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
	}

	function _n(e, t, i) {
		var n = this,
			r = !1,
			o = 0,
			s = 0,
			a = void 0;
		this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
			s++, !1 === r && void 0 !== n.onStart && n.onStart(e, o, s), r = !0
		}, this.itemEnd = function(e) {
			o++, void 0 !== n.onProgress && n.onProgress(e, o, s), o === s && (r = !1, void 0 !== n.onLoad) && n.onLoad()
		}, this.itemError = function(e) {
			void 0 !== n.onError && n.onError(e)
		}, this.resolveURL = function(e) {
			return a ? a(e) : e
		}, this.setURLModifier = function(e) {
			return a = e, this
		}
	}

	function En(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function Mn(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function Sn(e) {
		this.manager = void 0 !== e ? e : qo, this._parser = null
	}

	function Tn(e) {
		this.manager = void 0 !== e ? e : qo, this._parser = null
	}

	function An(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function Ln(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function Cn(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function Pn() {
		this.type = "Curve", this.arcLengthDivisions = 200
	}

	function In(e, t, i, n, r, o, s, a) {
		Pn.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = a || 0
	}

	function Rn(e, t, i, n, r, o) {
		In.call(this, e, t, i, i, n, r, o), this.type = "ArcCurve"
	}

	function On() {
		var e = 0,
			t = 0,
			i = 0,
			n = 0;
		return {
			initCatmullRom: function(r, o, s, a, l) {
				e = o, t = r = l * (s - r), i = -3 * o + 3 * s - 2 * r - (a = l * (a - o)), n = 2 * o - 2 * s + r + a
			},
			initNonuniformCatmullRom: function(r, o, s, a, l, c, h) {
				e = o, t = r = ((o - r) / l - (s - r) / (l + c) + (s - o) / c) * c, i = -3 * o + 3 * s - 2 * r - (a = ((s - o) / c - (a - o) / (c + h) + (a - s) / h) * c), n = 2 * o - 2 * s + r + a
			},
			calc: function(r) {
				var o = r * r;
				return e + t * r + i * o + n * o * r
			}
		}
	}

	function Dn(e, t, i, n) {
		Pn.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5
	}

	function zn(e, t, i, n, r) {
		var o = e * e;
		return (2 * i - 2 * n + (t = .5 * (n - t)) + (r = .5 * (r - i))) * e * o + (-3 * i + 3 * n - 2 * t - r) * o + t * e + i
	}

	function kn(e, t, i, n) {
		var r = 1 - e;
		return r * r * t + 2 * (1 - e) * e * i + e * e * n
	}

	function Nn(e, t, i, n, r) {
		var o = 1 - e,
			s = 1 - e;
		return o * o * o * t + 3 * s * s * e * i + 3 * (1 - e) * e * e * n + e * e * e * r
	}

	function Bn(e, t, n, r) {
		Pn.call(this), this.type = "CubicBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i, this.v3 = r || new i
	}

	function Hn(e, t, i, n) {
		Pn.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r, this.v3 = n || new r
	}

	function Fn(e, t) {
		Pn.call(this), this.type = "LineCurve", this.v1 = e || new i, this.v2 = t || new i
	}

	function Un(e, t) {
		Pn.call(this), this.type = "LineCurve3", this.v1 = e || new r, this.v2 = t || new r
	}

	function jn(e, t, n) {
		Pn.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new i, this.v1 = t || new i, this.v2 = n || new i
	}

	function Gn(e, t, i) {
		Pn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new r, this.v1 = t || new r, this.v2 = i || new r
	}

	function Vn(e) {
		Pn.call(this), this.type = "SplineCurve", this.points = e || []
	}

	function Wn() {
		Pn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
	}

	function qn(e) {
		Wn.call(this), this.type = "Path", this.currentPoint = new i, e && this.setFromPoints(e)
	}

	function Xn(e) {
		qn.call(this, e), this.uuid = uo.generateUUID(), this.type = "Shape", this.holes = []
	}

	function Yn(e, t) {
		S.call(this), this.type = "Light", this.color = new b(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
	}

	function Zn(e, t, i) {
		Yn.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(S.DefaultUp), this.updateMatrix(), this.groundColor = new b(t)
	}

	function Qn(e) {
		this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new g
	}

	function Jn() {
		Qn.call(this, new xt(50, 1, .5, 500))
	}

	function Kn(e, t, i, n, r, o) {
		Yn.call(this, e, t), this.type = "SpotLight", this.position.copy(S.DefaultUp), this.updateMatrix(), this.target = new S, Object.defineProperty(this, "power", {
			get: function() {
				return this.intensity * Math.PI
			},
			set: function(e) {
				this.intensity = e / Math.PI
			}
		}), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Jn
	}

	function $n(e, t, i, n) {
		Yn.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
			get: function() {
				return 4 * this.intensity * Math.PI
			},
			set: function(e) {
				this.intensity = e / (4 * Math.PI)
			}
		}), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Qn(new xt(90, 1, .5, 500))
	}

	function er(e, t, i, n, r, o) {
		wt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
	}

	function tr() {
		Qn.call(this, new er(-5, 5, 5, -5, .5, 500))
	}

	function ir(e, t) {
		Yn.call(this, e, t), this.type = "DirectionalLight", this.position.copy(S.DefaultUp), this.updateMatrix(), this.target = new S, this.shadow = new tr
	}

	function nr(e, t) {
		Yn.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
	}

	function rr(e, t, i, n) {
		Yn.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
	}

	function or(e) {
		this.manager = void 0 !== e ? e : qo, this.textures = {}
	}

	function sr() {
		H.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
	}

	function ar(e, t, i, n) {
		"number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), A.call(this, e, t, i), this.meshPerAttribute = n || 1
	}

	function lr(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function cr(e) {
		this.manager = void 0 !== e ? e : qo, this.resourcePath = ""
	}

	function hr(e) {
		"undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : qo, this.options = void 0
	}

	function ur() {
		this.type = "ShapePath", this.color = new b, this.subPaths = [], this.currentPath = null
	}

	function dr(e) {
		this.type = "Font", this.data = e
	}

	function pr(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function fr() {}

	function mr(e) {
		this.manager = void 0 !== e ? e : qo
	}

	function gr() {
		this.coefficients = [];
		for (var e = 0; 9 > e; e++) this.coefficients.push(new r)
	}

	function vr(e, t) {
		Yn.call(this, void 0, t), this.sh = void 0 !== e ? e : new gr
	}

	function yr(e, t, i) {
		vr.call(this, void 0, i), e = (new b).set(e), i = (new b).set(t), t = new r(e.r, e.g, e.b), e = new r(i.r, i.g, i.b);
		var n = (i = Math.sqrt(Math.PI)) * Math.sqrt(.75);
		this.sh.coefficients[0].copy(t).add(e).multiplyScalar(i), this.sh.coefficients[1].copy(t).sub(e).multiplyScalar(n)
	}

	function br(e, t) {
		vr.call(this, void 0, t), e = (new b).set(e), this.sh.coefficients[0].set(e.r, e.g, e.b).multiplyScalar(2 * Math.sqrt(Math.PI))
	}

	function wr() {
		this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new xt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new xt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
	}

	function xr(e, t, i, n) {
		S.call(this), this.type = "CubeCamera";
		var o = new xt(90, 1, e, t);
		o.up.set(0, -1, 0), o.lookAt(new r(1, 0, 0)), this.add(o);
		var s = new xt(90, 1, e, t);
		s.up.set(0, -1, 0), s.lookAt(new r(-1, 0, 0)), this.add(s);
		var a = new xt(90, 1, e, t);
		a.up.set(0, 0, 1), a.lookAt(new r(0, 1, 0)), this.add(a);
		var l = new xt(90, 1, e, t);
		l.up.set(0, 0, -1), l.lookAt(new r(0, -1, 0)), this.add(l);
		var c = new xt(90, 1, e, t);
		c.up.set(0, -1, 0), c.lookAt(new r(0, 0, 1)), this.add(c);
		var u = new xt(90, 1, e, t);
		u.up.set(0, -1, 0), u.lookAt(new r(0, 0, -1)), this.add(u), n = n || {
			format: 1022,
			magFilter: 1006,
			minFilter: 1006
		}, this.renderTarget = new h(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) {
			null === this.parent && this.updateMatrixWorld();
			var i = e.getRenderTarget(),
				n = this.renderTarget,
				r = n.texture.generateMipmaps;
			n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, o), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, a), e.setRenderTarget(n, 3), e.render(t, l), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = r, e.setRenderTarget(n, 5), e.render(t, u), e.setRenderTarget(i)
		}, this.clear = function(e, t, i, n) {
			for (var r = e.getRenderTarget(), o = this.renderTarget, s = 0; 6 > s; s++) e.setRenderTarget(o, s), e.clear(t, i, n);
			e.setRenderTarget(r)
		}
	}

	function _r(e) {
		this.autoStart = void 0 === e || e, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
	}

	function Er() {
		S.call(this), this.type = "AudioListener", this.context = as.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
	}

	function Mr(e) {
		S.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
	}

	function Sr(e) {
		Mr.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
	}

	function Tr(e, t) {
		this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
	}

	function Ar(e, t, i) {
		switch (this.binding = e, this.valueSize = i, e = Float64Array, t) {
			case "quaternion":
				t = this._slerp;
				break;
			case "string":
			case "bool":
				e = Array, t = this._select;
				break;
			default:
				t = this._lerp
		}
		this.buffer = new e(4 * i), this._mixBufferRegion = t, this.referenceCount = this.useCount = this.cumulativeWeight = 0
	}

	function Lr(e, t, i) {
		i = i || Cr.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, i)
	}

	function Cr(e, t, i) {
		this.path = t, this.parsedPath = i || Cr.parseTrackName(t), this.node = Cr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
	}

	function Pr() {
		this.uuid = uo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
		var e = {};
		this._indicesByUUID = e;
		for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
		this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
		var n = this;
		this.stats = {
			objects: {
				get total() {
					return n._objects.length
				},
				get inUse() {
					return this.total - n.nCachedObjects_
				}
			},
			get bindingsPerObject() {
				return n._bindings.length
			}
		}
	}

	function Ir(e, t, i) {
		this._mixer = e, this._clip = t, this._localRoot = i || null, t = (e = t.tracks).length, i = Array(t);
		for (var n = {
				endingStart: 2400,
				endingEnd: 2400
			}, r = 0; r !== t; ++r) {
			var o = e[r].createInterpolant(null);
			i[r] = o, o.settings = n
		}
		this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(t), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
	}

	function Rr(e) {
		this._root = e, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
	}

	function Or(e, t) {
		"string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = t), this.value = e
	}

	function Dr(e, t, i) {
		Pt.call(this, e, t), this.meshPerAttribute = i || 1
	}

	function zr(e, t, i, n) {
		this.ray = new q(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		}, Object.defineProperties(this.params, {
			PointCloud: {
				get: function() {
					return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
				}
			}
		})
	}

	function kr(e, t) {
		return e.distance - t.distance
	}

	function Nr(e, t, i, n) {
		if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) {
			n = 0;
			for (var r = (e = e.children).length; n < r; n++) Nr(e[n], t, i, !0)
		}
	}

	function Br(e, t, i) {
		return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
	}

	function Hr(e, t, i) {
		return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this
	}

	function Fr(e, t) {
		this.min = void 0 !== e ? e : new i(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new i(-1 / 0, -1 / 0)
	}

	function Ur(e, t) {
		this.start = void 0 !== e ? e : new r, this.end = void 0 !== t ? t : new r
	}

	function jr(e) {
		S.call(this), this.material = e, this.render = function() {}
	}

	function Gr(e, t, i, n) {
		this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = 3 * i.faces.length : i && i.isBufferGeometry && (t = i.attributes.normal.count), i = new H, t = new z(6 * t, 3), i.addAttribute("position", t), Ft.call(this, i, new Bt({
			color: e,
			linewidth: n
		})), this.matrixAutoUpdate = !1, this.update()
	}

	function Vr(e, t) {
		S.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, e = new H, t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
		for (var i = 0, n = 1; 32 > i; i++, n++) {
			var r = i / 32 * Math.PI * 2,
				o = n / 32 * Math.PI * 2;
			t.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1)
		}
		e.addAttribute("position", new z(t, 3)), t = new Bt({
			fog: !1
		}), this.cone = new Ft(e, t), this.add(this.cone), this.update()
	}

	function Wr(e) {
		for (var t = function e(t) {
				var i = [];
				t && t.isBone && i.push(t);
				for (var n = 0; n < t.children.length; n++) i.push.apply(i, e(t.children[n]));
				return i
			}(e), i = new H, n = [], r = [], o = new b(0, 0, 1), s = new b(0, 1, 0), a = 0; a < t.length; a++) {
			var l = t[a];
			l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(s.r, s.g, s.b))
		}
		i.addAttribute("position", new z(n, 3)), i.addAttribute("color", new z(r, 3)), n = new Bt({
			vertexColors: 2,
			depthTest: !1,
			depthWrite: !1,
			transparent: !0
		}), Ft.call(this, i, n), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
	}

	function qr(e, t, i) {
		this.light = e, this.light.updateMatrixWorld(), this.color = i, e = new ki(t, 4, 2), t = new Y({
			wireframe: !0,
			fog: !1
		}), Z.call(this, e, t), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
	}

	function Xr(e, t) {
		this.type = "RectAreaLightHelper", this.light = e, this.color = t, (e = new H).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), e.computeBoundingSphere(), t = new Bt({
			fog: !1
		}), Ht.call(this, e, t), (e = new H).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), e.computeBoundingSphere(), this.add(new Z(e, new Y({
			side: 1,
			fog: !1
		}))), this.update()
	}

	function Yr(e, t, i) {
		S.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (e = new ii(t)).rotateY(.5 * Math.PI), this.material = new Y({
			wireframe: !0,
			fog: !1
		}), void 0 === this.color && (this.material.vertexColors = 2), t = e.getAttribute("position"), t = new Float32Array(3 * t.count), e.addAttribute("color", new A(t, 3)), this.add(new Z(e, this.material)), this.update()
	}

	function Zr(e, t) {
		this.lightProbe = e, this.size = t, e = new W({
			defines: {
				GAMMA_OUTPUT: ""
			},
			uniforms: {
				sh: {
					value: this.lightProbe.sh.coefficients
				},
				intensity: {
					value: this.lightProbe.intensity
				}
			},
			vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
		}), t = new ki(1, 32, 16), Z.call(this, t, e), this.onBeforeRender()
	}

	function Qr(e, t, i, n) {
		e = e || 10, t = t || 10, i = new b(void 0 !== i ? i : 4473924), n = new b(void 0 !== n ? n : 8947848);
		var r = t / 2,
			o = e / t,
			s = e / 2;
		e = [];
		for (var a = [], l = 0, c = 0, h = -s; l <= t; l++, h += o) {
			e.push(-s, 0, h, s, 0, h), e.push(h, 0, -s, h, 0, s);
			var u = l === r ? i : n;
			u.toArray(a, c), c += 3, u.toArray(a, c), c += 3, u.toArray(a, c), c += 3, u.toArray(a, c), c += 3
		}(t = new H).addAttribute("position", new z(e, 3)), t.addAttribute("color", new z(a, 3)), i = new Bt({
			vertexColors: 2
		}), Ft.call(this, t, i)
	}

	function Jr(e, t, i, n, r, o) {
		e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new b(void 0 !== r ? r : 4473924), o = new b(void 0 !== o ? o : 8947848);
		var s, a = [],
			l = [];
		for (s = 0; s <= t; s++) {
			var c = s / t * 2 * Math.PI,
				h = Math.sin(c) * e;
			c = Math.cos(c) * e, a.push(0, 0, 0), a.push(h, 0, c);
			var u = 1 & s ? r : o;
			l.push(u.r, u.g, u.b), l.push(u.r, u.g, u.b)
		}
		for (s = 0; s <= i; s++) {
			u = 1 & s ? r : o;
			var d = e - e / i * s;
			for (t = 0; t < n; t++) c = t / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, a.push(h, 0, c), l.push(u.r, u.g, u.b), c = (t + 1) / n * 2 * Math.PI, h = Math.sin(c) * d, c = Math.cos(c) * d, a.push(h, 0, c), l.push(u.r, u.g, u.b)
		}(e = new H).addAttribute("position", new z(a, 3)), e.addAttribute("color", new z(l, 3)), a = new Bt({
			vertexColors: 2
		}), Ft.call(this, e, a)
	}

	function Kr(e, t, i, n) {
		this.audio = e, this.range = t || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2, e = new H, t = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)), e.addAttribute("position", new A(t, 3)), t = new Bt({
			color: 65280
		}), i = new Bt({
			color: 16776960
		}), Ht.call(this, e, [i, t]), this.update()
	}

	function $r(e, t, i, n) {
		this.object = e, this.size = void 0 !== t ? t : 1, e = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, t = 0, (i = this.object.geometry) && i.isGeometry ? t = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new H, t = new z(6 * t, 3), i.addAttribute("position", t), Ft.call(this, i, new Bt({
			color: e,
			linewidth: n
		})), this.matrixAutoUpdate = !1, this.update()
	}

	function eo(e, t, i) {
		S.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1), (e = new H).addAttribute("position", new z([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)), t = new Bt({
			fog: !1
		}), this.lightPlane = new Ht(e, t), this.add(this.lightPlane), (e = new H).addAttribute("position", new z([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ht(e, t), this.add(this.targetLine), this.update()
	}

	function to(e) {
		function t(e, t, n) {
			i(e, n), i(t, n)
		}

		function i(e, t) {
			o.push(0, 0, 0), s.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(o.length / 3 - 1)
		}
		var n = new H,
			r = new Bt({
				color: 16777215,
				vertexColors: 1
			}),
			o = [],
			s = [],
			a = {},
			l = new b(16755200),
			c = new b(16711680),
			h = new b(43775),
			u = new b(16777215),
			d = new b(3355443);
		t("n1", "n2", l), t("n2", "n4", l), t("n4", "n3", l), t("n3", "n1", l), t("f1", "f2", l), t("f2", "f4", l), t("f4", "f3", l), t("f3", "f1", l), t("n1", "f1", l), t("n2", "f2", l), t("n3", "f3", l), t("n4", "f4", l), t("p", "n1", c), t("p", "n2", c), t("p", "n3", c), t("p", "n4", c), t("u1", "u2", h), t("u2", "u3", h), t("u3", "u1", h), t("c", "t", u), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), n.addAttribute("position", new z(o, 3)), n.addAttribute("color", new z(s, 3)), Ft.call(this, n, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
	}

	function io(e, t) {
		this.object = e, void 0 === t && (t = 16776960), e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		var i = new Float32Array(24),
			n = new H;
		n.setIndex(new A(e, 1)), n.addAttribute("position", new A(i, 3)), Ft.call(this, n, new Bt({
			color: t
		})), this.matrixAutoUpdate = !1, this.update()
	}

	function no(e, t) {
		this.type = "Box3Helper", this.box = e, e = void 0 !== t ? t : 16776960, t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		var i = new H;
		i.setIndex(new A(t, 1)), i.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ft.call(this, i, new Bt({
			color: e
		})), this.geometry.computeBoundingSphere()
	}

	function ro(e, t, i) {
		this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t, e = void 0 !== i ? i : 16776960, (t = new H).addAttribute("position", new z([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), t.computeBoundingSphere(), Ht.call(this, t, new Bt({
			color: e
		})), (t = new H).addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), t.computeBoundingSphere(), this.add(new Z(t, new Y({
			color: e,
			opacity: .2,
			transparent: !0,
			depthWrite: !1
		})))
	}

	function oo(e, t, i, n, o, s) {
		S.call(this), void 0 === e && (e = new r(0, 0, 1)), void 0 === t && (t = new r(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === o && (o = .2 * i), void 0 === s && (s = .2 * o), void 0 === os && ((os = new H).addAttribute("position", new z([0, 0, 0, 0, 1, 0], 3)), (ss = new qi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Ht(os, new Bt({
			color: n
		})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(ss, new Y({
			color: n
		})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, o, s)
	}

	function so(e) {
		var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
		(e = new H).addAttribute("position", new z(t, 3)), e.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), t = new Bt({
			vertexColors: 2
		}), Ft.call(this, e, t)
	}

	function ao(e) {
		console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Dn.call(this, e), this.type = "catmullrom", this.closed = !0
	}

	function lo(e) {
		console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Dn.call(this, e), this.type = "catmullrom"
	}

	function co(e) {
		console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Dn.call(this, e), this.type = "catmullrom"
	}
	void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) {
		return "number" == typeof e && isFinite(e) && Math.floor(e) === e
	}), void 0 === Math.sign && (Math.sign = function(e) {
		return 0 > e ? -1 : 0 < e ? 1 : +e
	}), 0 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
		get: function() {
			return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
		}
	}), void 0 === Object.assign && (Object.assign = function(e) {
		if (null == e) throw new TypeError("Cannot convert undefined or null to object");
		for (var t = Object(e), i = 1; i < arguments.length; i++) {
			var n = arguments[i];
			if (null != n)
				for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
		}
		return t
	}), Object.assign(t.prototype, {
		addEventListener: function(e, t) {
			void 0 === this._listeners && (this._listeners = {});
			var i = this._listeners;
			void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
		},
		hasEventListener: function(e, t) {
			if (void 0 === this._listeners) return !1;
			var i = this._listeners;
			return void 0 !== i[e] && -1 !== i[e].indexOf(t)
		},
		removeEventListener: function(e, t) {
			void 0 !== this._listeners && void 0 !== (e = this._listeners[e]) && -1 !== (t = e.indexOf(t)) && e.splice(t, 1)
		},
		dispatchEvent: function(e) {
			if (void 0 !== this._listeners) {
				var t = this._listeners[e.type];
				if (void 0 !== t) {
					e.target = this;
					for (var i = 0, n = (t = t.slice(0)).length; i < n; i++) t[i].call(this, e)
				}
			}
		}
	});
	var ho, uo = {
		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,
		generateUUID: function() {
			for (var e = [], t = 0; 256 > t; t++) e[t] = (16 > t ? "0" : "") + t.toString(16);
			return function() {
				var t = 4294967295 * Math.random() | 0,
					i = 4294967295 * Math.random() | 0,
					n = 4294967295 * Math.random() | 0,
					r = 4294967295 * Math.random() | 0;
				return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase()
			}
		}(),
		clamp: function(e, t, i) {
			return Math.max(t, Math.min(i, e))
		},
		euclideanModulo: function(e, t) {
			return (e % t + t) % t
		},
		mapLinear: function(e, t, i, n, r) {
			return n + (e - t) * (r - n) / (i - t)
		},
		lerp: function(e, t, i) {
			return (1 - i) * e + i * t
		},
		smoothstep: function(e, t, i) {
			return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
		},
		smootherstep: function(e, t, i) {
			return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
		},
		randInt: function(e, t) {
			return e + Math.floor(Math.random() * (t - e + 1))
		},
		randFloat: function(e, t) {
			return e + Math.random() * (t - e)
		},
		randFloatSpread: function(e) {
			return e * (.5 - Math.random())
		},
		degToRad: function(e) {
			return e * uo.DEG2RAD
		},
		radToDeg: function(e) {
			return e * uo.RAD2DEG
		},
		isPowerOfTwo: function(e) {
			return 0 == (e & e - 1) && 0 !== e
		},
		ceilPowerOfTwo: function(e) {
			return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
		},
		floorPowerOfTwo: function(e) {
			return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
		}
	};
	Object.defineProperties(i.prototype, {
		width: {
			get: function() {
				return this.x
			},
			set: function(e) {
				this.x = e
			}
		},
		height: {
			get: function() {
				return this.y
			},
			set: function(e) {
				this.y = e
			}
		}
	}), Object.assign(i.prototype, {
		isVector2: !0,
		set: function(e, t) {
			return this.x = e, this.y = t, this
		},
		setScalar: function(e) {
			return this.y = this.x = e, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setComponent: function(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
			return this
		},
		getComponent: function(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		clone: function() {
			return new this.constructor(this.x, this.y)
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this
		},
		addScaledVector: function(e, t) {
			return this.x += e.x * t, this.y += e.y * t, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
		},
		subScalar: function(e) {
			return this.x -= e, this.y -= e, this
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this
		},
		multiply: function(e) {
			return this.x *= e.x, this.y *= e.y, this
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this
		},
		divide: function(e) {
			return this.x /= e.x, this.y /= e.y, this
		},
		divideScalar: function(e) {
			return this.multiplyScalar(1 / e)
		},
		applyMatrix3: function(e) {
			var t = this.x,
				i = this.y;
			return e = e.elements, this.x = e[0] * t + e[3] * i + e[6], this.y = e[1] * t + e[4] * i + e[7], this
		},
		min: function(e) {
			return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
		},
		max: function(e) {
			return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
		},
		clamp: function(e, t) {
			return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
		},
		clampScalar: function(e, t) {
			return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
		},
		clampLength: function(e, t) {
			var i = this.length();
			return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
		},
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
		},
		negate: function() {
			return this.x = -this.x, this.y = -this.y, this
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y
		},
		cross: function(e) {
			return this.x * e.y - this.y * e.x
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		},
		manhattanLength: function() {
			return Math.abs(this.x) + Math.abs(this.y)
		},
		normalize: function() {
			return this.divideScalar(this.length() || 1)
		},
		angle: function() {
			var e = Math.atan2(this.y, this.x);
			return 0 > e && (e += 2 * Math.PI), e
		},
		distanceTo: function(e) {
			return Math.sqrt(this.distanceToSquared(e))
		},
		distanceToSquared: function(e) {
			var t = this.x - e.x;
			return t * t + (e = this.y - e.y) * e
		},
		manhattanDistanceTo: function(e) {
			return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
		},
		setLength: function(e) {
			return this.normalize().multiplyScalar(e)
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
		},
		lerpVectors: function(e, t, i) {
			return this.subVectors(t, e).multiplyScalar(i).add(e)
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y
		},
		fromArray: function(e, t) {
			return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
		},
		toArray: function(e, t) {
			return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
		},
		fromBufferAttribute: function(e, t, i) {
			return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
		},
		rotateAround: function(e, t) {
			var i = Math.cos(t);
			t = Math.sin(t);
			var n = this.x - e.x,
				r = this.y - e.y;
			return this.x = n * i - r * t + e.x, this.y = n * t + r * i + e.y, this
		}
	}), Object.assign(n, {
		slerp: function(e, t, i, n) {
			return i.copy(e).slerp(t, n)
		},
		slerpFlat: function(e, t, i, n, r, o, s) {
			var a = i[n + 0],
				l = i[n + 1],
				c = i[n + 2];
			i = i[n + 3], n = r[o + 0];
			var h = r[o + 1],
				u = r[o + 2];
			if (i !== (r = r[o + 3]) || a !== n || l !== h || c !== u) {
				o = 1 - s;
				var d = a * n + l * h + c * u + i * r,
					p = 0 <= d ? 1 : -1,
					f = 1 - d * d;
				f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, s = Math.sin(s * d) / f), a = a * o + n * (p *= s), l = l * o + h * p, c = c * o + u * p, i = i * o + r * p, o === 1 - s && (a *= s = 1 / Math.sqrt(a * a + l * l + c * c + i * i), l *= s, c *= s, i *= s)
			}
			e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = i
		}
	}), Object.defineProperties(n.prototype, {
		x: {
			get: function() {
				return this._x
			},
			set: function(e) {
				this._x = e, this.onChangeCallback()
			}
		},
		y: {
			get: function() {
				return this._y
			},
			set: function(e) {
				this._y = e, this.onChangeCallback()
			}
		},
		z: {
			get: function() {
				return this._z
			},
			set: function(e) {
				this._z = e, this.onChangeCallback()
			}
		},
		w: {
			get: function() {
				return this._w
			},
			set: function(e) {
				this._w = e, this.onChangeCallback()
			}
		}
	}), Object.assign(n.prototype, {
		isQuaternion: !0,
		set: function(e, t, i, n) {
			return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this
		},
		clone: function() {
			return new this.constructor(this._x, this._y, this._z, this._w)
		},
		copy: function(e) {
			return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
		},
		setFromEuler: function(e, t) {
			if (!e || !e.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
			var i = e._x,
				n = e._y,
				r = e._z;
			e = e.order;
			var o = Math.cos,
				s = Math.sin,
				a = o(i / 2),
				l = o(n / 2);
			return o = o(r / 2), i = s(i / 2), n = s(n / 2), r = s(r / 2), "XYZ" === e ? (this._x = i * l * o + a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o - i * n * r) : "YXZ" === e ? (this._x = i * l * o + a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o + i * n * r) : "ZXY" === e ? (this._x = i * l * o - a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o - i * n * r) : "ZYX" === e ? (this._x = i * l * o - a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o + i * n * r) : "YZX" === e ? (this._x = i * l * o + a * n * r, this._y = a * n * o + i * l * r, this._z = a * l * r - i * n * o, this._w = a * l * o - i * n * r) : "XZY" === e && (this._x = i * l * o - a * n * r, this._y = a * n * o - i * l * r, this._z = a * l * r + i * n * o, this._w = a * l * o + i * n * r), !1 !== t && this.onChangeCallback(), this
		},
		setFromAxisAngle: function(e, t) {
			t /= 2;
			var i = Math.sin(t);
			return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(t), this.onChangeCallback(), this
		},
		setFromRotationMatrix: function(e) {
			var t = e.elements,
				i = t[0];
			e = t[4];
			var n = t[8],
				r = t[1],
				o = t[5],
				s = t[9],
				a = t[2],
				l = t[6],
				c = i + o + (t = t[10]);
			return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - s) * i, this._y = (n - a) * i, this._z = (r - e) * i) : i > o && i > t ? (i = 2 * Math.sqrt(1 + i - o - t), this._w = (l - s) / i, this._x = .25 * i, this._y = (e + r) / i, this._z = (n + a) / i) : o > t ? (i = 2 * Math.sqrt(1 + o - i - t), this._w = (n - a) / i, this._x = (e + r) / i, this._y = .25 * i, this._z = (s + l) / i) : (i = 2 * Math.sqrt(1 + t - i - o), this._w = (r - e) / i, this._x = (n + a) / i, this._y = (s + l) / i, this._z = .25 * i), this.onChangeCallback(), this
		},
		setFromUnitVectors: function(e, t) {
			var i = e.dot(t) + 1;
			return 1e-6 > i ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = i, this.normalize()
		},
		angleTo: function(e) {
			return 2 * Math.acos(Math.abs(uo.clamp(this.dot(e), -1, 1)))
		},
		rotateTowards: function(e, t) {
			var i = this.angleTo(e);
			return 0 === i || this.slerp(e, Math.min(1, t / i)), this
		},
		inverse: function() {
			return this.conjugate()
		},
		conjugate: function() {
			return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
		},
		dot: function(e) {
			return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
		},
		lengthSq: function() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
		},
		length: function() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
		},
		normalize: function() {
			var e = this.length();
			return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e), this.onChangeCallback(), this
		},
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
		},
		premultiply: function(e) {
			return this.multiplyQuaternions(e, this)
		},
		multiplyQuaternions: function(e, t) {
			var i = e._x,
				n = e._y,
				r = e._z;
			e = e._w;
			var o = t._x,
				s = t._y,
				a = t._z;
			return t = t._w, this._x = i * t + e * o + n * a - r * s, this._y = n * t + e * s + r * o - i * a, this._z = r * t + e * a + i * s - n * o, this._w = e * t - i * o - n * s - r * a, this.onChangeCallback(), this
		},
		slerp: function(e, t) {
			if (0 === t) return this;
			if (1 === t) return this.copy(e);
			var i = this._x,
				n = this._y,
				r = this._z,
				o = this._w,
				s = o * e._w + i * e._x + n * e._y + r * e._z;
			if (0 > s ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), 1 <= s) return this._w = o, this._x = i, this._y = n, this._z = r, this;
			if ((e = 1 - s * s) <= Number.EPSILON) return s = 1 - t, this._w = s * o + t * this._w, this._x = s * i + t * this._x, this._y = s * n + t * this._y, this._z = s * r + t * this._z, this.normalize();
			e = Math.sqrt(e);
			var a = Math.atan2(e, s);
			return s = Math.sin((1 - t) * a) / e, t = Math.sin(t * a) / e, this._w = o * s + this._w * t, this._x = i * s + this._x * t, this._y = n * s + this._y * t, this._z = r * s + this._z * t, this.onChangeCallback(), this
		},
		equals: function(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
		},
		fromArray: function(e, t) {
			return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
		},
		toArray: function(e, t) {
			return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
		},
		onChange: function(e) {
			return this.onChangeCallback = e, this
		},
		onChangeCallback: function() {}
	}), Object.assign(r.prototype, {
		isVector3: !0,
		set: function(e, t, i) {
			return this.x = e, this.y = t, this.z = i, this
		},
		setScalar: function(e) {
			return this.z = this.y = this.x = e, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setZ: function(e) {
			return this.z = e, this
		},
		setComponent: function(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
			return this
		},
		getComponent: function(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		clone: function() {
			return new this.constructor(this.x, this.y, this.z)
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this.z += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
		},
		addScaledVector: function(e, t) {
			return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
		},
		subScalar: function(e) {
			return this.x -= e, this.y -= e, this.z -= e, this
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
		},
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		},
		multiplyVectors: function(e, t) {
			return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
		},
		applyEuler: (ho = new n, function(e) {
			return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(ho.setFromEuler(e))
		}),
		applyAxisAngle: function() {
			var e = new n;
			return function(t, i) {
				return this.applyQuaternion(e.setFromAxisAngle(t, i))
			}
		}(),
		applyMatrix3: function(e) {
			var t = this.x,
				i = this.y,
				n = this.z;
			return e = e.elements, this.x = e[0] * t + e[3] * i + e[6] * n, this.y = e[1] * t + e[4] * i + e[7] * n, this.z = e[2] * t + e[5] * i + e[8] * n, this
		},
		applyMatrix4: function(e) {
			var t = this.x,
				i = this.y,
				n = this.z,
				r = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * n + e[15]);
			return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r, this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r, this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r, this
		},
		applyQuaternion: function(e) {
			var t = this.x,
				i = this.y,
				n = this.z,
				r = e.x,
				o = e.y,
				s = e.z,
				a = (e = e.w) * t + o * n - s * i,
				l = e * i + s * t - r * n,
				c = e * n + r * i - o * t;
			return t = -r * t - o * i - s * n, this.x = a * e + t * -r + l * -s - c * -o, this.y = l * e + t * -o + c * -r - a * -s, this.z = c * e + t * -s + a * -o - l * -r, this
		},
		project: function(e) {
			return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
		},
		unproject: function(e) {
			return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
		},
		transformDirection: function(e) {
			var t = this.x,
				i = this.y,
				n = this.z;
			return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n, this.y = e[1] * t + e[5] * i + e[9] * n, this.z = e[2] * t + e[6] * i + e[10] * n, this.normalize()
		},
		divide: function(e) {
			return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
		},
		divideScalar: function(e) {
			return this.multiplyScalar(1 / e)
		},
		min: function(e) {
			return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
		},
		max: function(e) {
			return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
		},
		clamp: function(e, t) {
			return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
		},
		clampScalar: function(e, t) {
			return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
		},
		clampLength: function(e, t) {
			var i = this.length();
			return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
		},
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
		},
		negate: function() {
			return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		},
		manhattanLength: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
		},
		normalize: function() {
			return this.divideScalar(this.length() || 1)
		},
		setLength: function(e) {
			return this.normalize().multiplyScalar(e)
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
		},
		lerpVectors: function(e, t, i) {
			return this.subVectors(t, e).multiplyScalar(i).add(e)
		},
		cross: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
		},
		crossVectors: function(e, t) {
			var i = e.x,
				n = e.y;
			e = e.z;
			var r = t.x,
				o = t.y;
			return t = t.z, this.x = n * t - e * o, this.y = e * r - i * t, this.z = i * o - n * r, this
		},
		projectOnVector: function(e) {
			var t = e.dot(this) / e.lengthSq();
			return this.copy(e).multiplyScalar(t)
		},
		projectOnPlane: function() {
			var e = new r;
			return function(t) {
				return e.copy(this).projectOnVector(t), this.sub(e)
			}
		}(),
		reflect: function() {
			var e = new r;
			return function(t) {
				return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
			}
		}(),
		angleTo: function(e) {
			return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()), Math.acos(uo.clamp(e, -1, 1))
		},
		distanceTo: function(e) {
			return Math.sqrt(this.distanceToSquared(e))
		},
		distanceToSquared: function(e) {
			var t = this.x - e.x,
				i = this.y - e.y;
			return t * t + i * i + (e = this.z - e.z) * e
		},
		manhattanDistanceTo: function(e) {
			return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
		},
		setFromSpherical: function(e) {
			return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
		},
		setFromSphericalCoords: function(e, t, i) {
			var n = Math.sin(t) * e;
			return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
		},
		setFromCylindrical: function(e) {
			return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
		},
		setFromCylindricalCoords: function(e, t, i) {
			return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
		},
		setFromMatrixPosition: function(e) {
			return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this
		},
		setFromMatrixScale: function(e) {
			var t = this.setFromMatrixColumn(e, 0).length(),
				i = this.setFromMatrixColumn(e, 1).length();
			return e = this.setFromMatrixColumn(e, 2).length(), this.x = t, this.y = i, this.z = e, this
		},
		setFromMatrixColumn: function(e, t) {
			return this.fromArray(e.elements, 4 * t)
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z
		},
		fromArray: function(e, t) {
			return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
		},
		toArray: function(e, t) {
			return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
		},
		fromBufferAttribute: function(e, t, i) {
			return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
		}
	}), Object.assign(o.prototype, {
		isMatrix3: !0,
		set: function(e, t, i, n, r, o, s, a, l) {
			var c = this.elements;
			return c[0] = e, c[1] = n, c[2] = s, c[3] = t, c[4] = r, c[5] = a, c[6] = i, c[7] = o, c[8] = l, this
		},
		identity: function() {
			return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
		},
		clone: function() {
			return (new this.constructor).fromArray(this.elements)
		},
		copy: function(e) {
			var t = this.elements;
			return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], this
		},
		setFromMatrix4: function(e) {
			return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
		},
		applyToBufferAttribute: function() {
			var e = new r;
			return function(t) {
				for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix3(this), t.setXYZ(i, e.x, e.y, e.z);
				return t
			}
		}(),
		multiply: function(e) {
			return this.multiplyMatrices(this, e)
		},
		premultiply: function(e) {
			return this.multiplyMatrices(e, this)
		},
		multiplyMatrices: function(e, t) {
			var i = e.elements,
				n = t.elements;
			t = this.elements, e = i[0];
			var r = i[3],
				o = i[6],
				s = i[1],
				a = i[4],
				l = i[7],
				c = i[2],
				h = i[5];
			i = i[8];
			var u = n[0],
				d = n[3],
				p = n[6],
				f = n[1],
				m = n[4],
				g = n[7],
				v = n[2],
				y = n[5];
			return n = n[8], t[0] = e * u + r * f + o * v, t[3] = e * d + r * m + o * y, t[6] = e * p + r * g + o * n, t[1] = s * u + a * f + l * v, t[4] = s * d + a * m + l * y, t[7] = s * p + a * g + l * n, t[2] = c * u + h * f + i * v, t[5] = c * d + h * m + i * y, t[8] = c * p + h * g + i * n, this
		},
		multiplyScalar: function(e) {
			var t = this.elements;
			return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
		},
		determinant: function() {
			var e = this.elements,
				t = e[0],
				i = e[1],
				n = e[2],
				r = e[3],
				o = e[4],
				s = e[5],
				a = e[6],
				l = e[7];
			return t * o * (e = e[8]) - t * s * l - i * r * e + i * s * a + n * r * l - n * o * a
		},
		getInverse: function(e, t) {
			e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
			var i = e.elements;
			e = this.elements;
			var n = i[0],
				r = i[1],
				o = i[2],
				s = i[3],
				a = i[4],
				l = i[5],
				c = i[6],
				h = i[7],
				u = (i = i[8]) * a - l * h,
				d = l * c - i * s,
				p = h * s - a * c,
				f = n * u + r * d + o * p;
			if (0 === f) {
				if (!0 === t) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
				return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
			}
			return t = 1 / f, e[0] = u * t, e[1] = (o * h - i * r) * t, e[2] = (l * r - o * a) * t, e[3] = d * t, e[4] = (i * n - o * c) * t, e[5] = (o * s - l * n) * t, e[6] = p * t, e[7] = (r * c - h * n) * t, e[8] = (a * n - r * s) * t, this
		},
		transpose: function() {
			var e = this.elements,
				t = e[1];
			return e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
		},
		getNormalMatrix: function(e) {
			return this.setFromMatrix4(e).getInverse(this).transpose()
		},
		transposeIntoArray: function(e) {
			var t = this.elements;
			return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
		},
		setUvTransform: function(e, t, i, n, r, o, s) {
			var a = Math.cos(r);
			r = Math.sin(r), this.set(i * a, i * r, -i * (a * o + r * s) + o + e, -n * r, n * a, -n * (-r * o + a * s) + s + t, 0, 0, 1)
		},
		scale: function(e, t) {
			var i = this.elements;
			return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this
		},
		rotate: function(e) {
			var t = Math.cos(e);
			e = Math.sin(e);
			var i = this.elements,
				n = i[0],
				r = i[3],
				o = i[6],
				s = i[1],
				a = i[4],
				l = i[7];
			return i[0] = t * n + e * s, i[3] = t * r + e * a, i[6] = t * o + e * l, i[1] = -e * n + t * s, i[4] = -e * r + t * a, i[7] = -e * o + t * l, this
		},
		translate: function(e, t) {
			var i = this.elements;
			return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this
		},
		equals: function(e) {
			var t = this.elements;
			e = e.elements;
			for (var i = 0; 9 > i; i++)
				if (t[i] !== e[i]) return !1;
			return !0
		},
		fromArray: function(e, t) {
			void 0 === t && (t = 0);
			for (var i = 0; 9 > i; i++) this.elements[i] = e[i + t];
			return this
		},
		toArray: function(e, t) {
			void 0 === e && (e = []), void 0 === t && (t = 0);
			var i = this.elements;
			return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
		}
	});
	var po, fo = {
			getDataURL: function(e) {
				if ("undefined" == typeof HTMLCanvasElement) return e.src;
				if (!(e instanceof HTMLCanvasElement)) {
					void 0 === po && (po = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), po.width = e.width, po.height = e.height;
					var t = po.getContext("2d");
					e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height), e = po
				}
				return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
			}
		},
		mo = 0;
	s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, s.prototype = Object.assign(Object.create(t.prototype), {
		constructor: s,
		isTexture: !0,
		updateMatrix: function() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
		},
		toJSON: function(e) {
			var t = void 0 === e || "string" == typeof e;
			if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
			var i = {
				metadata: {
					version: 4.5,
					type: "Texture",
					generator: "Texture.toJSON"
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};
			if (void 0 !== this.image) {
				var n = this.image;
				if (void 0 === n.uuid && (n.uuid = uo.generateUUID()), !t && void 0 === e.images[n.uuid]) {
					if (Array.isArray(n))
						for (var r = [], o = 0, s = n.length; o < s; o++) r.push(fo.getDataURL(n[o]));
					else r = fo.getDataURL(n);
					e.images[n.uuid] = {
						uuid: n.uuid,
						url: r
					}
				}
				i.image = n.uuid
			}
			return t || (e.textures[this.uuid] = i), i
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		},
		transformUv: function(e) {
			if (300 !== this.mapping) return e;
			if (e.applyMatrix3(this.matrix), 0 > e.x || 1 < e.x) switch (this.wrapS) {
				case 1e3:
					e.x -= Math.floor(e.x);
					break;
				case 1001:
					e.x = 0 > e.x ? 0 : 1;
					break;
				case 1002:
					e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x)
			}
			if (0 > e.y || 1 < e.y) switch (this.wrapT) {
				case 1e3:
					e.y -= Math.floor(e.y);
					break;
				case 1001:
					e.y = 0 > e.y ? 0 : 1;
					break;
				case 1002:
					e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y)
			}
			return this.flipY && (e.y = 1 - e.y), e
		}
	}), Object.defineProperty(s.prototype, "needsUpdate", {
		set: function(e) {
			!0 === e && this.version++
		}
	}), Object.assign(a.prototype, {
		isVector4: !0,
		set: function(e, t, i, n) {
			return this.x = e, this.y = t, this.z = i, this.w = n, this
		},
		setScalar: function(e) {
			return this.w = this.z = this.y = this.x = e, this
		},
		setX: function(e) {
			return this.x = e, this
		},
		setY: function(e) {
			return this.y = e, this
		},
		setZ: function(e) {
			return this.z = e, this
		},
		setW: function(e) {
			return this.w = e, this
		},
		setComponent: function(e, t) {
			switch (e) {
				case 0:
					this.x = t;
					break;
				case 1:
					this.y = t;
					break;
				case 2:
					this.z = t;
					break;
				case 3:
					this.w = t;
					break;
				default:
					throw Error("index is out of range: " + e)
			}
			return this
		},
		getComponent: function(e) {
			switch (e) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw Error("index is out of range: " + e)
			}
		},
		clone: function() {
			return new this.constructor(this.x, this.y, this.z, this.w)
		},
		copy: function(e) {
			return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
		},
		add: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
		},
		addScalar: function(e) {
			return this.x += e, this.y += e, this.z += e, this.w += e, this
		},
		addVectors: function(e, t) {
			return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
		},
		addScaledVector: function(e, t) {
			return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
		},
		sub: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
		},
		subScalar: function(e) {
			return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
		},
		subVectors: function(e, t) {
			return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
		},
		multiplyScalar: function(e) {
			return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
		},
		applyMatrix4: function(e) {
			var t = this.x,
				i = this.y,
				n = this.z,
				r = this.w;
			return e = e.elements, this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r, this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r, this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r, this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r, this
		},
		divideScalar: function(e) {
			return this.multiplyScalar(1 / e)
		},
		setAxisAngleFromQuaternion: function(e) {
			this.w = 2 * Math.acos(e.w);
			var t = Math.sqrt(1 - e.w * e.w);
			return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
		},
		setAxisAngleFromRotationMatrix: function(e) {
			var t = (e = e.elements)[0],
				i = e[4],
				n = e[8],
				r = e[1],
				o = e[5],
				s = e[9],
				a = e[2],
				l = e[6],
				c = e[10];
			return .01 > Math.abs(i - r) && .01 > Math.abs(n - a) && .01 > Math.abs(s - l) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + a) && .1 > Math.abs(s + l) && .1 > Math.abs(t + o + c - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, c = (c + 1) / 2, i = (i + r) / 4, n = (n + a) / 4, s = (s + l) / 4, (t = (t + 1) / 2) > (o = (o + 1) / 2) && t > c ? .01 > t ? (l = 0, i = a = .707106781) : (a = i / (l = Math.sqrt(t)), i = n / l) : o > c ? .01 > o ? (l = .707106781, a = 0, i = .707106781) : (l = i / (a = Math.sqrt(o)), i = s / a) : .01 > c ? (a = l = .707106781, i = 0) : (l = n / (i = Math.sqrt(c)), a = s / i), this.set(l, a, i, e), this) : (e = Math.sqrt((l - s) * (l - s) + (n - a) * (n - a) + (r - i) * (r - i)), .001 > Math.abs(e) && (e = 1), this.x = (l - s) / e, this.y = (n - a) / e, this.z = (r - i) / e, this.w = Math.acos((t + o + c - 1) / 2), this)
		},
		min: function(e) {
			return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
		},
		max: function(e) {
			return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
		},
		clamp: function(e, t) {
			return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
		},
		clampScalar: function() {
			var e, t;
			return function(i, n) {
				return void 0 === e && (e = new a, t = new a), e.set(i, i, i, i), t.set(n, n, n, n), this.clamp(e, t)
			}
		}(),
		clampLength: function(e, t) {
			var i = this.length();
			return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
		},
		floor: function() {
			return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
		},
		ceil: function() {
			return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
		},
		round: function() {
			return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
		},
		roundToZero: function() {
			return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
		},
		negate: function() {
			return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
		},
		dot: function(e) {
			return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		},
		manhattanLength: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
		},
		normalize: function() {
			return this.divideScalar(this.length() || 1)
		},
		setLength: function(e) {
			return this.normalize().multiplyScalar(e)
		},
		lerp: function(e, t) {
			return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
		},
		lerpVectors: function(e, t, i) {
			return this.subVectors(t, e).multiplyScalar(i).add(e)
		},
		equals: function(e) {
			return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
		},
		fromArray: function(e, t) {
			return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
		},
		toArray: function(e, t) {
			return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
		},
		fromBufferAttribute: function(e, t, i) {
			return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
		}
	}), l.prototype = Object.assign(Object.create(t.prototype), {
		constructor: l,
		isWebGLRenderTarget: !0,
		setSize: function(e, t) {
			this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}), c.prototype = Object.assign(Object.create(l.prototype), {
		constructor: c,
		isWebGLMultisampleRenderTarget: !0,
		copy: function(e) {
			return l.prototype.copy.call(this, e), this.samples = e.samples, this
		}
	}), h.prototype = Object.create(l.prototype), h.prototype.constructor = h, h.prototype.isWebGLRenderTargetCube = !0, u.prototype = Object.create(s.prototype), u.prototype.constructor = u, u.prototype.isDataTexture = !0, Object.assign(d.prototype, {
		isBox3: !0,
		set: function(e, t) {
			return this.min.copy(e), this.max.copy(t), this
		},
		setFromArray: function(e) {
			for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0, a = 0, l = e.length; a < l; a += 3) {
				var c = e[a],
					h = e[a + 1],
					u = e[a + 2];
				c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > s && (s = u)
			}
			return this.min.set(t, i, n), this.max.set(r, o, s), this
		},
		setFromBufferAttribute: function(e) {
			for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, s = -1 / 0, a = 0, l = e.count; a < l; a++) {
				var c = e.getX(a),
					h = e.getY(a),
					u = e.getZ(a);
				c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > o && (o = h), u > s && (s = u)
			}
			return this.min.set(t, i, n), this.max.set(r, o, s), this
		},
		setFromPoints: function(e) {
			this.makeEmpty();
			for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
			return this
		},
		setFromCenterAndSize: function() {
			var e = new r;
			return function(t, i) {
				return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
			}
		}(),
		setFromObject: function(e) {
			return this.makeEmpty(), this.expandByObject(e)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this
		},
		makeEmpty: function() {
			return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
		},
		isEmpty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
		},
		getCenter: function(e) {
			return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
		},
		getSize: function(e) {
			return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new r), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
		},
		expandByPoint: function(e) {
			return this.min.min(e), this.max.max(e), this
		},
		expandByVector: function(e) {
			return this.min.sub(e), this.max.add(e), this
		},
		expandByScalar: function(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this
		},
		expandByObject: function() {
			function e(e) {
				var r = e.geometry;
				if (void 0 !== r)
					if (r.isGeometry)
						for (r = r.vertices, i = 0, n = r.length; i < n; i++) o.copy(r[i]), o.applyMatrix4(e.matrixWorld), t.expandByPoint(o);
					else if (r.isBufferGeometry && void 0 !== (r = r.attributes.position))
					for (i = 0, n = r.count; i < n; i++) o.fromBufferAttribute(r, i).applyMatrix4(e.matrixWorld), t.expandByPoint(o)
			}
			var t, i, n, o = new r;
			return function(i) {
				return t = this, i.updateMatrixWorld(!0), i.traverse(e), this
			}
		}(),
		containsPoint: function(e) {
			return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
		},
		containsBox: function(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
		},
		getParameter: function(e, t) {
			return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new r), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
		},
		intersectsBox: function(e) {
			return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
		},
		intersectsSphere: function() {
			var e = new r;
			return function(t) {
				return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
			}
		}(),
		intersectsPlane: function(e) {
			if (0 < e.normal.x) var t = e.normal.x * this.min.x,
				i = e.normal.x * this.max.x;
			else t = e.normal.x * this.max.x, i = e.normal.x * this.min.x;
			return 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
		},
		intersectsTriangle: function() {
			function e(e) {
				var r, o = 0;
				for (r = e.length - 3; o <= r; o += 3) {
					l.fromArray(e, o);
					var s = h.x * Math.abs(l.x) + h.y * Math.abs(l.y) + h.z * Math.abs(l.z),
						a = t.dot(l),
						c = i.dot(l),
						u = n.dot(l);
					if (Math.max(-Math.max(a, c, u), Math.min(a, c, u)) > s) return !1
				}
				return !0
			}
			var t = new r,
				i = new r,
				n = new r,
				o = new r,
				s = new r,
				a = new r,
				l = new r,
				c = new r,
				h = new r,
				u = new r;
			return function(r) {
				return !this.isEmpty() && (this.getCenter(c), h.subVectors(this.max, c), t.subVectors(r.a, c), i.subVectors(r.b, c), n.subVectors(r.c, c), o.subVectors(i, t), s.subVectors(n, i), a.subVectors(t, n), !!e(r = [0, -o.z, o.y, 0, -s.z, s.y, 0, -a.z, a.y, o.z, 0, -o.x, s.z, 0, -s.x, a.z, 0, -a.x, -o.y, o.x, 0, -s.y, s.x, 0, -a.y, a.x, 0]) && !!e(r = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(o, s), e(r = [u.x, u.y, u.z])))
			}
		}(),
		clampPoint: function(e, t) {
			return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new r), t.copy(e).clamp(this.min, this.max)
		},
		distanceToPoint: function() {
			var e = new r;
			return function(t) {
				return e.copy(t).clamp(this.min, this.max).sub(t).length()
			}
		}(),
		getBoundingSphere: function() {
			var e = new r;
			return function(t) {
				return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
			}
		}(),
		intersect: function(e) {
			return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
		},
		union: function(e) {
			return this.min.min(e.min), this.max.max(e.max), this
		},
		applyMatrix4: function() {
			var e = [new r, new r, new r, new r, new r, new r, new r, new r];
			return function(t) {
				return this.isEmpty() || (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e)), this
			}
		}(),
		translate: function(e) {
			return this.min.add(e), this.max.add(e), this
		},
		equals: function(e) {
			return e.min.equals(this.min) && e.max.equals(this.max)
		}
	}), Object.assign(p.prototype, {
		set: function(e, t) {
			return this.center.copy(e), this.radius = t, this
		},
		setFromPoints: function() {
			var e = new d;
			return function(t, i) {
				var n = this.center;
				void 0 !== i ? n.copy(i) : e.setFromPoints(t).getCenter(n);
				for (var r = i = 0, o = t.length; r < o; r++) i = Math.max(i, n.distanceToSquared(t[r]));
				return this.radius = Math.sqrt(i), this
			}
		}(),
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.center.copy(e.center), this.radius = e.radius, this
		},
		empty: function() {
			return 0 >= this.radius
		},
		containsPoint: function(e) {
			return e.distanceToSquared(this.center) <= this.radius * this.radius
		},
		distanceToPoint: function(e) {
			return e.distanceTo(this.center) - this.radius
		},
		intersectsSphere: function(e) {
			var t = this.radius + e.radius;
			return e.center.distanceToSquared(this.center) <= t * t
		},
		intersectsBox: function(e) {
			return e.intersectsSphere(this)
		},
		intersectsPlane: function(e) {
			return Math.abs(e.distanceToPoint(this.center)) <= this.radius
		},
		clampPoint: function(e, t) {
			var i = this.center.distanceToSquared(e);
			return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new r), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
		},
		getBoundingBox: function(e) {
			return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new d), e.set(this.center, this.center), e.expandByScalar(this.radius), e
		},
		applyMatrix4: function(e) {
			return this.center.applyMatrix4(e), this.radius *= e.getMaxScaleOnAxis(), this
		},
		translate: function(e) {
			return this.center.add(e), this
		},
		equals: function(e) {
			return e.center.equals(this.center) && e.radius === this.radius
		}
	}), Object.assign(f.prototype, {
		set: function(e, t) {
			return this.normal.copy(e), this.constant = t, this
		},
		setComponents: function(e, t, i, n) {
			return this.normal.set(e, t, i), this.constant = n, this
		},
		setFromNormalAndCoplanarPoint: function(e, t) {
			return this.normal.copy(e), this.constant = -t.dot(this.normal), this
		},
		setFromCoplanarPoints: function() {
			var e = new r,
				t = new r;
			return function(i, n, r) {
				return n = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
			}
		}(),
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.normal.copy(e.normal), this.constant = e.constant, this
		},
		normalize: function() {
			var e = 1 / this.normal.length();
			return this.normal.multiplyScalar(e), this.constant *= e, this
		},
		negate: function() {
			return this.constant *= -1, this.normal.negate(), this
		},
		distanceToPoint: function(e) {
			return this.normal.dot(e) + this.constant
		},
		distanceToSphere: function(e) {
			return this.distanceToPoint(e.center) - e.radius
		},
		projectPoint: function(e, t) {
			return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new r), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
		},
		intersectLine: function() {
			var e = new r;
			return function(t, i) {
				void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new r);
				var n = t.delta(e),
					o = this.normal.dot(n);
				if (0 === o) {
					if (0 === this.distanceToPoint(t.start)) return i.copy(t.start)
				} else if (!(0 > (o = -(t.start.dot(this.normal) + this.constant) / o) || 1 < o)) return i.copy(n).multiplyScalar(o).add(t.start)
			}
		}(),
		intersectsLine: function(e) {
			var t = this.distanceToPoint(e.start);
			return e = this.distanceToPoint(e.end), 0 > t && 0 < e || 0 > e && 0 < t
		},
		intersectsBox: function(e) {
			return e.intersectsPlane(this)
		},
		intersectsSphere: function(e) {
			return e.intersectsPlane(this)
		},
		coplanarPoint: function(e) {
			return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new r), e.copy(this.normal).multiplyScalar(-this.constant)
		},
		applyMatrix4: function() {
			var e = new r,
				t = new o;
			return function(i, n) {
				return n = n || t.getNormalMatrix(i), i = this.coplanarPoint(e).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this
			}
		}(),
		translate: function(e) {
			return this.constant -= e.dot(this.normal), this
		},
		equals: function(e) {
			return e.normal.equals(this.normal) && e.constant === this.constant
		}
	}), Object.assign(m.prototype, {
		set: function(e, t, i, n, r, o) {
			var s = this.planes;
			return s[0].copy(e), s[1].copy(t), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(o), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
			return this
		},
		setFromMatrix: function(e) {
			var t = this.planes,
				i = e.elements;
			e = i[0];
			var n = i[1],
				r = i[2],
				o = i[3],
				s = i[4],
				a = i[5],
				l = i[6],
				c = i[7],
				h = i[8],
				u = i[9],
				d = i[10],
				p = i[11],
				f = i[12],
				m = i[13],
				g = i[14];
			return i = i[15], t[0].setComponents(o - e, c - s, p - h, i - f).normalize(), t[1].setComponents(o + e, c + s, p + h, i + f).normalize(), t[2].setComponents(o + n, c + a, p + u, i + m).normalize(), t[3].setComponents(o - n, c - a, p - u, i - m).normalize(), t[4].setComponents(o - r, c - l, p - d, i - g).normalize(), t[5].setComponents(o + r, c + l, p + d, i + g).normalize(), this
		},
		intersectsObject: function() {
			var e = new p;
			return function(t) {
				var i = t.geometry;
				return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
			}
		}(),
		intersectsSprite: function() {
			var e = new p;
			return function(t) {
				return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
			}
		}(),
		intersectsSphere: function(e) {
			var t = this.planes,
				i = e.center;
			e = -e.radius;
			for (var n = 0; 6 > n; n++)
				if (t[n].distanceToPoint(i) < e) return !1;
			return !0
		},
		intersectsBox: function() {
			var e = new r;
			return function(t) {
				for (var i = this.planes, n = 0; 6 > n; n++) {
					var r = i[n];
					if (e.x = 0 < r.normal.x ? t.max.x : t.min.x, e.y = 0 < r.normal.y ? t.max.y : t.min.y, e.z = 0 < r.normal.z ? t.max.z : t.min.z, 0 > r.distanceToPoint(e)) return !1
				}
				return !0
			}
		}(),
		containsPoint: function(e) {
			for (var t = this.planes, i = 0; 6 > i; i++)
				if (0 > t[i].distanceToPoint(e)) return !1;
			return !0
		}
	}), Object.assign(g.prototype, {
		isMatrix4: !0,
		set: function(e, t, i, n, r, o, s, a, l, c, h, u, d, p, f, m) {
			var g = this.elements;
			return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = s, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
		},
		identity: function() {
			return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
		},
		clone: function() {
			return (new g).fromArray(this.elements)
		},
		copy: function(e) {
			var t = this.elements;
			return e = e.elements, t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], this
		},
		copyPosition: function(e) {
			var t = this.elements;
			return e = e.elements, t[12] = e[12], t[13] = e[13], t[14] = e[14], this
		},
		extractBasis: function(e, t, i) {
			return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
		},
		makeBasis: function(e, t, i) {
			return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
		},
		extractRotation: function() {
			var e = new r;
			return function(t) {
				var i = this.elements,
					n = t.elements,
					r = 1 / e.setFromMatrixColumn(t, 0).length(),
					o = 1 / e.setFromMatrixColumn(t, 1).length();
				return t = 1 / e.setFromMatrixColumn(t, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * t, i[9] = n[9] * t, i[10] = n[10] * t, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
			}
		}(),
		makeRotationFromEuler: function(e) {
			e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
			var t = this.elements,
				i = e.x,
				n = e.y,
				r = e.z,
				o = Math.cos(i);
			i = Math.sin(i);
			var s = Math.cos(n);
			n = Math.sin(n);
			var a = Math.cos(r);
			if (r = Math.sin(r), "XYZ" === e.order) {
				e = o * a;
				var l = o * r,
					c = i * a,
					h = i * r;
				t[0] = s * a, t[4] = -s * r, t[8] = n, t[1] = l + c * n, t[5] = e - h * n, t[9] = -i * s, t[2] = h - e * n, t[6] = c + l * n, t[10] = o * s
			} else "YXZ" === e.order ? (e = s * a, l = s * r, c = n * a, h = n * r, t[0] = e + h * i, t[4] = c * i - l, t[8] = o * n, t[1] = o * r, t[5] = o * a, t[9] = -i, t[2] = l * i - c, t[6] = h + e * i, t[10] = o * s) : "ZXY" === e.order ? (e = s * a, l = s * r, c = n * a, h = n * r, t[0] = e - h * i, t[4] = -o * r, t[8] = c + l * i, t[1] = l + c * i, t[5] = o * a, t[9] = h - e * i, t[2] = -o * n, t[6] = i, t[10] = o * s) : "ZYX" === e.order ? (e = o * a, l = o * r, c = i * a, h = i * r, t[0] = s * a, t[4] = c * n - l, t[8] = e * n + h, t[1] = s * r, t[5] = h * n + e, t[9] = l * n - c, t[2] = -n, t[6] = i * s, t[10] = o * s) : "YZX" === e.order ? (e = o * s, l = o * n, c = i * s, h = i * n, t[0] = s * a, t[4] = h - e * r, t[8] = c * r + l, t[1] = r, t[5] = o * a, t[9] = -i * a, t[2] = -n * a, t[6] = l * r + c, t[10] = e - h * r) : "XZY" === e.order && (e = o * s, l = o * n, c = i * s, h = i * n, t[0] = s * a, t[4] = -r, t[8] = n * a, t[1] = e * r + h, t[5] = o * a, t[9] = l * r - c, t[2] = c * r - l, t[6] = i * a, t[10] = h * r + e);
			return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
		},
		makeRotationFromQuaternion: function() {
			var e = new r(0, 0, 0),
				t = new r(1, 1, 1);
			return function(i) {
				return this.compose(e, i, t)
			}
		}(),
		lookAt: function() {
			var e = new r,
				t = new r,
				i = new r;
			return function(n, r, o) {
				var s = this.elements;
				return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), e.crossVectors(o, i), 0 === e.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), e.crossVectors(o, i)), e.normalize(), t.crossVectors(i, e), s[0] = e.x, s[4] = t.x, s[8] = i.x, s[1] = e.y, s[5] = t.y, s[9] = i.y, s[2] = e.z, s[6] = t.z, s[10] = i.z, this
			}
		}(),
		multiply: function(e, t) {
			return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
		},
		premultiply: function(e) {
			return this.multiplyMatrices(e, this)
		},
		multiplyMatrices: function(e, t) {
			var i = e.elements,
				n = t.elements;
			t = this.elements, e = i[0];
			var r = i[4],
				o = i[8],
				s = i[12],
				a = i[1],
				l = i[5],
				c = i[9],
				h = i[13],
				u = i[2],
				d = i[6],
				p = i[10],
				f = i[14],
				m = i[3],
				g = i[7],
				v = i[11];
			i = i[15];
			var y = n[0],
				b = n[4],
				w = n[8],
				x = n[12],
				_ = n[1],
				E = n[5],
				M = n[9],
				S = n[13],
				T = n[2],
				A = n[6],
				L = n[10],
				C = n[14],
				P = n[3],
				I = n[7],
				R = n[11];
			return n = n[15], t[0] = e * y + r * _ + o * T + s * P, t[4] = e * b + r * E + o * A + s * I, t[8] = e * w + r * M + o * L + s * R, t[12] = e * x + r * S + o * C + s * n, t[1] = a * y + l * _ + c * T + h * P, t[5] = a * b + l * E + c * A + h * I, t[9] = a * w + l * M + c * L + h * R, t[13] = a * x + l * S + c * C + h * n, t[2] = u * y + d * _ + p * T + f * P, t[6] = u * b + d * E + p * A + f * I, t[10] = u * w + d * M + p * L + f * R, t[14] = u * x + d * S + p * C + f * n, t[3] = m * y + g * _ + v * T + i * P, t[7] = m * b + g * E + v * A + i * I, t[11] = m * w + g * M + v * L + i * R, t[15] = m * x + g * S + v * C + i * n, this
		},
		multiplyScalar: function(e) {
			var t = this.elements;
			return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
		},
		applyToBufferAttribute: function() {
			var e = new r;
			return function(t) {
				for (var i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix4(this), t.setXYZ(i, e.x, e.y, e.z);
				return t
			}
		}(),
		determinant: function() {
			var e = this.elements,
				t = e[0],
				i = e[4],
				n = e[8],
				r = e[12],
				o = e[1],
				s = e[5],
				a = e[9],
				l = e[13],
				c = e[2],
				h = e[6],
				u = e[10],
				d = e[14];
			return e[3] * (+r * a * h - n * l * h - r * s * u + i * l * u + n * s * d - i * a * d) + e[7] * (+t * a * d - t * l * u + r * o * u - n * o * d + n * l * c - r * a * c) + e[11] * (+t * l * h - t * s * d - r * o * h + i * o * d + r * s * c - i * l * c) + e[15] * (-n * s * c - t * a * h + t * s * u + n * o * h - i * o * u + i * a * c)
		},
		transpose: function() {
			var e = this.elements,
				t = e[1];
			return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
		},
		setPosition: function(e, t, i) {
			var n = this.elements;
			return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this
		},
		getInverse: function(e, t) {
			var i = this.elements,
				n = e.elements;
			e = n[0];
			var r = n[1],
				o = n[2],
				s = n[3],
				a = n[4],
				l = n[5],
				c = n[6],
				h = n[7],
				u = n[8],
				d = n[9],
				p = n[10],
				f = n[11],
				m = n[12],
				g = n[13],
				v = n[14],
				y = d * v * h - g * p * h + g * c * f - l * v * f - d * c * (n = n[15]) + l * p * n,
				b = m * p * h - u * v * h - m * c * f + a * v * f + u * c * n - a * p * n,
				w = u * g * h - m * d * h + m * l * f - a * g * f - u * l * n + a * d * n,
				x = m * d * c - u * g * c - m * l * p + a * g * p + u * l * v - a * d * v,
				_ = e * y + r * b + o * w + s * x;
			if (0 === _) {
				if (!0 === t) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
				return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
			}
			return t = 1 / _, i[0] = y * t, i[1] = (g * p * s - d * v * s - g * o * f + r * v * f + d * o * n - r * p * n) * t, i[2] = (l * v * s - g * c * s + g * o * h - r * v * h - l * o * n + r * c * n) * t, i[3] = (d * c * s - l * p * s - d * o * h + r * p * h + l * o * f - r * c * f) * t, i[4] = b * t, i[5] = (u * v * s - m * p * s + m * o * f - e * v * f - u * o * n + e * p * n) * t, i[6] = (m * c * s - a * v * s - m * o * h + e * v * h + a * o * n - e * c * n) * t, i[7] = (a * p * s - u * c * s + u * o * h - e * p * h - a * o * f + e * c * f) * t, i[8] = w * t, i[9] = (m * d * s - u * g * s - m * r * f + e * g * f + u * r * n - e * d * n) * t, i[10] = (a * g * s - m * l * s + m * r * h - e * g * h - a * r * n + e * l * n) * t, i[11] = (u * l * s - a * d * s - u * r * h + e * d * h + a * r * f - e * l * f) * t, i[12] = x * t, i[13] = (u * g * o - m * d * o + m * r * p - e * g * p - u * r * v + e * d * v) * t, i[14] = (m * l * o - a * g * o - m * r * c + e * g * c + a * r * v - e * l * v) * t, i[15] = (a * d * o - u * l * o + u * r * c - e * d * c - a * r * p + e * l * p) * t, this
		},
		scale: function(e) {
			var t = this.elements,
				i = e.x,
				n = e.y;
			return e = e.z, t[0] *= i, t[4] *= n, t[8] *= e, t[1] *= i, t[5] *= n, t[9] *= e, t[2] *= i, t[6] *= n, t[10] *= e, t[3] *= i, t[7] *= n, t[11] *= e, this
		},
		getMaxScaleOnAxis: function() {
			var e = this.elements;
			return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
		},
		makeTranslation: function(e, t, i) {
			return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
		},
		makeRotationX: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this
		},
		makeRotationY: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this
		},
		makeRotationZ: function(e) {
			var t = Math.cos(e);
			return e = Math.sin(e), this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
		},
		makeRotationAxis: function(e, t) {
			var i = Math.cos(t);
			t = Math.sin(t);
			var n = 1 - i,
				r = e.x,
				o = e.y;
			e = e.z;
			var s = n * r,
				a = n * o;
			return this.set(s * r + i, s * o - t * e, s * e + t * o, 0, s * o + t * e, a * o + i, a * e - t * r, 0, s * e - t * o, a * e + t * r, n * e * e + i, 0, 0, 0, 0, 1), this
		},
		makeScale: function(e, t, i) {
			return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
		},
		makeShear: function(e, t, i) {
			return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this
		},
		compose: function(e, t, i) {
			var n = this.elements,
				r = t._x,
				o = t._y,
				s = t._z,
				a = t._w,
				l = r + r,
				c = o + o,
				h = s + s;
			t = r * l;
			var u = r * c;
			r *= h;
			var d = o * c;
			o *= h, s *= h, l *= a, c *= a, a *= h, h = i.x;
			var p = i.y;
			return i = i.z, n[0] = (1 - (d + s)) * h, n[1] = (u + a) * h, n[2] = (r - c) * h, n[3] = 0, n[4] = (u - a) * p, n[5] = (1 - (t + s)) * p, n[6] = (o + l) * p, n[7] = 0, n[8] = (r + c) * i, n[9] = (o - l) * i, n[10] = (1 - (t + d)) * i, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
		},
		decompose: function() {
			var e = new r,
				t = new g;
			return function(i, n, r) {
				var o = this.elements,
					s = e.set(o[0], o[1], o[2]).length(),
					a = e.set(o[4], o[5], o[6]).length(),
					l = e.set(o[8], o[9], o[10]).length();
				0 > this.determinant() && (s = -s), i.x = o[12], i.y = o[13], i.z = o[14], t.copy(this), i = 1 / s, o = 1 / a;
				var c = 1 / l;
				return t.elements[0] *= i, t.elements[1] *= i, t.elements[2] *= i, t.elements[4] *= o, t.elements[5] *= o, t.elements[6] *= o, t.elements[8] *= c, t.elements[9] *= c, t.elements[10] *= c, n.setFromRotationMatrix(t), r.x = s, r.y = a, r.z = l, this
			}
		}(),
		makePerspective: function(e, t, i, n, r, o) {
			void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
			var s = this.elements;
			return s[0] = 2 * r / (t - e), s[4] = 0, s[8] = (t + e) / (t - e), s[12] = 0, s[1] = 0, s[5] = 2 * r / (i - n), s[9] = (i + n) / (i - n), s[13] = 0, s[2] = 0, s[6] = 0, s[10] = -(o + r) / (o - r), s[14] = -2 * o * r / (o - r), s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this
		},
		makeOrthographic: function(e, t, i, n, r, o) {
			var s = this.elements,
				a = 1 / (t - e),
				l = 1 / (i - n),
				c = 1 / (o - r);
			return s[0] = 2 * a, s[4] = 0, s[8] = 0, s[12] = -(t + e) * a, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -(i + n) * l, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -(o + r) * c, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this
		},
		equals: function(e) {
			var t = this.elements;
			e = e.elements;
			for (var i = 0; 16 > i; i++)
				if (t[i] !== e[i]) return !1;
			return !0
		},
		fromArray: function(e, t) {
			void 0 === t && (t = 0);
			for (var i = 0; 16 > i; i++) this.elements[i] = e[i + t];
			return this
		},
		toArray: function(e, t) {
			void 0 === e && (e = []), void 0 === t && (t = 0);
			var i = this.elements;
			return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
		}
	});
	var go = {
			alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
			alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
			alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
			aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
			aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
			begin_vertex: "vec3 transformed = vec3( position );",
			beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
			bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
			bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
			clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
			clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
			clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
			clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
			color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
			color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
			color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
			color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
			common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
			cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
			defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
			displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
			displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
			emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
			emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
			encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
			encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
			envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
			envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
			envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
			envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
			envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
			fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
			fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
			fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
			fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
			gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
			lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
			lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
			lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
			lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
			lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
			lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
			lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
			lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
			lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
			lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
			lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
			logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
			logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
			logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
			logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
			map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
			map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
			map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
			map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
			metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
			metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
			morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
			morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
			morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
			normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
			normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
			normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
			packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
			premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
			project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
			dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
			dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
			roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
			roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
			shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
			shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
			shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
			shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
			skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
			skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
			skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
			skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
			specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
			specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
			tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
			tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
			uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
			uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
			uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
			uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
			uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
			uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
			worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
			background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
			background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
			cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
			cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
			depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
			depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
			distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
			distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
			equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
			equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
			linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
			meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
			meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
			meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
			meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
			meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
			meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
			normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
			points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
			shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
			shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
		},
		vo = {
			clone: v,
			merge: y
		},
		yo = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		};
	Object.assign(b.prototype, {
		isColor: !0,
		r: 1,
		g: 1,
		b: 1,
		set: function(e) {
			return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
		},
		setScalar: function(e) {
			return this.b = this.g = this.r = e, this
		},
		setHex: function(e) {
			return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
		},
		setRGB: function(e, t, i) {
			return this.r = e, this.g = t, this.b = i, this
		},
		setHSL: function() {
			function e(e, t, i) {
				return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? e + 6 * (t - e) * i : .5 > i ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
			}
			return function(t, i, n) {
				return t = uo.euclideanModulo(t, 1), i = uo.clamp(i, 0, 1), n = uo.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (n = 2 * n - (i = .5 >= n ? n * (1 + i) : n + i - n * i), this.r = e(n, i, t + 1 / 3), this.g = e(n, i, t), this.b = e(n, i, t - 1 / 3)), this
			}
		}(),
		setStyle: function(e) {
			function t(t) {
				void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
			}
			var i;
			if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
				var n = i[2];
				switch (i[1]) {
					case "rgb":
					case "rgba":
						if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
						if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
						break;
					case "hsl":
					case "hsla":
						if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
							n = parseFloat(i[1]) / 360;
							var r = parseInt(i[2], 10) / 100,
								o = parseInt(i[3], 10) / 100;
							return t(i[5]), this.setHSL(n, r, o)
						}
				}
			} else if (i = /^#([A-Fa-f0-9]+)$/.exec(e)) {
				if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
				if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
			}
			return e && 0 < e.length && (void 0 !== (i = yo[e]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + e)), this
		},
		clone: function() {
			return new this.constructor(this.r, this.g, this.b)
		},
		copy: function(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this
		},
		copyGammaToLinear: function(e, t) {
			return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
		},
		copyLinearToGamma: function(e, t) {
			return void 0 === t && (t = 2), t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
		},
		convertGammaToLinear: function(e) {
			return this.copyGammaToLinear(this, e), this
		},
		convertLinearToGamma: function(e) {
			return this.copyLinearToGamma(this, e), this
		},
		copySRGBToLinear: function() {
			function e(e) {
				return .04045 > e ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
			}
			return function(t) {
				return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
			}
		}(),
		copyLinearToSRGB: function() {
			function e(e) {
				return .0031308 > e ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
			}
			return function(t) {
				return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
			}
		}(),
		convertSRGBToLinear: function() {
			return this.copySRGBToLinear(this), this
		},
		convertLinearToSRGB: function() {
			return this.copyLinearToSRGB(this), this
		},
		getHex: function() {
			return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
		},
		getHexString: function() {
			return ("000000" + this.getHex().toString(16)).slice(-6)
		},
		getHSL: function(e) {
			void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
				h: 0,
				s: 0,
				l: 0
			});
			var t, i = this.r,
				n = this.g,
				r = this.b,
				o = Math.max(i, n, r),
				s = Math.min(i, n, r),
				a = (s + o) / 2;
			if (s === o) s = t = 0;
			else {
				var l = o - s;
				switch (s = .5 >= a ? l / (o + s) : l / (2 - o - s), o) {
					case i:
						t = (n - r) / l + (n < r ? 6 : 0);
						break;
					case n:
						t = (r - i) / l + 2;
						break;
					case r:
						t = (i - n) / l + 4
				}
				t /= 6
			}
			return e.h = t, e.s = s, e.l = a, e
		},
		getStyle: function() {
			return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
		},
		offsetHSL: function() {
			var e = {};
			return function(t, i, n) {
				return this.getHSL(e), e.h += t, e.s += i, e.l += n, this.setHSL(e.h, e.s, e.l), this
			}
		}(),
		add: function(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this
		},
		addColors: function(e, t) {
			return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
		},
		addScalar: function(e) {
			return this.r += e, this.g += e, this.b += e, this
		},
		sub: function(e) {
			return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
		},
		multiply: function(e) {
			return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
		},
		multiplyScalar: function(e) {
			return this.r *= e, this.g *= e, this.b *= e, this
		},
		lerp: function(e, t) {
			return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
		},
		lerpHSL: function() {
			var e = {
					h: 0,
					s: 0,
					l: 0
				},
				t = {
					h: 0,
					s: 0,
					l: 0
				};
			return function(i, n) {
				this.getHSL(e), i.getHSL(t), i = uo.lerp(e.h, t.h, n);
				var r = uo.lerp(e.s, t.s, n);
				return n = uo.lerp(e.l, t.l, n), this.setHSL(i, r, n), this
			}
		}(),
		equals: function(e) {
			return e.r === this.r && e.g === this.g && e.b === this.b
		},
		fromArray: function(e, t) {
			return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
		},
		toArray: function(e, t) {
			return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
		},
		toJSON: function() {
			return this.getHex()
		}
	});
	var bo = {
			common: {
				diffuse: {
					value: new b(15658734)
				},
				opacity: {
					value: 1
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new o
				},
				alphaMap: {
					value: null
				}
			},
			specularmap: {
				specularMap: {
					value: null
				}
			},
			envmap: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				reflectivity: {
					value: 1
				},
				refractionRatio: {
					value: .98
				},
				maxMipLevel: {
					value: 0
				}
			},
			aomap: {
				aoMap: {
					value: null
				},
				aoMapIntensity: {
					value: 1
				}
			},
			lightmap: {
				lightMap: {
					value: null
				},
				lightMapIntensity: {
					value: 1
				}
			},
			emissivemap: {
				emissiveMap: {
					value: null
				}
			},
			bumpmap: {
				bumpMap: {
					value: null
				},
				bumpScale: {
					value: 1
				}
			},
			normalmap: {
				normalMap: {
					value: null
				},
				normalScale: {
					value: new i(1, 1)
				}
			},
			displacementmap: {
				displacementMap: {
					value: null
				},
				displacementScale: {
					value: 1
				},
				displacementBias: {
					value: 0
				}
			},
			roughnessmap: {
				roughnessMap: {
					value: null
				}
			},
			metalnessmap: {
				metalnessMap: {
					value: null
				}
			},
			gradientmap: {
				gradientMap: {
					value: null
				}
			},
			fog: {
				fogDensity: {
					value: 25e-5
				},
				fogNear: {
					value: 1
				},
				fogFar: {
					value: 2e3
				},
				fogColor: {
					value: new b(16777215)
				}
			},
			lights: {
				ambientLightColor: {
					value: []
				},
				lightProbe: {
					value: []
				},
				directionalLights: {
					value: [],
					properties: {
						direction: {},
						color: {},
						shadow: {},
						shadowBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				directionalShadowMap: {
					value: []
				},
				directionalShadowMatrix: {
					value: []
				},
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {},
						shadow: {},
						shadowBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				spotShadowMap: {
					value: []
				},
				spotShadowMatrix: {
					value: []
				},
				pointLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						decay: {},
						distance: {},
						shadow: {},
						shadowBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {}
					}
				},
				pointShadowMap: {
					value: []
				},
				pointShadowMatrix: {
					value: []
				},
				hemisphereLights: {
					value: [],
					properties: {
						direction: {},
						skyColor: {},
						groundColor: {}
					}
				},
				rectAreaLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						width: {},
						height: {}
					}
				}
			},
			points: {
				diffuse: {
					value: new b(15658734)
				},
				opacity: {
					value: 1
				},
				size: {
					value: 1
				},
				scale: {
					value: 1
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new o
				}
			},
			sprite: {
				diffuse: {
					value: new b(15658734)
				},
				opacity: {
					value: 1
				},
				center: {
					value: new i(.5, .5)
				},
				rotation: {
					value: 0
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new o
				}
			}
		},
		wo = {
			basic: {
				uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.fog]),
				vertexShader: go.meshbasic_vert,
				fragmentShader: go.meshbasic_frag
			},
			lambert: {
				uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.fog, bo.lights, {
					emissive: {
						value: new b(0)
					}
				}]),
				vertexShader: go.meshlambert_vert,
				fragmentShader: go.meshlambert_frag
			},
			phong: {
				uniforms: y([bo.common, bo.specularmap, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.gradientmap, bo.fog, bo.lights, {
					emissive: {
						value: new b(0)
					},
					specular: {
						value: new b(1118481)
					},
					shininess: {
						value: 30
					}
				}]),
				vertexShader: go.meshphong_vert,
				fragmentShader: go.meshphong_frag
			},
			standard: {
				uniforms: y([bo.common, bo.envmap, bo.aomap, bo.lightmap, bo.emissivemap, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.roughnessmap, bo.metalnessmap, bo.fog, bo.lights, {
					emissive: {
						value: new b(0)
					},
					roughness: {
						value: .5
					},
					metalness: {
						value: .5
					},
					envMapIntensity: {
						value: 1
					}
				}]),
				vertexShader: go.meshphysical_vert,
				fragmentShader: go.meshphysical_frag
			},
			matcap: {
				uniforms: y([bo.common, bo.bumpmap, bo.normalmap, bo.displacementmap, bo.fog, {
					matcap: {
						value: null
					}
				}]),
				vertexShader: go.meshmatcap_vert,
				fragmentShader: go.meshmatcap_frag
			},
			points: {
				uniforms: y([bo.points, bo.fog]),
				vertexShader: go.points_vert,
				fragmentShader: go.points_frag
			},
			dashed: {
				uniforms: y([bo.common, bo.fog, {
					scale: {
						value: 1
					},
					dashSize: {
						value: 1
					},
					totalSize: {
						value: 2
					}
				}]),
				vertexShader: go.linedashed_vert,
				fragmentShader: go.linedashed_frag
			},
			depth: {
				uniforms: y([bo.common, bo.displacementmap]),
				vertexShader: go.depth_vert,
				fragmentShader: go.depth_frag
			},
			normal: {
				uniforms: y([bo.common, bo.bumpmap, bo.normalmap, bo.displacementmap, {
					opacity: {
						value: 1
					}
				}]),
				vertexShader: go.normal_vert,
				fragmentShader: go.normal_frag
			},
			sprite: {
				uniforms: y([bo.sprite, bo.fog]),
				vertexShader: go.sprite_vert,
				fragmentShader: go.sprite_frag
			},
			background: {
				uniforms: {
					uvTransform: {
						value: new o
					},
					t2D: {
						value: null
					}
				},
				vertexShader: go.background_vert,
				fragmentShader: go.background_frag
			},
			cube: {
				uniforms: {
					tCube: {
						value: null
					},
					tFlip: {
						value: -1
					},
					opacity: {
						value: 1
					}
				},
				vertexShader: go.cube_vert,
				fragmentShader: go.cube_frag
			},
			equirect: {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: go.equirect_vert,
				fragmentShader: go.equirect_frag
			},
			distanceRGBA: {
				uniforms: y([bo.common, bo.displacementmap, {
					referencePosition: {
						value: new r
					},
					nearDistance: {
						value: 1
					},
					farDistance: {
						value: 1e3
					}
				}]),
				vertexShader: go.distanceRGBA_vert,
				fragmentShader: go.distanceRGBA_frag
			},
			shadow: {
				uniforms: y([bo.lights, bo.fog, {
					color: {
						value: new b(0)
					},
					opacity: {
						value: 1
					}
				}]),
				vertexShader: go.shadow_vert,
				fragmentShader: go.shadow_frag
			}
		};
	wo.physical = {
		uniforms: y([wo.standard.uniforms, {
			clearCoat: {
				value: 0
			},
			clearCoatRoughness: {
				value: 0
			}
		}]),
		vertexShader: go.meshphysical_vert,
		fragmentShader: go.meshphysical_frag
	}, Object.assign(_.prototype, {
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
			for (var t = 0, i = e.vertexNormals.length; t < i; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
			for (t = 0, i = e.vertexColors.length; t < i; t++) this.vertexColors[t] = e.vertexColors[t].clone();
			return this
		}
	}), E.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), E.DefaultOrder = "XYZ", Object.defineProperties(E.prototype, {
		x: {
			get: function() {
				return this._x
			},
			set: function(e) {
				this._x = e, this.onChangeCallback()
			}
		},
		y: {
			get: function() {
				return this._y
			},
			set: function(e) {
				this._y = e, this.onChangeCallback()
			}
		},
		z: {
			get: function() {
				return this._z
			},
			set: function(e) {
				this._z = e, this.onChangeCallback()
			}
		},
		order: {
			get: function() {
				return this._order
			},
			set: function(e) {
				this._order = e, this.onChangeCallback()
			}
		}
	}), Object.assign(E.prototype, {
		isEuler: !0,
		set: function(e, t, i, n) {
			return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
		},
		clone: function() {
			return new this.constructor(this._x, this._y, this._z, this._order)
		},
		copy: function(e) {
			return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
		},
		setFromRotationMatrix: function(e, t, i) {
			var n = uo.clamp,
				r = e.elements;
			e = r[0];
			var o = r[4],
				s = r[8],
				a = r[1],
				l = r[5],
				c = r[9],
				h = r[2],
				u = r[6];
			return r = r[10], "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-o, e)) : (this._x = Math.atan2(u, l), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(s, r), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, e))) : "ZYX" === t ? (this._y = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(a, e)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === t ? (this._z = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, e)) : (this._x = 0, this._y = Math.atan2(s, r))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(u, l), this._y = Math.atan2(s, e)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
		},
		setFromQuaternion: function() {
			var e = new g;
			return function(t, i, n) {
				return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n)
			}
		}(),
		setFromVector3: function(e, t) {
			return this.set(e.x, e.y, e.z, t || this._order)
		},
		reorder: function() {
			var e = new n;
			return function(t) {
				return e.setFromEuler(this), this.setFromQuaternion(e, t)
			}
		}(),
		equals: function(e) {
			return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
		},
		fromArray: function(e) {
			return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
		},
		toArray: function(e, t) {
			return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
		},
		toVector3: function(e) {
			return e ? e.set(this._x, this._y, this._z) : new r(this._x, this._y, this._z)
		},
		onChange: function(e) {
			return this.onChangeCallback = e, this
		},
		onChangeCallback: function() {}
	}), Object.assign(M.prototype, {
		set: function(e) {
			this.mask = 1 << e | 0
		},
		enable: function(e) {
			this.mask = this.mask | 1 << e | 0
		},
		toggle: function(e) {
			this.mask ^= 1 << e | 0
		},
		disable: function(e) {
			this.mask &= ~(1 << e | 0)
		},
		test: function(e) {
			return 0 != (this.mask & e.mask)
		}
	});
	var xo = 0;
	S.DefaultUp = new r(0, 1, 0), S.DefaultMatrixAutoUpdate = !0, S.prototype = Object.assign(Object.create(t.prototype), {
		constructor: S,
		isObject3D: !0,
		onBeforeRender: function() {},
		onAfterRender: function() {},
		applyMatrix: function(e) {
			this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
		},
		applyQuaternion: function(e) {
			return this.quaternion.premultiply(e), this
		},
		setRotationFromAxisAngle: function(e, t) {
			this.quaternion.setFromAxisAngle(e, t)
		},
		setRotationFromEuler: function(e) {
			this.quaternion.setFromEuler(e, !0)
		},
		setRotationFromMatrix: function(e) {
			this.quaternion.setFromRotationMatrix(e)
		},
		setRotationFromQuaternion: function(e) {
			this.quaternion.copy(e)
		},
		rotateOnAxis: function() {
			var e = new n;
			return function(t, i) {
				return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
			}
		}(),
		rotateOnWorldAxis: function() {
			var e = new n;
			return function(t, i) {
				return e.setFromAxisAngle(t, i), this.quaternion.premultiply(e), this
			}
		}(),
		rotateX: function() {
			var e = new r(1, 0, 0);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		rotateY: function() {
			var e = new r(0, 1, 0);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		rotateZ: function() {
			var e = new r(0, 0, 1);
			return function(t) {
				return this.rotateOnAxis(e, t)
			}
		}(),
		translateOnAxis: function() {
			var e = new r;
			return function(t, i) {
				return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
			}
		}(),
		translateX: function() {
			var e = new r(1, 0, 0);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		translateY: function() {
			var e = new r(0, 1, 0);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		translateZ: function() {
			var e = new r(0, 0, 1);
			return function(t) {
				return this.translateOnAxis(e, t)
			}
		}(),
		localToWorld: function(e) {
			return e.applyMatrix4(this.matrixWorld)
		},
		worldToLocal: function() {
			var e = new g;
			return function(t) {
				return t.applyMatrix4(e.getInverse(this.matrixWorld))
			}
		}(),
		lookAt: function() {
			var e = new n,
				t = new g,
				i = new r,
				o = new r;
			return function(n, r, s) {
				n.isVector3 ? i.copy(n) : i.set(n, r, s), n = this.parent, this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? t.lookAt(o, i, this.up) : t.lookAt(i, o, this.up), this.quaternion.setFromRotationMatrix(t), n && (t.extractRotation(n.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
			}
		}(),
		add: function(e) {
			if (1 < arguments.length) {
				for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
				return this
			}
			return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
				type: "added"
			}), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
		},
		remove: function(e) {
			if (1 < arguments.length) {
				for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
				return this
			}
			return -1 !== (t = this.children.indexOf(e)) && (e.parent = null, e.dispatchEvent({
				type: "removed"
			}), this.children.splice(t, 1)), this
		},
		attach: function() {
			var e = new g;
			return function(t) {
				return this.updateWorldMatrix(!0, !1), e.getInverse(this.matrixWorld), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), e.multiply(t.parent.matrixWorld)), t.applyMatrix(e), t.updateWorldMatrix(!1, !1), this.add(t), this
			}
		}(),
		getObjectById: function(e) {
			return this.getObjectByProperty("id", e)
		},
		getObjectByName: function(e) {
			return this.getObjectByProperty("name", e)
		},
		getObjectByProperty: function(e, t) {
			if (this[e] === t) return this;
			for (var i = 0, n = this.children.length; i < n; i++) {
				var r = this.children[i].getObjectByProperty(e, t);
				if (void 0 !== r) return r
			}
		},
		getWorldPosition: function(e) {
			return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new r), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
		},
		getWorldQuaternion: function() {
			var e = new r,
				t = new r;
			return function(i) {
				return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, i, t), i
			}
		}(),
		getWorldScale: function() {
			var e = new r,
				t = new n;
			return function(i) {
				return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i
			}
		}(),
		getWorldDirection: function(e) {
			void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
			var t = this.matrixWorld.elements;
			return e.set(t[8], t[9], t[10]).normalize()
		},
		raycast: function() {},
		traverse: function(e) {
			e(this);
			for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverse(e)
		},
		traverseVisible: function(e) {
			if (!1 !== this.visible) {
				e(this);
				for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
			}
		},
		traverseAncestors: function(e) {
			var t = this.parent;
			null !== t && (e(t), t.traverseAncestors(e))
		},
		updateMatrix: function() {
			this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
		},
		updateMatrixWorld: function(e) {
			this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
			for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e)
		},
		updateWorldMatrix: function(e, t) {
			var i = this.parent;
			if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
				for (t = 0, i = (e = this.children).length; t < i; t++) e[t].updateWorldMatrix(!1, !0)
		},
		toJSON: function(e) {
			function t(t, i) {
				return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid
			}

			function i(e) {
				var t, i = [];
				for (t in e) {
					var n = e[t];
					delete n.metadata, i.push(n)
				}
				return i
			}
			var n = void 0 === e || "string" == typeof e,
				r = {};
			n && (e = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			}, r.metadata = {
				version: 4.5,
				type: "Object",
				generator: "Object3D.toJSON"
			});
			var o = {};
			if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
				o.geometry = t(e.geometries, this.geometry);
				var s = this.geometry.parameters;
				if (void 0 !== s && void 0 !== s.shapes)
					if (s = s.shapes, Array.isArray(s))
						for (var a = 0, l = s.length; a < l; a++) t(e.shapes, s[a]);
					else t(e.shapes, s)
			}
			if (void 0 !== this.material)
				if (Array.isArray(this.material)) {
					for (s = [], a = 0, l = this.material.length; a < l; a++) s.push(t(e.materials, this.material[a]));
					o.material = s
				} else o.material = t(e.materials, this.material);
			if (0 < this.children.length)
				for (o.children = [], a = 0; a < this.children.length; a++) o.children.push(this.children[a].toJSON(e).object);
			if (n) {
				n = i(e.geometries), a = i(e.materials), l = i(e.textures);
				var c = i(e.images);
				s = i(e.shapes), 0 < n.length && (r.geometries = n), 0 < a.length && (r.materials = a), 0 < l.length && (r.textures = l), 0 < c.length && (r.images = c), 0 < s.length && (r.shapes = s)
			}
			return r.object = o, r
		},
		clone: function(e) {
			return (new this.constructor).copy(this, e)
		},
		copy: function(e, t) {
			if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
				for (t = 0; t < e.children.length; t++) this.add(e.children[t].clone());
			return this
		}
	});
	var _o = 0;
	T.prototype = Object.assign(Object.create(t.prototype), {
		constructor: T,
		isGeometry: !0,
		applyMatrix: function(e) {
			for (var t = (new o).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(e);
			for (i = 0, n = this.faces.length; i < n; i++) {
				(e = this.faces[i]).normal.applyMatrix3(t).normalize();
				for (var r = 0, s = e.vertexNormals.length; r < s; r++) e.vertexNormals[r].applyMatrix3(t).normalize()
			}
			return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
		},
		rotateX: function() {
			var e = new g;
			return function(t) {
				return e.makeRotationX(t), this.applyMatrix(e), this
			}
		}(),
		rotateY: function() {
			var e = new g;
			return function(t) {
				return e.makeRotationY(t), this.applyMatrix(e), this
			}
		}(),
		rotateZ: function() {
			var e = new g;
			return function(t) {
				return e.makeRotationZ(t), this.applyMatrix(e), this
			}
		}(),
		translate: function() {
			var e = new g;
			return function(t, i, n) {
				return e.makeTranslation(t, i, n), this.applyMatrix(e), this
			}
		}(),
		scale: function() {
			var e = new g;
			return function(t, i, n) {
				return e.makeScale(t, i, n), this.applyMatrix(e), this
			}
		}(),
		lookAt: function() {
			var e = new S;
			return function(t) {
				e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
			}
		}(),
		fromBufferGeometry: function(e) {
			function t(e, t, o, s) {
				var a = void 0 === c ? [] : [n.colors[e].clone(), n.colors[t].clone(), n.colors[o].clone()];
				s = new _(e, t, o, void 0 === l ? [] : [(new r).fromArray(l, 3 * e), (new r).fromArray(l, 3 * t), (new r).fromArray(l, 3 * o)], a, s), n.faces.push(s), void 0 !== h && n.faceVertexUvs[0].push([(new i).fromArray(h, 2 * e), (new i).fromArray(h, 2 * t), (new i).fromArray(h, 2 * o)]), void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * o)])
			}
			var n = this,
				o = null !== e.index ? e.index.array : void 0,
				s = e.attributes,
				a = s.position.array,
				l = void 0 !== s.normal ? s.normal.array : void 0,
				c = void 0 !== s.color ? s.color.array : void 0,
				h = void 0 !== s.uv ? s.uv.array : void 0,
				u = void 0 !== s.uv2 ? s.uv2.array : void 0;
			for (void 0 !== u && (this.faceVertexUvs[1] = []), s = 0; s < a.length; s += 3) n.vertices.push((new r).fromArray(a, s)), void 0 !== c && n.colors.push((new b).fromArray(c, s));
			var d = e.groups;
			if (0 < d.length)
				for (s = 0; s < d.length; s++) {
					var p = (a = d[s]).start,
						f = p;
					for (p += a.count; f < p; f += 3) void 0 !== o ? t(o[f], o[f + 1], o[f + 2], a.materialIndex) : t(f, f + 1, f + 2, a.materialIndex)
				} else if (void 0 !== o)
					for (s = 0; s < o.length; s += 3) t(o[s], o[s + 1], o[s + 2]);
				else
					for (s = 0; s < a.length / 3; s += 3) t(s, s + 1, s + 2);
			return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
		},
		center: function() {
			var e = new r;
			return function() {
				return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
			}
		}(),
		normalize: function() {
			this.computeBoundingSphere();
			var e = this.boundingSphere.center,
				t = this.boundingSphere.radius;
			t = 0 === t ? 1 : 1 / t;
			var i = new g;
			return i.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1), this.applyMatrix(i), this
		},
		computeFaceNormals: function() {
			for (var e = new r, t = new r, i = 0, n = this.faces.length; i < n; i++) {
				var o = this.faces[i],
					s = this.vertices[o.a],
					a = this.vertices[o.b];
				e.subVectors(this.vertices[o.c], a), t.subVectors(s, a), e.cross(t), e.normalize(), o.normal.copy(e)
			}
		},
		computeVertexNormals: function(e) {
			var t;
			void 0 === e && (e = !0);
			var i = Array(this.vertices.length),
				n = 0;
			for (t = this.vertices.length; n < t; n++) i[n] = new r;
			if (e) {
				var o = new r,
					s = new r;
				for (e = 0, n = this.faces.length; e < n; e++) {
					t = this.faces[e];
					var a = this.vertices[t.a],
						l = this.vertices[t.b],
						c = this.vertices[t.c];
					o.subVectors(c, l), s.subVectors(a, l), o.cross(s), i[t.a].add(o), i[t.b].add(o), i[t.c].add(o)
				}
			} else
				for (this.computeFaceNormals(), e = 0, n = this.faces.length; e < n; e++) i[(t = this.faces[e]).a].add(t.normal), i[t.b].add(t.normal), i[t.c].add(t.normal);
			for (n = 0, t = this.vertices.length; n < t; n++) i[n].normalize();
			for (e = 0, n = this.faces.length; e < n; e++) 3 === (a = (t = this.faces[e]).vertexNormals).length ? (a[0].copy(i[t.a]), a[1].copy(i[t.b]), a[2].copy(i[t.c])) : (a[0] = i[t.a].clone(), a[1] = i[t.b].clone(), a[2] = i[t.c].clone());
			0 < this.faces.length && (this.normalsNeedUpdate = !0)
		},
		computeFlatVertexNormals: function() {
			var e;
			this.computeFaceNormals();
			var t = 0;
			for (e = this.faces.length; t < e; t++) {
				var i = this.faces[t],
					n = i.vertexNormals;
				3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
			}
			0 < this.faces.length && (this.normalsNeedUpdate = !0)
		},
		computeMorphNormals: function() {
			var e, t, i = 0;
			for (t = this.faces.length; i < t; i++) {
				var n = this.faces[i];
				n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
				var o = 0;
				for (e = n.vertexNormals.length; o < e; o++) n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone()
			}
			var s = new T;
			for (s.faces = this.faces, o = 0, e = this.morphTargets.length; o < e; o++) {
				if (!this.morphNormals[o]) {
					this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals;
					var a = this.morphNormals[o].vertexNormals;
					for (i = 0, t = this.faces.length; i < t; i++) {
						var l = new r,
							c = {
								a: new r,
								b: new r,
								c: new r
							};
						n.push(l), a.push(c)
					}
				}
				for (a = this.morphNormals[o], s.vertices = this.morphTargets[o].vertices, s.computeFaceNormals(), s.computeVertexNormals(), i = 0, t = this.faces.length; i < t; i++) n = this.faces[i], l = a.faceNormals[i], c = a.vertexNormals[i], l.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2])
			}
			for (i = 0, t = this.faces.length; i < t; i++)(n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices)
		},
		computeBoundingSphere: function() {
			null === this.boundingSphere && (this.boundingSphere = new p), this.boundingSphere.setFromPoints(this.vertices)
		},
		merge: function(e, t, i) {
			if (e && e.isGeometry) {
				var n, r = this.vertices.length,
					s = this.vertices,
					a = e.vertices,
					l = this.faces,
					c = e.faces,
					h = this.faceVertexUvs[0],
					u = e.faceVertexUvs[0],
					d = this.colors,
					p = e.colors;
				void 0 === i && (i = 0), void 0 !== t && (n = (new o).getNormalMatrix(t)), e = 0;
				for (var f = a.length; e < f; e++) {
					var m = a[e].clone();
					void 0 !== t && m.applyMatrix4(t), s.push(m)
				}
				for (e = 0, f = p.length; e < f; e++) d.push(p[e].clone());
				for (e = 0, f = c.length; e < f; e++) {
					var g = (a = c[e]).vertexNormals;
					for (p = a.vertexColors, (d = new _(a.a + r, a.b + r, a.c + r)).normal.copy(a.normal), void 0 !== n && d.normal.applyMatrix3(n).normalize(), t = 0, s = g.length; t < s; t++) m = g[t].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), d.vertexNormals.push(m);
					for (d.color.copy(a.color), t = 0, s = p.length; t < s; t++) m = p[t], d.vertexColors.push(m.clone());
					d.materialIndex = a.materialIndex + i, l.push(d)
				}
				for (e = 0, f = u.length; e < f; e++)
					if (n = [], void 0 !== (i = u[e])) {
						for (t = 0, s = i.length; t < s; t++) n.push(i[t].clone());
						h.push(n)
					}
			} else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
		},
		mergeMesh: function(e) {
			e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
		},
		mergeVertices: function() {
			var e, t = {},
				i = [],
				n = [],
				r = Math.pow(10, 4),
				o = 0;
			for (e = this.vertices.length; o < e; o++) {
				var s = this.vertices[o];
				void 0 === t[s = Math.round(s.x * r) + "_" + Math.round(s.y * r) + "_" + Math.round(s.z * r)] ? (t[s] = o, i.push(this.vertices[o]), n[o] = i.length - 1) : n[o] = n[t[s]]
			}
			for (t = [], o = 0, e = this.faces.length; o < e; o++)
				for ((r = this.faces[o]).a = n[r.a], r.b = n[r.b], r.c = n[r.c], r = [r.a, r.b, r.c], s = 0; 3 > s; s++)
					if (r[s] === r[(s + 1) % 3]) {
						t.push(o);
						break
					} for (o = t.length - 1; 0 <= o; o--)
				for (r = t[o], this.faces.splice(r, 1), n = 0, e = this.faceVertexUvs.length; n < e; n++) this.faceVertexUvs[n].splice(r, 1);
			return o = this.vertices.length - i.length, this.vertices = i, o
		},
		setFromPoints: function(e) {
			this.vertices = [];
			for (var t = 0, i = e.length; t < i; t++) {
				var n = e[t];
				this.vertices.push(new r(n.x, n.y, n.z || 0))
			}
			return this
		},
		sortFacesByMaterialIndex: function() {
			for (var e = this.faces, t = e.length, i = 0; i < t; i++) e[i]._id = i;
			e.sort((function(e, t) {
				return e.materialIndex - t.materialIndex
			}));
			var n, r, o = this.faceVertexUvs[0],
				s = this.faceVertexUvs[1];
			for (o && o.length === t && (n = []), s && s.length === t && (r = []), i = 0; i < t; i++) {
				var a = e[i]._id;
				n && n.push(o[a]), r && r.push(s[a])
			}
			n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
		},
		toJSON: function() {
			function e(e, t, i) {
				return i ? e | 1 << t : e & ~(1 << t)
			}

			function t(e) {
				var t = e.x.toString() + e.y.toString() + e.z.toString();
				return void 0 !== c[t] || (c[t] = l.length / 3, l.push(e.x, e.y, e.z)), c[t]
			}

			function i(e) {
				var t = e.r.toString() + e.g.toString() + e.b.toString();
				return void 0 !== u[t] || (u[t] = h.length, h.push(e.getHex())), u[t]
			}

			function n(e) {
				var t = e.x.toString() + e.y.toString();
				return void 0 !== p[t] || (p[t] = d.length / 2, d.push(e.x, e.y)), p[t]
			}
			var r = {
				metadata: {
					version: 4.5,
					type: "Geometry",
					generator: "Geometry.toJSON"
				}
			};
			if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
				var o, s = this.parameters;
				for (o in s) void 0 !== s[o] && (r[o] = s[o]);
				return r
			}
			for (s = [], o = 0; o < this.vertices.length; o++) {
				var a = this.vertices[o];
				s.push(a.x, a.y, a.z)
			}
			a = [];
			var l = [],
				c = {},
				h = [],
				u = {},
				d = [],
				p = {};
			for (o = 0; o < this.faces.length; o++) {
				var f = this.faces[o],
					m = void 0 !== this.faceVertexUvs[0][o],
					g = 0 < f.normal.length(),
					v = 0 < f.vertexNormals.length,
					y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
					b = 0 < f.vertexColors.length,
					w = 0;
				w = e(w, 0, 0), w = e(w, 1, !0), w = e(w, 2, !1), w = e(w, 3, m), w = e(w, 4, g), w = e(w, 5, v), w = e(w, 6, y), w = e(w, 7, b), a.push(w), a.push(f.a, f.b, f.c), a.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], a.push(n(m[0]), n(m[1]), n(m[2]))), g && a.push(t(f.normal)), v && (g = f.vertexNormals, a.push(t(g[0]), t(g[1]), t(g[2]))), y && a.push(i(f.color)), b && (f = f.vertexColors, a.push(i(f[0]), i(f[1]), i(f[2])))
			}
			return r.data = {}, r.data.vertices = s, r.data.normals = l, 0 < h.length && (r.data.colors = h), 0 < d.length && (r.data.uvs = [d]), r.data.faces = a, r
		},
		clone: function() {
			return (new T).copy(this)
		},
		copy: function(e) {
			var t, i, n;
			this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
				[]
			], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
			var r = e.vertices,
				o = 0;
			for (t = r.length; o < t; o++) this.vertices.push(r[o].clone());
			for (o = 0, t = (r = e.colors).length; o < t; o++) this.colors.push(r[o].clone());
			for (o = 0, t = (r = e.faces).length; o < t; o++) this.faces.push(r[o].clone());
			for (o = 0, t = e.faceVertexUvs.length; o < t; o++) {
				var s = e.faceVertexUvs[o];
				for (void 0 === this.faceVertexUvs[o] && (this.faceVertexUvs[o] = []), r = 0, i = s.length; r < i; r++) {
					var a = s[r],
						l = [],
						c = 0;
					for (n = a.length; c < n; c++) l.push(a[c].clone());
					this.faceVertexUvs[o].push(l)
				}
			}
			for (o = 0, t = (c = e.morphTargets).length; o < t; o++) {
				if ((n = {}).name = c[o].name, void 0 !== c[o].vertices)
					for (n.vertices = [], r = 0, i = c[o].vertices.length; r < i; r++) n.vertices.push(c[o].vertices[r].clone());
				if (void 0 !== c[o].normals)
					for (n.normals = [], r = 0, i = c[o].normals.length; r < i; r++) n.normals.push(c[o].normals[r].clone());
				this.morphTargets.push(n)
			}
			for (o = 0, t = (c = e.morphNormals).length; o < t; o++) {
				if (n = {}, void 0 !== c[o].vertexNormals)
					for (n.vertexNormals = [], r = 0, i = c[o].vertexNormals.length; r < i; r++) s = c[o].vertexNormals[r], (a = {}).a = s.a.clone(), a.b = s.b.clone(), a.c = s.c.clone(), n.vertexNormals.push(a);
				if (void 0 !== c[o].faceNormals)
					for (n.faceNormals = [], r = 0, i = c[o].faceNormals.length; r < i; r++) n.faceNormals.push(c[o].faceNormals[r].clone());
				this.morphNormals.push(n)
			}
			for (o = 0, t = (r = e.skinWeights).length; o < t; o++) this.skinWeights.push(r[o].clone());
			for (o = 0, t = (r = e.skinIndices).length; o < t; o++) this.skinIndices.push(r[o].clone());
			for (o = 0, t = (r = e.lineDistances).length; o < t; o++) this.lineDistances.push(r[o]);
			return null !== (o = e.boundingBox) && (this.boundingBox = o.clone()), null !== (o = e.boundingSphere) && (this.boundingSphere = o.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}), Object.defineProperty(A.prototype, "needsUpdate", {
		set: function(e) {
			!0 === e && this.version++
		}
	}), Object.assign(A.prototype, {
		isBufferAttribute: !0,
		onUploadCallback: function() {},
		setArray: function(e) {
			if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
			return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
		},
		setDynamic: function(e) {
			return this.dynamic = e, this
		},
		copy: function(e) {
			return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
		},
		copyAt: function(e, t, i) {
			e *= this.itemSize, i *= t.itemSize;
			for (var n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
			return this
		},
		copyArray: function(e) {
			return this.array.set(e), this
		},
		copyColorsArray: function(e) {
			for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
				var o = e[n];
				void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new b), t[i++] = o.r, t[i++] = o.g, t[i++] = o.b
			}
			return this
		},
		copyVector2sArray: function(e) {
			for (var t = this.array, n = 0, r = 0, o = e.length; r < o; r++) {
				var s = e[r];
				void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), s = new i), t[n++] = s.x, t[n++] = s.y
			}
			return this
		},
		copyVector3sArray: function(e) {
			for (var t = this.array, i = 0, n = 0, o = e.length; n < o; n++) {
				var s = e[n];
				void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new r), t[i++] = s.x, t[i++] = s.y, t[i++] = s.z
			}
			return this
		},
		copyVector4sArray: function(e) {
			for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
				var o = e[n];
				void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new a), t[i++] = o.x, t[i++] = o.y, t[i++] = o.z, t[i++] = o.w
			}
			return this
		},
		set: function(e, t) {
			return void 0 === t && (t = 0), this.array.set(e, t), this
		},
		getX: function(e) {
			return this.array[e * this.itemSize]
		},
		setX: function(e, t) {
			return this.array[e * this.itemSize] = t, this
		},
		getY: function(e) {
			return this.array[e * this.itemSize + 1]
		},
		setY: function(e, t) {
			return this.array[e * this.itemSize + 1] = t, this
		},
		getZ: function(e) {
			return this.array[e * this.itemSize + 2]
		},
		setZ: function(e, t) {
			return this.array[e * this.itemSize + 2] = t, this
		},
		getW: function(e) {
			return this.array[e * this.itemSize + 3]
		},
		setW: function(e, t) {
			return this.array[e * this.itemSize + 3] = t, this
		},
		setXY: function(e, t, i) {
			return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
		},
		setXYZ: function(e, t, i, n) {
			return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
		},
		setXYZW: function(e, t, i, n, r) {
			return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
		},
		onUpload: function(e) {
			return this.onUploadCallback = e, this
		},
		clone: function() {
			return new this.constructor(this.array, this.itemSize).copy(this)
		},
		toJSON: function() {
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			}
		}
	}), L.prototype = Object.create(A.prototype), L.prototype.constructor = L, C.prototype = Object.create(A.prototype), C.prototype.constructor = C, P.prototype = Object.create(A.prototype), P.prototype.constructor = P, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, R.prototype = Object.create(A.prototype), R.prototype.constructor = R, O.prototype = Object.create(A.prototype), O.prototype.constructor = O, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, z.prototype = Object.create(A.prototype), z.prototype.constructor = z, k.prototype = Object.create(A.prototype), k.prototype.constructor = k, Object.assign(N.prototype, {
		computeGroups: function(e) {
			var t = [],
				i = void 0;
			e = e.faces;
			for (var n = 0; n < e.length; n++) {
				var r = e[n];
				if (r.materialIndex !== i) {
					i = r.materialIndex, void 0 !== o && (o.count = 3 * n - o.start, t.push(o));
					var o = {
						start: 3 * n,
						materialIndex: i
					}
				}
			}
			void 0 !== o && (o.count = 3 * n - o.start, t.push(o)), this.groups = t
		},
		fromGeometry: function(e) {
			var t = e.faces,
				n = e.vertices,
				r = e.faceVertexUvs,
				o = r[0] && 0 < r[0].length,
				s = r[1] && 0 < r[1].length,
				a = e.morphTargets,
				l = a.length;
			if (0 < l) {
				for (var c = [], h = 0; h < l; h++) c[h] = {
					name: a[h].name,
					data: []
				};
				this.morphTargets.position = c
			}
			var u = e.morphNormals,
				d = u.length;
			if (0 < d) {
				var p = [];
				for (h = 0; h < d; h++) p[h] = {
					name: u[h].name,
					data: []
				};
				this.morphTargets.normal = p
			}
			var f = e.skinIndices,
				m = e.skinWeights,
				g = f.length === n.length,
				v = m.length === n.length;
			for (0 < n.length && 0 === t.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < t.length; h++) {
				var y = t[h];
				this.vertices.push(n[y.a], n[y.b], n[y.c]);
				var b = y.vertexNormals;
				for (3 === b.length ? this.normals.push(b[0], b[1], b[2]) : (b = y.normal, this.normals.push(b, b, b)), 3 === (b = y.vertexColors).length ? this.colors.push(b[0], b[1], b[2]) : (b = y.color, this.colors.push(b, b, b)), !0 === o && (void 0 !== (b = r[0][h]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))), !0 === s && (void 0 !== (b = r[1][h]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))), b = 0; b < l; b++) {
					var w = a[b].vertices;
					c[b].data.push(w[y.a], w[y.b], w[y.c])
				}
				for (b = 0; b < d; b++) w = u[b].vertexNormals[h], p[b].data.push(w.a, w.b, w.c);
				g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
			}
			return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
		}
	});
	var Eo = 1;
	H.prototype = Object.assign(Object.create(t.prototype), {
		constructor: H,
		isBufferGeometry: !0,
		getIndex: function() {
			return this.index
		},
		setIndex: function(e) {
			Array.isArray(e) ? this.index = new(65535 < B(e) ? D : R)(e, 1) : this.index = e
		},
		addAttribute: function(e, t, i) {
			return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new A(t, i)))
		},
		getAttribute: function(e) {
			return this.attributes[e]
		},
		removeAttribute: function(e) {
			return delete this.attributes[e], this
		},
		addGroup: function(e, t, i) {
			this.groups.push({
				start: e,
				count: t,
				materialIndex: void 0 !== i ? i : 0
			})
		},
		clearGroups: function() {
			this.groups = []
		},
		setDrawRange: function(e, t) {
			this.drawRange.start = e, this.drawRange.count = t
		},
		applyMatrix: function(e) {
			var t = this.attributes.position;
			void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
			var i = this.attributes.normal;
			return void 0 !== i && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), void 0 !== (i = this.attributes.tangent) && ((t = (new o).getNormalMatrix(e)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
		},
		rotateX: function() {
			var e = new g;
			return function(t) {
				return e.makeRotationX(t), this.applyMatrix(e), this
			}
		}(),
		rotateY: function() {
			var e = new g;
			return function(t) {
				return e.makeRotationY(t), this.applyMatrix(e), this
			}
		}(),
		rotateZ: function() {
			var e = new g;
			return function(t) {
				return e.makeRotationZ(t), this.applyMatrix(e), this
			}
		}(),
		translate: function() {
			var e = new g;
			return function(t, i, n) {
				return e.makeTranslation(t, i, n), this.applyMatrix(e), this
			}
		}(),
		scale: function() {
			var e = new g;
			return function(t, i, n) {
				return e.makeScale(t, i, n), this.applyMatrix(e), this
			}
		}(),
		lookAt: function() {
			var e = new S;
			return function(t) {
				e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
			}
		}(),
		center: function() {
			var e = new r;
			return function() {
				return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
			}
		}(),
		setFromObject: function(e) {
			var t = e.geometry;
			if (e.isPoints || e.isLine) {
				e = new z(3 * t.vertices.length, 3);
				var i = new z(3 * t.colors.length, 3);
				this.addAttribute("position", e.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new z(t.lineDistances.length, 1), this.addAttribute("lineDistance", e.copyArray(t.lineDistances))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
			} else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
			return this
		},
		setFromPoints: function(e) {
			for (var t = [], i = 0, n = e.length; i < n; i++) {
				var r = e[i];
				t.push(r.x, r.y, r.z || 0)
			}
			return this.addAttribute("position", new z(t, 3)), this
		},
		updateFromObject: function(e) {
			var t = e.geometry;
			if (e.isMesh) {
				var i = t.__directGeometry;
				if (!0 === t.elementsNeedUpdate && (i = void 0, t.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(t);
				i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i
			}
			return !0 === t.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), !0 === t.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), !0 === t.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
		},
		fromGeometry: function(e) {
			return e.__directGeometry = (new N).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
		},
		fromDirectGeometry: function(e) {
			var t = new Float32Array(3 * e.vertices.length);
			for (var i in this.addAttribute("position", new A(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.addAttribute("normal", new A(t, 3).copyVector3sArray(e.normals))), 0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.addAttribute("color", new A(t, 3).copyColorsArray(e.colors))), 0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.addAttribute("uv", new A(t, 2).copyVector2sArray(e.uvs))), 0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.addAttribute("uv2", new A(t, 2).copyVector2sArray(e.uvs2))), this.groups = e.groups, e.morphTargets) {
				t = [];
				for (var n = e.morphTargets[i], r = 0, o = n.length; r < o; r++) {
					var s = n[r],
						a = new z(3 * s.data.length, 3);
					a.name = s.name, t.push(a.copyVector3sArray(s.data))
				}
				this.morphAttributes[i] = t
			}
			return 0 < e.skinIndices.length && (i = new z(4 * e.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(e.skinIndices))), 0 < e.skinWeights.length && (i = new z(4 * e.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(e.skinWeights))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
		},
		computeBoundingBox: function() {
			var e = new d;
			return function() {
				null === this.boundingBox && (this.boundingBox = new d);
				var t = this.attributes.position,
					i = this.morphAttributes.position;
				if (void 0 !== t) {
					if (this.boundingBox.setFromBufferAttribute(t), i) {
						t = 0;
						for (var n = i.length; t < n; t++) e.setFromBufferAttribute(i[t]), this.boundingBox.expandByPoint(e.min), this.boundingBox.expandByPoint(e.max)
					}
				} else this.boundingBox.makeEmpty();
				(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
			}
		}(),
		computeBoundingSphere: function() {
			var e = new d,
				t = new d,
				i = new r;
			return function() {
				null === this.boundingSphere && (this.boundingSphere = new p);
				var n = this.attributes.position,
					r = this.morphAttributes.position;
				if (n) {
					var o = this.boundingSphere.center;
					if (e.setFromBufferAttribute(n), r)
						for (var s = 0, a = r.length; s < a; s++) {
							var l = r[s];
							t.setFromBufferAttribute(l), e.expandByPoint(t.min), e.expandByPoint(t.max)
						}
					e.getCenter(o);
					var c = 0;
					for (s = 0, a = n.count; s < a; s++) i.fromBufferAttribute(n, s), c = Math.max(c, o.distanceToSquared(i));
					if (r)
						for (s = 0, a = r.length; s < a; s++) {
							n = 0;
							for (var h = (l = r[s]).count; n < h; n++) i.fromBufferAttribute(l, n), c = Math.max(c, o.distanceToSquared(i))
						}
					this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
				}
			}
		}(),
		computeFaceNormals: function() {},
		computeVertexNormals: function() {
			var e = this.index,
				t = this.attributes;
			if (t.position) {
				var i = t.position.array;
				if (void 0 === t.normal) this.addAttribute("normal", new A(new Float32Array(i.length), 3));
				else
					for (var n = t.normal.array, o = 0, s = n.length; o < s; o++) n[o] = 0;
				n = t.normal.array;
				var a = new r,
					l = new r,
					c = new r,
					h = new r,
					u = new r;
				if (e) {
					var d = e.array;
					for (o = 0, s = e.count; o < s; o += 3) {
						e = 3 * d[o + 0];
						var p = 3 * d[o + 1],
							f = 3 * d[o + 2];
						a.fromArray(i, e), l.fromArray(i, p), c.fromArray(i, f), h.subVectors(c, l), u.subVectors(a, l), h.cross(u), n[e] += h.x, n[e + 1] += h.y, n[e + 2] += h.z, n[p] += h.x, n[p + 1] += h.y, n[p + 2] += h.z, n[f] += h.x, n[f + 1] += h.y, n[f + 2] += h.z
					}
				} else
					for (o = 0, s = i.length; o < s; o += 9) a.fromArray(i, o), l.fromArray(i, o + 3), c.fromArray(i, o + 6), h.subVectors(c, l), u.subVectors(a, l), h.cross(u), n[o] = h.x, n[o + 1] = h.y, n[o + 2] = h.z, n[o + 3] = h.x, n[o + 4] = h.y, n[o + 5] = h.z, n[o + 6] = h.x, n[o + 7] = h.y, n[o + 8] = h.z;
				this.normalizeNormals(), t.normal.needsUpdate = !0
			}
		},
		merge: function(e, t) {
			if (e && e.isBufferGeometry) {
				void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
				var i, n = this.attributes;
				for (i in n)
					if (void 0 !== e.attributes[i]) {
						var r = n[i].array,
							o = e.attributes[i],
							s = o.array,
							a = o.itemSize * t;
						o = Math.min(s.length, r.length - a);
						for (var l = 0; l < o; l++, a++) r[a] = s[l]
					} return this
			}
			console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
		},
		normalizeNormals: function() {
			var e = new r;
			return function() {
				for (var t = this.attributes.normal, i = 0, n = t.count; i < n; i++) e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.normalize(), t.setXYZ(i, e.x, e.y, e.z)
			}
		}(),
		toNonIndexed: function() {
			function e(e, t) {
				var i = e.array;
				e = e.itemSize;
				for (var n, r = new i.constructor(t.length * e), o = 0, s = 0, a = t.length; s < a; s++) {
					n = t[s] * e;
					for (var l = 0; l < e; l++) r[o++] = i[n++]
				}
				return new A(r, e)
			}
			if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
			var t, i = new H,
				n = this.index.array,
				r = this.attributes;
			for (t in r) {
				var o = r[t];
				o = e(o, n), i.addAttribute(t, o)
			}
			var s = this.morphAttributes;
			for (t in s) {
				var a = [],
					l = s[t];
				r = 0;
				for (var c = l.length; r < c; r++) o = e(o = l[r], n), a.push(o);
				i.morphAttributes[t] = a
			}
			for (r = 0, t = (n = this.groups).length; r < t; r++) o = n[r], i.addGroup(o.start, o.count, o.materialIndex);
			return i
		},
		toJSON: function() {
			var e = {
				metadata: {
					version: 4.5,
					type: "BufferGeometry",
					generator: "BufferGeometry.toJSON"
				}
			};
			if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
				var t = this.parameters;
				for (c in t) void 0 !== t[c] && (e[c] = t[c]);
				return e
			}
			e.data = {
				attributes: {}
			}, null !== (t = this.index) && (e.data.index = {
				type: t.array.constructor.name,
				array: Array.prototype.slice.call(t.array)
			});
			var i = this.attributes;
			for (c in i) {
				var n = (t = i[c]).toJSON();
				"" !== t.name && (n.name = t.name), e.data.attributes[c] = n
			}
			i = {};
			var r = !1;
			for (c in this.morphAttributes) {
				for (var o = this.morphAttributes[c], s = [], a = 0, l = o.length; a < l; a++) n = (t = o[a]).toJSON(), "" !== t.name && (n.name = t.name), s.push(n);
				0 < s.length && (i[c] = s, r = !0)
			}
			r && (e.data.morphAttributes = i);
			var c = this.groups;
			return 0 < c.length && (e.data.groups = JSON.parse(JSON.stringify(c))), null !== (c = this.boundingSphere) && (e.data.boundingSphere = {
				center: c.center.toArray(),
				radius: c.radius
			}), e
		},
		clone: function() {
			return (new H).copy(this)
		},
		copy: function(e) {
			var t;
			this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = e.name;
			var i = e.index;
			for (s in null !== i && this.setIndex(i.clone()), i = e.attributes) this.addAttribute(s, i[s].clone());
			var n = e.morphAttributes;
			for (s in n) {
				var r = [],
					o = n[s];
				for (i = 0, t = o.length; i < t; i++) r.push(o[i].clone());
				this.morphAttributes[s] = r
			}
			var s = e.groups;
			for (i = 0, t = s.length; i < t; i++) n = s[i], this.addGroup(n.start, n.count, n.materialIndex);
			return null !== (s = e.boundingBox) && (this.boundingBox = s.clone()), null !== (s = e.boundingSphere) && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}), F.prototype = Object.create(T.prototype), F.prototype.constructor = F, U.prototype = Object.create(H.prototype), U.prototype.constructor = U, j.prototype = Object.create(T.prototype), j.prototype.constructor = j, G.prototype = Object.create(H.prototype), G.prototype.constructor = G;
	var Mo = 0;
	V.prototype = Object.assign(Object.create(t.prototype), {
		constructor: V,
		isMaterial: !0,
		onBeforeCompile: function() {},
		setValues: function(e) {
			if (void 0 !== e)
				for (var t in e) {
					var i = e[t];
					if (void 0 === i) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
					else if ("shading" === t) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
					else {
						var n = this[t];
						void 0 === n ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i
					}
				}
		},
		toJSON: function(e) {
			function t(e) {
				var t, i = [];
				for (t in e) {
					var n = e[t];
					delete n.metadata, i.push(n)
				}
				return i
			}
			var i = void 0 === e || "string" == typeof e;
			i && (e = {
				textures: {},
				images: {}
			});
			var n = {
				metadata: {
					version: 4.5,
					type: "Material",
					generator: "Material.toJSON"
				}
			};
			return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = t(e.textures), e = t(e.images), 0 < i.length && (n.textures = i), 0 < e.length && (n.images = e)), n
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
			var t = e.clippingPlanes,
				i = null;
			if (null !== t) {
				var n = t.length;
				i = Array(n);
				for (var r = 0; r !== n; ++r) i[r] = t[r].clone()
			}
			return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = v(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
	}, W.prototype.toJSON = function(e) {
		var t = V.prototype.toJSON.call(this, e);
		for (var i in t.uniforms = {}, this.uniforms) {
			var n = this.uniforms[i].value;
			t.uniforms[i] = n && n.isTexture ? {
				type: "t",
				value: n.toJSON(e).uuid
			} : n && n.isColor ? {
				type: "c",
				value: n.getHex()
			} : n && n.isVector2 ? {
				type: "v2",
				value: n.toArray()
			} : n && n.isVector3 ? {
				type: "v3",
				value: n.toArray()
			} : n && n.isVector4 ? {
				type: "v4",
				value: n.toArray()
			} : n && n.isMatrix3 ? {
				type: "m3",
				value: n.toArray()
			} : n && n.isMatrix4 ? {
				type: "m4",
				value: n.toArray()
			} : {
				value: n
			}
		}
		for (var r in 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, e = {}, this.extensions) !0 === this.extensions[r] && (e[r] = !0);
		return 0 < Object.keys(e).length && (t.extensions = e), t
	}, Object.assign(q.prototype, {
		set: function(e, t) {
			return this.origin.copy(e), this.direction.copy(t), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.origin.copy(e.origin), this.direction.copy(e.direction), this
		},
		at: function(e, t) {
			return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new r), t.copy(this.direction).multiplyScalar(e).add(this.origin)
		},
		lookAt: function(e) {
			return this.direction.copy(e).sub(this.origin).normalize(), this
		},
		recast: function() {
			var e = new r;
			return function(t) {
				return this.origin.copy(this.at(t, e)), this
			}
		}(),
		closestPointToPoint: function(e, t) {
			return void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new r), t.subVectors(e, this.origin), 0 > (e = t.dot(this.direction)) ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin)
		},
		distanceToPoint: function(e) {
			return Math.sqrt(this.distanceSqToPoint(e))
		},
		distanceSqToPoint: function() {
			var e = new r;
			return function(t) {
				var i = e.subVectors(t, this.origin).dot(this.direction);
				return 0 > i ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t))
			}
		}(),
		distanceSqToSegment: function() {
			var e = new r,
				t = new r,
				i = new r;
			return function(n, r, o, s) {
				e.copy(n).add(r).multiplyScalar(.5), t.copy(r).sub(n).normalize(), i.copy(this.origin).sub(e);
				var a = .5 * n.distanceTo(r),
					l = -this.direction.dot(t),
					c = i.dot(this.direction),
					h = -i.dot(t),
					u = i.lengthSq(),
					d = Math.abs(1 - l * l);
				if (0 < d) {
					r = l * c - h;
					var p = a * d;
					0 <= (n = l * h - c) ? r >= -p ? r <= p ? l = (n *= a = 1 / d) * (n + l * (r *= a) + 2 * c) + r * (l * n + r + 2 * h) + u : (r = a, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u) : (r = -a, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u) : r <= -p ? l = -(n = Math.max(0, -(-l * a + c))) * n + (r = 0 < n ? -a : Math.min(Math.max(-a, -h), a)) * (r + 2 * h) + u : r <= p ? (n = 0, l = (r = Math.min(Math.max(-a, -h), a)) * (r + 2 * h) + u) : l = -(n = Math.max(0, -(l * a + c))) * n + (r = 0 < n ? a : Math.min(Math.max(-a, -h), a)) * (r + 2 * h) + u
				} else r = 0 < l ? -a : a, l = -(n = Math.max(0, -(l * r + c))) * n + r * (r + 2 * h) + u;
				return o && o.copy(this.direction).multiplyScalar(n).add(this.origin), s && s.copy(t).multiplyScalar(r).add(e), l
			}
		}(),
		intersectSphere: function() {
			var e = new r;
			return function(t, i) {
				e.subVectors(t.center, this.origin);
				var n = e.dot(this.direction),
					r = e.dot(e) - n * n;
				return r > (t = t.radius * t.radius) ? null : (r = n - (t = Math.sqrt(t - r)), n += t, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
			}
		}(),
		intersectsSphere: function(e) {
			return this.distanceSqToPoint(e.center) <= e.radius * e.radius
		},
		distanceToPlane: function(e) {
			var t = e.normal.dot(this.direction);
			return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null
		},
		intersectPlane: function(e, t) {
			return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t)
		},
		intersectsPlane: function(e) {
			var t = e.distanceToPoint(this.origin);
			return 0 === t || 0 > e.normal.dot(this.direction) * t
		},
		intersectBox: function(e, t) {
			var i = 1 / this.direction.x,
				n = 1 / this.direction.y,
				r = 1 / this.direction.z,
				o = this.origin;
			if (0 <= i) {
				var s = (e.min.x - o.x) * i;
				i *= e.max.x - o.x
			} else s = (e.max.x - o.x) * i, i *= e.min.x - o.x;
			if (0 <= n) {
				var a = (e.min.y - o.y) * n;
				n *= e.max.y - o.y
			} else a = (e.max.y - o.y) * n, n *= e.min.y - o.y;
			return s > n || a > i ? null : ((a > s || s != s) && (s = a), (n < i || i != i) && (i = n), 0 <= r ? (a = (e.min.z - o.z) * r, e = (e.max.z - o.z) * r) : (a = (e.max.z - o.z) * r, e = (e.min.z - o.z) * r), s > e || a > i ? null : ((a > s || s != s) && (s = a), (e < i || i != i) && (i = e), 0 > i ? null : this.at(0 <= s ? s : i, t)))
		},
		intersectsBox: function() {
			var e = new r;
			return function(t) {
				return null !== this.intersectBox(t, e)
			}
		}(),
		intersectTriangle: function() {
			var e = new r,
				t = new r,
				i = new r,
				n = new r;
			return function(r, o, s, a, l) {
				if (t.subVectors(o, r), i.subVectors(s, r), n.crossVectors(t, i), 0 < (o = this.direction.dot(n))) {
					if (a) return null;
					a = 1
				} else {
					if (!(0 > o)) return null;
					a = -1, o = -o
				}
				return e.subVectors(this.origin, r), 0 > (r = a * this.direction.dot(i.crossVectors(e, i))) || 0 > (s = a * this.direction.dot(t.cross(e))) || r + s > o || 0 > (r = -a * e.dot(n)) ? null : this.at(r / o, l)
			}
		}(),
		applyMatrix4: function(e) {
			return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
		},
		equals: function(e) {
			return e.origin.equals(this.origin) && e.direction.equals(this.direction)
		}
	}), Object.assign(X, {
		getNormal: function() {
			var e = new r;
			return function(t, i, n, o) {
				return void 0 === o && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new r), o.subVectors(n, i), e.subVectors(t, i), o.cross(e), 0 < (t = o.lengthSq()) ? o.multiplyScalar(1 / Math.sqrt(t)) : o.set(0, 0, 0)
			}
		}(),
		getBarycoord: function() {
			var e = new r,
				t = new r,
				i = new r;
			return function(n, o, s, a, l) {
				e.subVectors(a, o), t.subVectors(s, o), i.subVectors(n, o), n = e.dot(e), o = e.dot(t), s = e.dot(i);
				var c = t.dot(t);
				a = t.dot(i);
				var h = n * c - o * o;
				return void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new r), 0 === h ? l.set(-2, -1, -1) : (c = (c * s - o * a) * (h = 1 / h), n = (n * a - o * s) * h, l.set(1 - c - n, n, c))
			}
		}(),
		containsPoint: function() {
			var e = new r;
			return function(t, i, n, r) {
				return X.getBarycoord(t, i, n, r, e), 0 <= e.x && 0 <= e.y && 1 >= e.x + e.y
			}
		}(),
		getUV: function() {
			var e = new r;
			return function(t, i, n, r, o, s, a, l) {
				return this.getBarycoord(t, i, n, r, e), l.set(0, 0), l.addScaledVector(o, e.x), l.addScaledVector(s, e.y), l.addScaledVector(a, e.z), l
			}
		}(),
		isFrontFacing: function() {
			var e = new r,
				t = new r;
			return function(i, n, r, o) {
				return e.subVectors(r, n), t.subVectors(i, n), 0 > e.cross(t).dot(o)
			}
		}()
	}), Object.assign(X.prototype, {
		set: function(e, t, i) {
			return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
		},
		setFromPointsAndIndices: function(e, t, i, n) {
			return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
		},
		getArea: function() {
			var e = new r,
				t = new r;
			return function() {
				return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
			}
		}(),
		getMidpoint: function(e) {
			return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new r), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
		},
		getNormal: function(e) {
			return X.getNormal(this.a, this.b, this.c, e)
		},
		getPlane: function(e) {
			return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new r), e.setFromCoplanarPoints(this.a, this.b, this.c)
		},
		getBarycoord: function(e, t) {
			return X.getBarycoord(e, this.a, this.b, this.c, t)
		},
		getUV: function(e, t, i, n, r) {
			return X.getUV(e, this.a, this.b, this.c, t, i, n, r)
		},
		containsPoint: function(e) {
			return X.containsPoint(e, this.a, this.b, this.c)
		},
		isFrontFacing: function(e) {
			return X.isFrontFacing(this.a, this.b, this.c, e)
		},
		intersectsBox: function(e) {
			return e.intersectsTriangle(this)
		},
		closestPointToPoint: function() {
			var e = new r,
				t = new r,
				i = new r,
				n = new r,
				o = new r,
				s = new r;
			return function(a, l) {
				void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new r);
				var c = this.a,
					h = this.b,
					u = this.c;
				e.subVectors(h, c), t.subVectors(u, c), n.subVectors(a, c);
				var d = e.dot(n),
					p = t.dot(n);
				if (0 >= d && 0 >= p) return l.copy(c);
				o.subVectors(a, h);
				var f = e.dot(o),
					m = t.dot(o);
				if (0 <= f && m <= f) return l.copy(h);
				var g = d * m - f * p;
				if (0 >= g && 0 <= d && 0 >= f) return h = d / (d - f), l.copy(c).addScaledVector(e, h);
				s.subVectors(a, u), a = e.dot(s);
				var v = t.dot(s);
				return 0 <= v && a <= v ? l.copy(u) : 0 >= (d = a * p - d * v) && 0 <= p && 0 >= v ? (g = p / (p - v), l.copy(c).addScaledVector(t, g)) : 0 >= (p = f * v - a * m) && 0 <= m - f && 0 <= a - v ? (i.subVectors(u, h), g = (m - f) / (m - f + (a - v)), l.copy(h).addScaledVector(i, g)) : (h = d * (u = 1 / (p + d + g)), g *= u, l.copy(c).addScaledVector(e, h).addScaledVector(t, g))
			}
		}(),
		equals: function(e) {
			return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
		}
	}), Y.prototype = Object.create(V.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
	}, Z.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Z,
		isMesh: !0,
		setDrawMode: function(e) {
			this.drawMode = e
		},
		copy: function(e) {
			return S.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
		},
		updateMorphTargets: function() {
			var e = this.geometry;
			if (e.isBufferGeometry) {
				e = e.morphAttributes;
				var t = Object.keys(e);
				if (0 < t.length) {
					var i = e[t[0]];
					if (void 0 !== i)
						for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = i.length; e < t; e++) {
							var n = i[e].name || String(e);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
						}
				}
			} else void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
		},
		raycast: function() {
			function e(e, t, i, n, r, o, s, a) {
				return null === (1 === t.side ? n.intersectTriangle(s, o, r, !0, a) : n.intersectTriangle(r, o, s, 2 !== t.side, a)) ? null : (E.copy(a), E.applyMatrix4(e.matrixWorld), (t = i.ray.origin.distanceTo(E)) < i.near || t > i.far ? null : {
					distance: t,
					point: E.clone(),
					object: e
				})
			}

			function t(t, n, r, o, s, p, g, E, M, S) {
				if (a.fromBufferAttribute(s, E), l.fromBufferAttribute(s, M), c.fromBufferAttribute(s, S), s = t.morphTargetInfluences, n.morphTargets && p && s) {
					f.set(0, 0, 0), m.set(0, 0, 0), v.set(0, 0, 0);
					for (var T = 0, A = p.length; T < A; T++) {
						var L = s[T],
							C = p[T];
						0 !== L && (h.fromBufferAttribute(C, E), u.fromBufferAttribute(C, M), d.fromBufferAttribute(C, S), f.addScaledVector(h.sub(a), L), m.addScaledVector(u.sub(l), L), v.addScaledVector(d.sub(c), L))
					}
					a.add(f), l.add(m), c.add(v)
				}
				return (t = e(t, n, r, o, a, l, c, x)) && (g && (y.fromBufferAttribute(g, E), b.fromBufferAttribute(g, M), w.fromBufferAttribute(g, S), t.uv = X.getUV(x, a, l, c, y, b, w, new i)), g = new _(E, M, S), X.getNormal(a, l, c, g.normal), t.face = g), t
			}
			var n = new g,
				o = new q,
				s = new p,
				a = new r,
				l = new r,
				c = new r,
				h = new r,
				u = new r,
				d = new r,
				f = new r,
				m = new r,
				v = new r,
				y = new i,
				b = new i,
				w = new i,
				x = new r,
				E = new r;
			return function(r, a) {
				var l = this.geometry,
					c = this.material,
					h = this.matrixWorld;
				if (void 0 !== c && (null === l.boundingSphere && l.computeBoundingSphere(), s.copy(l.boundingSphere), s.applyMatrix4(h), !1 !== r.ray.intersectsSphere(s) && (n.getInverse(h), o.copy(r.ray).applyMatrix4(n), null === l.boundingBox || !1 !== o.intersectsBox(l.boundingBox))))
					if (l.isBufferGeometry) {
						var u = l.index;
						h = l.attributes.position;
						var d, p, f = l.morphAttributes.position,
							m = l.attributes.uv,
							g = l.groups,
							v = l.drawRange;
						if (null !== u)
							if (Array.isArray(c)) {
								var _ = 0;
								for (d = g.length; _ < d; _++) {
									var E = g[_],
										M = c[E.materialIndex],
										S = Math.max(E.start, v.start);
									for (p = l = Math.min(E.start + E.count, v.start + v.count); S < p; S += 3) {
										l = u.getX(S);
										var T = u.getX(S + 1),
											A = u.getX(S + 2);
										(l = t(this, M, r, o, h, f, m, l, T, A)) && (l.faceIndex = Math.floor(S / 3), l.face.materialIndex = E.materialIndex, a.push(l))
									}
								}
							} else
								for (_ = S = Math.max(0, v.start), d = l = Math.min(u.count, v.start + v.count); _ < d; _ += 3) l = u.getX(_), T = u.getX(_ + 1), A = u.getX(_ + 2), (l = t(this, c, r, o, h, f, m, l, T, A)) && (l.faceIndex = Math.floor(_ / 3), a.push(l));
						else if (void 0 !== h)
							if (Array.isArray(c))
								for (_ = 0, d = g.length; _ < d; _++)
									for (M = c[(E = g[_]).materialIndex], S = Math.max(E.start, v.start), p = l = Math.min(E.start + E.count, v.start + v.count); S < p; S += 3)(l = t(this, M, r, o, h, f, m, l = S, T = S + 1, A = S + 2)) && (l.faceIndex = Math.floor(S / 3), l.face.materialIndex = E.materialIndex, a.push(l));
							else
								for (_ = S = Math.max(0, v.start), d = l = Math.min(h.count, v.start + v.count); _ < d; _ += 3)(l = t(this, c, r, o, h, f, m, l = _, T = _ + 1, A = _ + 2)) && (l.faceIndex = Math.floor(_ / 3), a.push(l))
					} else if (l.isGeometry)
					for (h = Array.isArray(c), f = l.vertices, m = l.faces, 0 < (l = l.faceVertexUvs[0]).length && (u = l), d = 0, E = m.length; d < E; d++) M = m[d], void 0 !== (l = h ? c[M.materialIndex] : c) && (g = f[M.a], v = f[M.b], _ = f[M.c], l = e(this, l, r, o, g, v, _, x)) && (u && u[d] && (S = u[d], y.copy(S[0]), b.copy(S[1]), w.copy(S[2]), l.uv = X.getUV(x, g, v, _, y, b, w, new i)), l.face = M, l.faceIndex = d, a.push(l))
			}
		}(),
		clone: function() {
			return new this.constructor(this.geometry, this.material).copy(this)
		}
	}), ae.prototype = Object.create(s.prototype), ae.prototype.constructor = ae, ae.prototype.isCubeTexture = !0, Object.defineProperty(ae.prototype, "images", {
		get: function() {
			return this.image
		},
		set: function(e) {
			this.image = e
		}
	}), le.prototype = Object.create(s.prototype), le.prototype.constructor = le, le.prototype.isDataTexture2DArray = !0, ce.prototype = Object.create(s.prototype), ce.prototype.constructor = ce, ce.prototype.isDataTexture3D = !0;
	var So = new s,
		To = new le,
		Ao = new ce,
		Lo = new ae,
		Co = [],
		Po = [],
		Io = new Float32Array(16),
		Ro = new Float32Array(9),
		Oo = new Float32Array(4);
	Ge.prototype.updateCache = function(e) {
		var t = this.cache;
		e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), de(t, e)
	}, Ve.prototype.setValue = function(e, t, i) {
		for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
			var s = n[r];
			s.setValue(e, t[s.id], i)
		}
	};
	var Do = /([\w\d_]+)(\])?(\[|\.)?/g;
	We.prototype.setValue = function(e, t, i, n) {
		void 0 !== (t = this.map[t]) && t.setValue(e, i, n)
	}, We.prototype.setOptional = function(e, t, i) {
		void 0 !== (t = t[i]) && this.setValue(e, i, t)
	}, We.upload = function(e, t, i, n) {
		for (var r = 0, o = t.length; r !== o; ++r) {
			var s = t[r],
				a = i[s.id];
			!1 !== a.needsUpdate && s.setValue(e, a.value, n)
		}
	}, We.seqWithValue = function(e, t) {
		for (var i = [], n = 0, r = e.length; n !== r; ++n) {
			var o = e[n];
			o.id in t && i.push(o)
		}
		return i
	};
	var zo = 0,
		ko = 0;
	pt.prototype = Object.create(V.prototype), pt.prototype.constructor = pt, pt.prototype.isMeshDepthMaterial = !0, pt.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
	}, ft.prototype = Object.create(V.prototype), ft.prototype.constructor = ft, ft.prototype.isMeshDistanceMaterial = !0, ft.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
	}, bt.prototype = Object.assign(Object.create(S.prototype), {
		constructor: bt,
		isGroup: !0
	}), wt.prototype = Object.assign(Object.create(S.prototype), {
		constructor: wt,
		isCamera: !0,
		copy: function(e, t) {
			return S.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
		},
		getWorldDirection: function(e) {
			void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new r), this.updateMatrixWorld(!0);
			var t = this.matrixWorld.elements;
			return e.set(-t[8], -t[9], -t[10]).normalize()
		},
		updateMatrixWorld: function(e) {
			S.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		}
	}), xt.prototype = Object.assign(Object.create(wt.prototype), {
		constructor: xt,
		isPerspectiveCamera: !0,
		copy: function(e, t) {
			return wt.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
		},
		setFocalLength: function(e) {
			e = .5 * this.getFilmHeight() / e, this.fov = 2 * uo.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
		},
		getFocalLength: function() {
			var e = Math.tan(.5 * uo.DEG2RAD * this.fov);
			return .5 * this.getFilmHeight() / e
		},
		getEffectiveFOV: function() {
			return 2 * uo.RAD2DEG * Math.atan(Math.tan(.5 * uo.DEG2RAD * this.fov) / this.zoom)
		},
		getFilmWidth: function() {
			return this.filmGauge * Math.min(this.aspect, 1)
		},
		getFilmHeight: function() {
			return this.filmGauge / Math.max(this.aspect, 1)
		},
		setViewOffset: function(e, t, i, n, r, o) {
			this.aspect = e / t, null === this.view && (this.view = {
				enabled: !0,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
		},
		clearViewOffset: function() {
			null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
		},
		updateProjectionMatrix: function() {
			var e = this.near,
				t = e * Math.tan(.5 * uo.DEG2RAD * this.fov) / this.zoom,
				i = 2 * t,
				n = this.aspect * i,
				r = -.5 * n,
				o = this.view;
			if (null !== this.view && this.view.enabled) {
				var s = o.fullWidth,
					a = o.fullHeight;
				r += o.offsetX * n / s, t -= o.offsetY * i / a, n *= o.width / s, i *= o.height / a
			}
			0 !== (o = this.filmOffset) && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
		},
		toJSON: function(e) {
			return (e = S.prototype.toJSON.call(this, e)).object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
		}
	}), _t.prototype = Object.assign(Object.create(xt.prototype), {
		constructor: _t,
		isArrayCamera: !0
	});
	var No, Bo = new r,
		Ho = new r;
	Object.assign(At.prototype, {
		isFogExp2: !0,
		clone: function() {
			return new At(this.color, this.density)
		},
		toJSON: function() {
			return {
				type: "FogExp2",
				color: this.color.getHex(),
				density: this.density
			}
		}
	}), Object.assign(Lt.prototype, {
		isFog: !0,
		clone: function() {
			return new Lt(this.color, this.near, this.far)
		},
		toJSON: function() {
			return {
				type: "Fog",
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			}
		}
	}), Ct.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Ct,
		isScene: !0,
		copy: function(e, t) {
			return S.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
		},
		toJSON: function(e) {
			var t = S.prototype.toJSON.call(this, e);
			return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	}), Object.defineProperty(Pt.prototype, "needsUpdate", {
		set: function(e) {
			!0 === e && this.version++
		}
	}), Object.assign(Pt.prototype, {
		isInterleavedBuffer: !0,
		onUploadCallback: function() {},
		setArray: function(e) {
			if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
			return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
		},
		setDynamic: function(e) {
			return this.dynamic = e, this
		},
		copy: function(e) {
			return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
		},
		copyAt: function(e, t, i) {
			e *= this.stride, i *= t.stride;
			for (var n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
			return this
		},
		set: function(e, t) {
			return void 0 === t && (t = 0), this.array.set(e, t), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		onUpload: function(e) {
			return this.onUploadCallback = e, this
		}
	}), Object.defineProperties(It.prototype, {
		count: {
			get: function() {
				return this.data.count
			}
		},
		array: {
			get: function() {
				return this.data.array
			}
		}
	}), Object.assign(It.prototype, {
		isInterleavedBufferAttribute: !0,
		setX: function(e, t) {
			return this.data.array[e * this.data.stride + this.offset] = t, this
		},
		setY: function(e, t) {
			return this.data.array[e * this.data.stride + this.offset + 1] = t, this
		},
		setZ: function(e, t) {
			return this.data.array[e * this.data.stride + this.offset + 2] = t, this
		},
		setW: function(e, t) {
			return this.data.array[e * this.data.stride + this.offset + 3] = t, this
		},
		getX: function(e) {
			return this.data.array[e * this.data.stride + this.offset]
		},
		getY: function(e) {
			return this.data.array[e * this.data.stride + this.offset + 1]
		},
		getZ: function(e) {
			return this.data.array[e * this.data.stride + this.offset + 2]
		},
		getW: function(e) {
			return this.data.array[e * this.data.stride + this.offset + 3]
		},
		setXY: function(e, t, i) {
			return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
		},
		setXYZ: function(e, t, i, n) {
			return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
		},
		setXYZW: function(e, t, i, n, r) {
			return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
		}
	}), Rt.prototype = Object.create(V.prototype), Rt.prototype.constructor = Rt, Rt.prototype.isSpriteMaterial = !0, Rt.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
	}, Ot.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Ot,
		isSprite: !0,
		raycast: function() {
			function e(e, t, i, n, r, o) {
				s.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (a.x = o * s.x - r * s.y, a.y = r * s.x + o * s.y) : a.copy(s), e.copy(t), e.x += a.x, e.y += a.y, e.applyMatrix4(l)
			}
			var t = new r,
				n = new r,
				o = new r,
				s = new i,
				a = new i,
				l = new g,
				c = new r,
				h = new r,
				u = new r,
				d = new i,
				p = new i,
				f = new i;
			return function(r, s) {
				n.setFromMatrixScale(this.matrixWorld), l.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
				var a = this.material.rotation;
				if (0 !== a) var m = Math.cos(a),
					g = Math.sin(a);
				a = this.center, e(c.set(-.5, -.5, 0), o, a, n, g, m), e(h.set(.5, -.5, 0), o, a, n, g, m), e(u.set(.5, .5, 0), o, a, n, g, m), d.set(0, 0), p.set(1, 0), f.set(1, 1);
				var v = r.ray.intersectTriangle(c, h, u, !1, t);
				null === v && (e(h.set(-.5, .5, 0), o, a, n, g, m), p.set(0, 1), null === (v = r.ray.intersectTriangle(c, u, h, !1, t))) || (g = r.ray.origin.distanceTo(t)) < r.near || g > r.far || s.push({
					distance: g,
					point: t.clone(),
					uv: X.getUV(t, c, h, u, d, p, f, new i),
					face: null,
					object: this
				})
			}
		}(),
		clone: function() {
			return new this.constructor(this.material).copy(this)
		},
		copy: function(e) {
			return S.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
		}
	}), Dt.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Dt,
		isLOD: !0,
		copy: function(e) {
			S.prototype.copy.call(this, e, !1);
			for (var t = 0, i = (e = e.levels).length; t < i; t++) {
				var n = e[t];
				this.addLevel(n.object.clone(), n.distance)
			}
			return this
		},
		addLevel: function(e, t) {
			void 0 === t && (t = 0), t = Math.abs(t);
			for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++);
			return i.splice(n, 0, {
				distance: t,
				object: e
			}), this.add(e), this
		},
		getObjectForDistance: function(e) {
			for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++);
			return t[i - 1].object
		},
		raycast: function() {
			var e = new r;
			return function(t, i) {
				e.setFromMatrixPosition(this.matrixWorld);
				var n = t.ray.origin.distanceTo(e);
				this.getObjectForDistance(n).raycast(t, i)
			}
		}(),
		update: function() {
			var e = new r,
				t = new r;
			return function(i) {
				var n = this.levels;
				if (1 < n.length) {
					e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld), i = e.distanceTo(t), n[0].object.visible = !0;
					for (var r = 1, o = n.length; r < o && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
					for (; r < o; r++) n[r].object.visible = !1
				}
			}
		}(),
		toJSON: function(e) {
			(e = S.prototype.toJSON.call(this, e)).object.levels = [];
			for (var t = this.levels, i = 0, n = t.length; i < n; i++) {
				var r = t[i];
				e.object.levels.push({
					object: r.object.uuid,
					distance: r.distance
				})
			}
			return e
		}
	}), zt.prototype = Object.assign(Object.create(Z.prototype), {
		constructor: zt,
		isSkinnedMesh: !0,
		bind: function(e, t) {
			this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
		},
		pose: function() {
			this.skeleton.pose()
		},
		normalizeSkinWeights: function() {
			for (var e = new a, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) {
				e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i);
				var r = 1 / e.manhattanLength();
				1 / 0 !== r ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
			}
		},
		updateMatrixWorld: function(e) {
			Z.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
		},
		clone: function() {
			return new this.constructor(this.geometry, this.material).copy(this)
		}
	}), Object.assign(kt.prototype, {
		calculateInverses: function() {
			this.boneInverses = [];
			for (var e = 0, t = this.bones.length; e < t; e++) {
				var i = new g;
				this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
			}
		},
		pose: function() {
			var e, t, i = 0;
			for (t = this.bones.length; i < t; i++)(e = this.bones[i]) && e.matrixWorld.getInverse(this.boneInverses[i]);
			for (i = 0, t = this.bones.length; i < t; i++)(e = this.bones[i]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
		},
		update: function() {
			var e = new g,
				t = new g;
			return function() {
				for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, s = 0, a = i.length; s < a; s++) e.multiplyMatrices(i[s] ? i[s].matrixWorld : t, n[s]), e.toArray(r, 16 * s);
				void 0 !== o && (o.needsUpdate = !0)
			}
		}(),
		clone: function() {
			return new kt(this.bones, this.boneInverses)
		},
		getBoneByName: function(e) {
			for (var t = 0, i = this.bones.length; t < i; t++) {
				var n = this.bones[t];
				if (n.name === e) return n
			}
		}
	}), Nt.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Nt,
		isBone: !0
	}), Bt.prototype = Object.create(V.prototype), Bt.prototype.constructor = Bt, Bt.prototype.isLineBasicMaterial = !0, Bt.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
	}, Ht.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Ht,
		isLine: !0,
		computeLineDistances: function() {
			var e = new r,
				t = new r;
			return function() {
				var i = this.geometry;
				if (i.isBufferGeometry)
					if (null === i.index) {
						for (var n = i.attributes.position, r = [0], o = 1, s = n.count; o < s; o++) e.fromBufferAttribute(n, o - 1), t.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += e.distanceTo(t);
						i.addAttribute("lineDistance", new z(r, 1))
					} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				else if (i.isGeometry)
					for (n = i.vertices, (r = i.lineDistances)[0] = 0, o = 1, s = n.length; o < s; o++) r[o] = r[o - 1], r[o] += n[o - 1].distanceTo(n[o]);
				return this
			}
		}(),
		raycast: function() {
			var e = new g,
				t = new q,
				i = new p;
			return function(n, o) {
				var s = n.linePrecision,
					a = this.geometry,
					l = this.matrixWorld;
				if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(l), i.radius += s, !1 !== n.ray.intersectsSphere(i)) {
					e.getInverse(l), t.copy(n.ray).applyMatrix4(e), s /= (this.scale.x + this.scale.y + this.scale.z) / 3, s *= s;
					var c = new r,
						h = new r;
					l = new r;
					var u = new r,
						d = this && this.isLineSegments ? 2 : 1;
					if (a.isBufferGeometry) {
						var p = a.index,
							f = a.attributes.position.array;
						if (null !== p) {
							a = 0;
							for (var m = (p = p.array).length - 1; a < m; a += d) {
								var g = p[a + 1];
								c.fromArray(f, 3 * p[a]), h.fromArray(f, 3 * g), (g = t.distanceSqToSegment(c, h, u, l)) > s || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
									distance: g,
									point: l.clone().applyMatrix4(this.matrixWorld),
									index: a,
									face: null,
									faceIndex: null,
									object: this
								}))
							}
						} else
							for (a = 0, m = f.length / 3 - 1; a < m; a += d) c.fromArray(f, 3 * a), h.fromArray(f, 3 * a + 3), (g = t.distanceSqToSegment(c, h, u, l)) > s || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
								distance: g,
								point: l.clone().applyMatrix4(this.matrixWorld),
								index: a,
								face: null,
								faceIndex: null,
								object: this
							}))
					} else if (a.isGeometry)
						for (h = (c = a.vertices).length, a = 0; a < h - 1; a += d)(g = t.distanceSqToSegment(c[a], c[a + 1], u, l)) > s || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({
							distance: g,
							point: l.clone().applyMatrix4(this.matrixWorld),
							index: a,
							face: null,
							faceIndex: null,
							object: this
						}))
				}
			}
		}(),
		clone: function() {
			return new this.constructor(this.geometry, this.material).copy(this)
		}
	}), Ft.prototype = Object.assign(Object.create(Ht.prototype), {
		constructor: Ft,
		isLineSegments: !0,
		computeLineDistances: function() {
			var e = new r,
				t = new r;
			return function() {
				var i = this.geometry;
				if (i.isBufferGeometry)
					if (null === i.index) {
						for (var n = i.attributes.position, r = [], o = 0, s = n.count; o < s; o += 2) e.fromBufferAttribute(n, o), t.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
						i.addAttribute("lineDistance", new z(r, 1))
					} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				else if (i.isGeometry)
					for (n = i.vertices, r = i.lineDistances, o = 0, s = n.length; o < s; o += 2) e.copy(n[o]), t.copy(n[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + e.distanceTo(t);
				return this
			}
		}()
	}), Ut.prototype = Object.assign(Object.create(Ht.prototype), {
		constructor: Ut,
		isLineLoop: !0
	}), jt.prototype = Object.create(V.prototype), jt.prototype.constructor = jt, jt.prototype.isPointsMaterial = !0, jt.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
	}, Gt.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Gt,
		isPoints: !0,
		raycast: function() {
			var e = new g,
				t = new q,
				i = new p;
			return function(n, o) {
				function s(e, i) {
					var r = t.distanceSqToPoint(e);
					r < u && (t.closestPointToPoint(e, d), d.applyMatrix4(c), (e = n.ray.origin.distanceTo(d)) < n.near || e > n.far || o.push({
						distance: e,
						distanceToRay: Math.sqrt(r),
						point: d.clone(),
						index: i,
						face: null,
						object: a
					}))
				}
				var a = this,
					l = this.geometry,
					c = this.matrixWorld,
					h = n.params.Points.threshold;
				if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), i.radius += h, !1 !== n.ray.intersectsSphere(i)) {
					e.getInverse(c), t.copy(n.ray).applyMatrix4(e);
					var u = (h /= (this.scale.x + this.scale.y + this.scale.z) / 3) * h;
					h = new r;
					var d = new r;
					if (l.isBufferGeometry) {
						var p = l.index;
						if (l = l.attributes.position.array, null !== p) {
							var f = p.array;
							p = 0;
							for (var m = f.length; p < m; p++) {
								var g = f[p];
								h.fromArray(l, 3 * g), s(h, g)
							}
						} else
							for (p = 0, f = l.length / 3; p < f; p++) h.fromArray(l, 3 * p), s(h, p)
					} else
						for (p = 0, f = (h = l.vertices).length; p < f; p++) s(h[p], p)
				}
			}
		}(),
		clone: function() {
			return new this.constructor(this.geometry, this.material).copy(this)
		}
	}), Vt.prototype = Object.assign(Object.create(s.prototype), {
		constructor: Vt,
		isVideoTexture: !0,
		update: function() {
			var e = this.image;
			e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
		}
	}), Wt.prototype = Object.create(s.prototype), Wt.prototype.constructor = Wt, Wt.prototype.isCompressedTexture = !0, qt.prototype = Object.create(s.prototype), qt.prototype.constructor = qt, qt.prototype.isCanvasTexture = !0, Xt.prototype = Object.create(s.prototype), Xt.prototype.constructor = Xt, Xt.prototype.isDepthTexture = !0, Yt.prototype = Object.create(H.prototype), Yt.prototype.constructor = Yt, Zt.prototype = Object.create(T.prototype), Zt.prototype.constructor = Zt, Qt.prototype = Object.create(H.prototype), Qt.prototype.constructor = Qt, Jt.prototype = Object.create(T.prototype), Jt.prototype.constructor = Jt, Kt.prototype = Object.create(H.prototype), Kt.prototype.constructor = Kt, $t.prototype = Object.create(T.prototype), $t.prototype.constructor = $t, ei.prototype = Object.create(Kt.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(T.prototype), ti.prototype.constructor = ti, ii.prototype = Object.create(Kt.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(T.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(Kt.prototype), ri.prototype.constructor = ri, oi.prototype = Object.create(T.prototype), oi.prototype.constructor = oi, si.prototype = Object.create(Kt.prototype), si.prototype.constructor = si, ai.prototype = Object.create(T.prototype), ai.prototype.constructor = ai, li.prototype = Object.create(H.prototype), li.prototype.constructor = li, li.prototype.toJSON = function() {
		var e = H.prototype.toJSON.call(this);
		return e.path = this.parameters.path.toJSON(), e
	}, ci.prototype = Object.create(T.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(H.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(T.prototype), ui.prototype.constructor = ui, di.prototype = Object.create(H.prototype), di.prototype.constructor = di;
	var Fo = {
		area: function(e) {
			for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
			return .5 * i
		},
		isClockWise: function(e) {
			return 0 > Fo.area(e)
		},
		triangulateShape: function(e, t) {
			var i = [],
				n = [],
				r = [];
			Li(e), Ci(i, e);
			var o = e.length;
			for (t.forEach(Li), e = 0; e < t.length; e++) n.push(o), o += t[e].length, Ci(i, t[e]);
			for (t = function(e, t, i) {
					i = i || 2;
					var n, r = t && t.length,
						o = r ? t[0] * i : e.length,
						s = pi(e, 0, o, i, !0),
						a = [];
					if (!s) return a;
					if (r) {
						var l, c = i;
						r = [];
						var h = 0;
						for (l = t.length; h < l; h++) {
							var u = t[h] * c;
							(u = pi(e, u, h < l - 1 ? t[h + 1] * c : e.length, c, !1)) === u.next && (u.steiner = !0), r.push(yi(u))
						}
						for (r.sort(mi), h = 0; h < r.length; h++)(c = gi(t = r[h], c = s)) && fi(t = Mi(c, t), t.next), s = fi(s, s.next)
					}
					if (e.length > 80 * i) {
						var d = n = e[0],
							p = r = e[1];
						for (c = i; c < o; c += i)(h = e[c]) < d && (d = h), (t = e[c + 1]) < p && (p = t), h > n && (n = h), t > r && (r = t);
						n = 0 !== (n = Math.max(n - d, r - p)) ? 1 / n : 0
					}
					return function e(t, i, n, r, o, s, a) {
						if (t) {
							if (!a && s) {
								var l = t,
									c = l;
								do {
									null === c.z && (c.z = vi(c.x, c.y, r, o, s)), c.prevZ = c.prev, c = c.nextZ = c.next
								} while (c !== l);
								c.prevZ.nextZ = null, c.prevZ = null, l = c;
								var h, u, d, p, f = 1;
								do {
									c = l;
									var m = l = null;
									for (u = 0; c;) {
										u++;
										var g = c;
										for (h = d = 0; h < f && (d++, g = g.nextZ); h++);
										for (p = f; 0 < d || 0 < p && g;) 0 !== d && (0 === p || !g || c.z <= g.z) ? (h = c, c = c.nextZ, d--) : (h = g, g = g.nextZ, p--), m ? m.nextZ = h : l = h, h.prevZ = m, m = h;
										c = g
									}
									m.nextZ = null, f *= 2
								} while (1 < u)
							}
							for (l = t; t.prev !== t.next;) {
								if (c = t.prev, g = t.next, s) e: {
									p = r;
									var v = o,
										y = s;
									if (0 <= wi(u = (m = t).prev, d = m, f = m.next)) m = !1;
									else {
										var b = u.x > d.x ? u.x > f.x ? u.x : f.x : d.x > f.x ? d.x : f.x,
											w = u.y > d.y ? u.y > f.y ? u.y : f.y : d.y > f.y ? d.y : f.y;
										for (h = vi(u.x < d.x ? u.x < f.x ? u.x : f.x : d.x < f.x ? d.x : f.x, u.y < d.y ? u.y < f.y ? u.y : f.y : d.y < f.y ? d.y : f.y, p, v, y), p = vi(b, w, p, v, y), v = m.nextZ; v && v.z <= p;) {
											if (v !== m.prev && v !== m.next && bi(u.x, u.y, d.x, d.y, f.x, f.y, v.x, v.y) && 0 <= wi(v.prev, v, v.next)) {
												m = !1;
												break e
											}
											v = v.nextZ
										}
										for (v = m.prevZ; v && v.z >= h;) {
											if (v !== m.prev && v !== m.next && bi(u.x, u.y, d.x, d.y, f.x, f.y, v.x, v.y) && 0 <= wi(v.prev, v, v.next)) {
												m = !1;
												break e
											}
											v = v.prevZ
										}
										m = !0
									}
								}
								else e: if (m = t, u = m.prev, d = m, f = m.next, 0 <= wi(u, d, f)) m = !1;
									else {
										for (h = m.next.next; h !== m.prev;) {
											if (bi(u.x, u.y, d.x, d.y, f.x, f.y, h.x, h.y) && 0 <= wi(h.prev, h, h.next)) {
												m = !1;
												break e
											}
											h = h.next
										}
										m = !0
									} if (m) i.push(c.i / n), i.push(t.i / n), i.push(g.i / n), Ti(t), l = t = g.next;
								else if ((t = g) === l) {
									if (a) {
										if (1 === a) {
											a = i, l = n, c = t;
											do {
												!xi(g = c.prev, m = c.next.next) && _i(g, c, c.next, m) && Ei(g, m) && Ei(m, g) && (a.push(g.i / l), a.push(c.i / l), a.push(m.i / l), Ti(c), Ti(c.next), c = t = m), c = c.next
											} while (c !== t);
											e(t = c, i, n, r, o, s, 2)
										} else if (2 === a) e: {
											a = t;do {
												for (l = a.next.next; l !== a.prev;) {
													if (c = a.i !== l.i) {
														if (g = l, m = (c = a).next.i !== g.i && c.prev.i !== g.i) {
															t: {
																m = c;do {
																	if (m.i !== c.i && m.next.i !== c.i && m.i !== g.i && m.next.i !== g.i && _i(m, m.next, c, g)) {
																		m = !0;
																		break t
																	}
																	m = m.next
																} while (m !== c);m = !1
															}
															m = !m
														}
														if (m = m && Ei(c, g) && Ei(g, c)) {
															m = c, u = !1, d = (c.x + g.x) / 2, g = (c.y + g.y) / 2;
															do {
																m.y > g != m.next.y > g && m.next.y !== m.y && d < (m.next.x - m.x) * (g - m.y) / (m.next.y - m.y) + m.x && (u = !u), m = m.next
															} while (m !== c);
															m = u
														}
														c = m
													}
													if (c) {
														t = Mi(a, l), a = fi(a, a.next), t = fi(t, t.next), e(a, i, n, r, o, s), e(t, i, n, r, o, s);
														break e
													}
													l = l.next
												}
												a = a.next
											} while (a !== t)
										}
									} else e(fi(t), i, n, r, o, s, 1);
									break
								}
							}
						}
					}(s, a, i, d, p, n), a
				}(i, n), e = 0; e < t.length; e += 3) r.push(t.slice(e, e + 3));
			return r
		}
	};
	Pi.prototype = Object.create(T.prototype), Pi.prototype.constructor = Pi, Pi.prototype.toJSON = function() {
		var e = T.prototype.toJSON.call(this);
		return Ri(this.parameters.shapes, this.parameters.options, e)
	}, Ii.prototype = Object.create(H.prototype), Ii.prototype.constructor = Ii, Ii.prototype.toJSON = function() {
		var e = H.prototype.toJSON.call(this);
		return Ri(this.parameters.shapes, this.parameters.options, e)
	};
	var Uo = {
		generateTopUV: function(e, t, n, r, o) {
			e = t[3 * r], r = t[3 * r + 1];
			var s = t[3 * o];
			return o = t[3 * o + 1], [new i(t[3 * n], t[3 * n + 1]), new i(e, r), new i(s, o)]
		},
		generateSideWallUV: function(e, t, n, r, o, s) {
			e = t[3 * n];
			var a = t[3 * n + 1];
			n = t[3 * n + 2];
			var l = t[3 * r],
				c = t[3 * r + 1];
			r = t[3 * r + 2];
			var h = t[3 * o],
				u = t[3 * o + 1];
			o = t[3 * o + 2];
			var d = t[3 * s],
				p = t[3 * s + 1];
			return t = t[3 * s + 2], .01 > Math.abs(a - c) ? [new i(e, 1 - n), new i(l, 1 - r), new i(h, 1 - o), new i(d, 1 - t)] : [new i(a, 1 - n), new i(c, 1 - r), new i(u, 1 - o), new i(p, 1 - t)]
		}
	};
	Oi.prototype = Object.create(T.prototype), Oi.prototype.constructor = Oi, Di.prototype = Object.create(Ii.prototype), Di.prototype.constructor = Di, zi.prototype = Object.create(T.prototype), zi.prototype.constructor = zi, ki.prototype = Object.create(H.prototype), ki.prototype.constructor = ki, Ni.prototype = Object.create(T.prototype), Ni.prototype.constructor = Ni, Bi.prototype = Object.create(H.prototype), Bi.prototype.constructor = Bi, Hi.prototype = Object.create(T.prototype), Hi.prototype.constructor = Hi, Fi.prototype = Object.create(H.prototype), Fi.prototype.constructor = Fi, Ui.prototype = Object.create(T.prototype), Ui.prototype.constructor = Ui, Ui.prototype.toJSON = function() {
		var e = T.prototype.toJSON.call(this);
		return Gi(this.parameters.shapes, e)
	}, ji.prototype = Object.create(H.prototype), ji.prototype.constructor = ji, ji.prototype.toJSON = function() {
		var e = H.prototype.toJSON.call(this);
		return Gi(this.parameters.shapes, e)
	}, Vi.prototype = Object.create(H.prototype), Vi.prototype.constructor = Vi, Wi.prototype = Object.create(T.prototype), Wi.prototype.constructor = Wi, qi.prototype = Object.create(H.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(Wi.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(qi.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(T.prototype), Zi.prototype.constructor = Zi, Qi.prototype = Object.create(H.prototype), Qi.prototype.constructor = Qi;
	var jo = Object.freeze({
		WireframeGeometry: Yt,
		ParametricGeometry: Zt,
		ParametricBufferGeometry: Qt,
		TetrahedronGeometry: $t,
		TetrahedronBufferGeometry: ei,
		OctahedronGeometry: ti,
		OctahedronBufferGeometry: ii,
		IcosahedronGeometry: ni,
		IcosahedronBufferGeometry: ri,
		DodecahedronGeometry: oi,
		DodecahedronBufferGeometry: si,
		PolyhedronGeometry: Jt,
		PolyhedronBufferGeometry: Kt,
		TubeGeometry: ai,
		TubeBufferGeometry: li,
		TorusKnotGeometry: ci,
		TorusKnotBufferGeometry: hi,
		TorusGeometry: ui,
		TorusBufferGeometry: di,
		TextGeometry: Oi,
		TextBufferGeometry: Di,
		SphereGeometry: zi,
		SphereBufferGeometry: ki,
		RingGeometry: Ni,
		RingBufferGeometry: Bi,
		PlaneGeometry: j,
		PlaneBufferGeometry: G,
		LatheGeometry: Hi,
		LatheBufferGeometry: Fi,
		ShapeGeometry: Ui,
		ShapeBufferGeometry: ji,
		ExtrudeGeometry: Pi,
		ExtrudeBufferGeometry: Ii,
		EdgesGeometry: Vi,
		ConeGeometry: Xi,
		ConeBufferGeometry: Yi,
		CylinderGeometry: Wi,
		CylinderBufferGeometry: qi,
		CircleGeometry: Zi,
		CircleBufferGeometry: Qi,
		BoxGeometry: F,
		BoxBufferGeometry: U
	});
	Ji.prototype = Object.create(V.prototype), Ji.prototype.constructor = Ji, Ji.prototype.isShadowMaterial = !0, Ji.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this
	}, Ki.prototype = Object.create(W.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isRawShaderMaterial = !0, $i.prototype = Object.create(V.prototype), $i.prototype.constructor = $i, $i.prototype.isMeshStandardMaterial = !0, $i.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.defines = {
			STANDARD: ""
		}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
	}, en.prototype = Object.create($i.prototype), en.prototype.constructor = en, en.prototype.isMeshPhysicalMaterial = !0, en.prototype.copy = function(e) {
		return $i.prototype.copy.call(this, e), this.defines = {
			PHYSICAL: ""
		}, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
	}, tn.prototype = Object.create(V.prototype), tn.prototype.constructor = tn, tn.prototype.isMeshPhongMaterial = !0, tn.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
	}, nn.prototype = Object.create(tn.prototype), nn.prototype.constructor = nn, nn.prototype.isMeshToonMaterial = !0, nn.prototype.copy = function(e) {
		return tn.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
	}, rn.prototype = Object.create(V.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshNormalMaterial = !0, rn.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
	}, on.prototype = Object.create(V.prototype), on.prototype.constructor = on, on.prototype.isMeshLambertMaterial = !0, on.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
	}, sn.prototype = Object.create(V.prototype), sn.prototype.constructor = sn, sn.prototype.isMeshMatcapMaterial = !0, sn.prototype.copy = function(e) {
		return V.prototype.copy.call(this, e), this.defines = {
			MATCAP: ""
		}, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
	}, an.prototype = Object.create(Bt.prototype), an.prototype.constructor = an, an.prototype.isLineDashedMaterial = !0, an.prototype.copy = function(e) {
		return Bt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
	};
	var Go = Object.freeze({
			ShadowMaterial: Ji,
			SpriteMaterial: Rt,
			RawShaderMaterial: Ki,
			ShaderMaterial: W,
			PointsMaterial: jt,
			MeshPhysicalMaterial: en,
			MeshStandardMaterial: $i,
			MeshPhongMaterial: tn,
			MeshToonMaterial: nn,
			MeshNormalMaterial: rn,
			MeshLambertMaterial: on,
			MeshDepthMaterial: pt,
			MeshDistanceMaterial: ft,
			MeshBasicMaterial: Y,
			MeshMatcapMaterial: sn,
			LineDashedMaterial: an,
			LineBasicMaterial: Bt,
			Material: V
		}),
		Vo = {
			arraySlice: function(e, t, i) {
				return Vo.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
			},
			convertArray: function(e, t, i) {
				return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
			},
			isTypedArray: function(e) {
				return ArrayBuffer.isView(e) && !(e instanceof DataView)
			},
			getKeyframeOrder: function(e) {
				for (var t = e.length, i = Array(t), n = 0; n !== t; ++n) i[n] = n;
				return i.sort((function(t, i) {
					return e[t] - e[i]
				})), i
			},
			sortedArray: function(e, t, i) {
				for (var n = e.length, r = new e.constructor(n), o = 0, s = 0; s !== n; ++o)
					for (var a = i[o] * t, l = 0; l !== t; ++l) r[s++] = e[a + l];
				return r
			},
			flattenJSON: function(e, t, i, n) {
				for (var r = 1, o = e[0]; void 0 !== o && void 0 === o[n];) o = e[r++];
				if (void 0 !== o) {
					var s = o[n];
					if (void 0 !== s)
						if (Array.isArray(s))
							do {
								void 0 !== (s = o[n]) && (t.push(o.time), i.push.apply(i, s)), o = e[r++]
							} while (void 0 !== o);
						else if (void 0 !== s.toArray)
						do {
							void 0 !== (s = o[n]) && (t.push(o.time), s.toArray(i, i.length)), o = e[r++]
						} while (void 0 !== o);
					else
						do {
							void 0 !== (s = o[n]) && (t.push(o.time), i.push(s)), o = e[r++]
						} while (void 0 !== o)
				}
			}
		};
	Object.assign(ln.prototype, {
		evaluate: function(e) {
			var t = this.parameterPositions,
				i = this._cachedIndex,
				n = t[i],
				r = t[i - 1];
			e: {
				t: {
					i: {
						n: if (!(e < n)) {
							for (var o = i + 2;;) {
								if (void 0 === n) {
									if (e < r) break n;
									return this._cachedIndex = i = t.length, this.afterEnd_(i - 1, e, r)
								}
								if (i === o) break;
								if (r = n, e < (n = t[++i])) break t
							}
							n = t.length;
							break i
						}if (e >= r) break e;
						for (e < (o = t[1]) && (i = 2, r = o), o = i - 2;;) {
							if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
							if (i === o) break;
							if (n = r, e >= (r = t[--i - 1])) break t
						}
						n = i,
						i = 0
					}
					for (; i < n;) e < t[r = i + n >>> 1] ? n = r : i = r + 1;
					if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0,
					this.beforeStart_(0, e, n);
					if (void 0 === n) return this._cachedIndex = i = t.length,
					this.afterEnd_(i - 1, r, e)
				}
				this._cachedIndex = i,
				this.intervalChanged_(i, r, n)
			}
			return this.interpolate_(i, r, e, n)
		},
		settings: null,
		DefaultSettings_: {},
		getSettings_: function() {
			return this.settings || this.DefaultSettings_
		},
		copySampleValue_: function(e) {
			var t = this.resultBuffer,
				i = this.sampleValues,
				n = this.valueSize;
			e *= n;
			for (var r = 0; r !== n; ++r) t[r] = i[e + r];
			return t
		},
		interpolate_: function() {
			throw Error("call to abstract method")
		},
		intervalChanged_: function() {}
	}), Object.assign(ln.prototype, {
		beforeStart_: ln.prototype.copySampleValue_,
		afterEnd_: ln.prototype.copySampleValue_
	}), cn.prototype = Object.assign(Object.create(ln.prototype), {
		constructor: cn,
		DefaultSettings_: {
			endingStart: 2400,
			endingEnd: 2400
		},
		intervalChanged_: function(e, t, i) {
			var n = this.parameterPositions,
				r = e - 2,
				o = e + 1,
				s = n[r],
				a = n[o];
			if (void 0 === s) switch (this.getSettings_().endingStart) {
				case 2401:
					r = e, s = 2 * t - i;
					break;
				case 2402:
					s = t + n[r = n.length - 2] - n[r + 1];
					break;
				default:
					r = e, s = i
			}
			if (void 0 === a) switch (this.getSettings_().endingEnd) {
				case 2401:
					o = e, a = 2 * i - t;
					break;
				case 2402:
					o = 1, a = i + n[1] - n[0];
					break;
				default:
					o = e - 1, a = t
			}
			e = .5 * (i - t), n = this.valueSize, this._weightPrev = e / (t - s), this._weightNext = e / (a - i), this._offsetPrev = r * n, this._offsetNext = o * n
		},
		interpolate_: function(e, t, i, n) {
			var r = this.resultBuffer,
				o = this.sampleValues,
				s = this.valueSize,
				a = (e *= s) - s,
				l = this._offsetPrev,
				c = this._offsetNext,
				h = this._weightPrev,
				u = this._weightNext,
				d = (i - t) / (n - t);
			for (t = -h * (n = (i = d * d) * d) + 2 * h * i - h * d, h = (1 + h) * n + (-1.5 - 2 * h) * i + (-.5 + h) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== s; ++i) r[i] = t * o[l + i] + h * o[a + i] + d * o[e + i] + u * o[c + i];
			return r
		}
	}), hn.prototype = Object.assign(Object.create(ln.prototype), {
		constructor: hn,
		interpolate_: function(e, t, i, n) {
			var r = this.resultBuffer,
				o = this.sampleValues,
				s = this.valueSize,
				a = (e *= s) - s;
			for (i = 1 - (t = (i - t) / (n - t)), n = 0; n !== s; ++n) r[n] = o[a + n] * i + o[e + n] * t;
			return r
		}
	}), un.prototype = Object.assign(Object.create(ln.prototype), {
		constructor: un,
		interpolate_: function(e) {
			return this.copySampleValue_(e - 1)
		}
	}), Object.assign(dn, {
		toJSON: function(e) {
			var t = e.constructor;
			if (void 0 !== t.toJSON) t = t.toJSON(e);
			else {
				t = {
					name: e.name,
					times: Vo.convertArray(e.times, Array),
					values: Vo.convertArray(e.values, Array)
				};
				var i = e.getInterpolation();
				i !== e.DefaultInterpolation && (t.interpolation = i)
			}
			return t.type = e.ValueTypeName, t
		}
	}), Object.assign(dn.prototype, {
		constructor: dn,
		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,
		DefaultInterpolation: 2301,
		InterpolantFactoryMethodDiscrete: function(e) {
			return new un(this.times, this.values, this.getValueSize(), e)
		},
		InterpolantFactoryMethodLinear: function(e) {
			return new hn(this.times, this.values, this.getValueSize(), e)
		},
		InterpolantFactoryMethodSmooth: function(e) {
			return new cn(this.times, this.values, this.getValueSize(), e)
		},
		setInterpolation: function(e) {
			switch (e) {
				case 2300:
					var t = this.InterpolantFactoryMethodDiscrete;
					break;
				case 2301:
					t = this.InterpolantFactoryMethodLinear;
					break;
				case 2302:
					t = this.InterpolantFactoryMethodSmooth
			}
			if (void 0 === t) {
				if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
					if (e === this.DefaultInterpolation) throw Error(t);
					this.setInterpolation(this.DefaultInterpolation)
				}
				return console.warn("THREE.KeyframeTrack:", t), this
			}
			return this.createInterpolant = t, this
		},
		getInterpolation: function() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return 2300;
				case this.InterpolantFactoryMethodLinear:
					return 2301;
				case this.InterpolantFactoryMethodSmooth:
					return 2302
			}
		},
		getValueSize: function() {
			return this.values.length / this.times.length
		},
		shift: function(e) {
			if (0 !== e)
				for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e;
			return this
		},
		scale: function(e) {
			if (1 !== e)
				for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e;
			return this
		},
		trim: function(e, t) {
			for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < e;) ++r;
			for (; - 1 !== o && i[o] > t;) --o;
			return ++o, 0 === r && o === n || (r >= o && (r = (o = Math.max(o, 1)) - 1), e = this.getValueSize(), this.times = Vo.arraySlice(i, r, o), this.values = Vo.arraySlice(this.values, r * e, o * e)), this
		},
		validate: function() {
			var e = !0,
				t = this.getValueSize();
			0 != t - Math.floor(t) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
			var i = this.times;
			t = this.values;
			var n = i.length;
			0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
			for (var r = null, o = 0; o !== n; o++) {
				var s = i[o];
				if ("number" == typeof s && isNaN(s)) {
					console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
					break
				}
				if (null !== r && r > s) {
					console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, r), e = !1;
					break
				}
				r = s
			}
			if (void 0 !== t && Vo.isTypedArray(t))
				for (o = 0, i = t.length; o !== i; ++o)
					if (n = t[o], isNaN(n)) {
						console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, n), e = !1;
						break
					} return e
		},
		optimize: function() {
			for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = e.length - 1, s = 1; s < o; ++s) {
				var a = !1,
					l = e[s];
				if (l !== e[s + 1] && (1 !== s || l !== l[0]))
					if (n) a = !0;
					else {
						var c = s * i,
							h = c - i,
							u = c + i;
						for (l = 0; l !== i; ++l) {
							var d = t[c + l];
							if (d !== t[h + l] || d !== t[u + l]) {
								a = !0;
								break
							}
						}
					} if (a) {
					if (s !== r)
						for (e[r] = e[s], a = s * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[a + l];
					++r
				}
			}
			if (0 < o) {
				for (e[r] = e[o], a = o * i, c = r * i, l = 0; l !== i; ++l) t[c + l] = t[a + l];
				++r
			}
			return r !== e.length && (this.times = Vo.arraySlice(e, 0, r), this.values = Vo.arraySlice(t, 0, r * i)), this
		},
		clone: function() {
			var e = Vo.arraySlice(this.times, 0),
				t = Vo.arraySlice(this.values, 0);
			return (e = new this.constructor(this.name, e, t)).createInterpolant = this.createInterpolant, e
		}
	}), pn.prototype = Object.assign(Object.create(dn.prototype), {
		constructor: pn,
		ValueTypeName: "bool",
		ValueBufferType: Array,
		DefaultInterpolation: 2300,
		InterpolantFactoryMethodLinear: void 0,
		InterpolantFactoryMethodSmooth: void 0
	}), fn.prototype = Object.assign(Object.create(dn.prototype), {
		constructor: fn,
		ValueTypeName: "color"
	}), mn.prototype = Object.assign(Object.create(dn.prototype), {
		constructor: mn,
		ValueTypeName: "number"
	}), gn.prototype = Object.assign(Object.create(ln.prototype), {
		constructor: gn,
		interpolate_: function(e, t, i, r) {
			var o = this.resultBuffer,
				s = this.sampleValues,
				a = this.valueSize;
			for (t = (i - t) / (r - t), i = (e *= a) + a; e !== i; e += 4) n.slerpFlat(o, 0, s, e - a, s, e, t);
			return o
		}
	}), vn.prototype = Object.assign(Object.create(dn.prototype), {
		constructor: vn,
		ValueTypeName: "quaternion",
		DefaultInterpolation: 2301,
		InterpolantFactoryMethodLinear: function(e) {
			return new gn(this.times, this.values, this.getValueSize(), e)
		},
		InterpolantFactoryMethodSmooth: void 0
	}), yn.prototype = Object.assign(Object.create(dn.prototype), {
		constructor: yn,
		ValueTypeName: "string",
		ValueBufferType: Array,
		DefaultInterpolation: 2300,
		InterpolantFactoryMethodLinear: void 0,
		InterpolantFactoryMethodSmooth: void 0
	}), bn.prototype = Object.assign(Object.create(dn.prototype), {
		constructor: bn,
		ValueTypeName: "vector"
	}), Object.assign(wn, {
		parse: function(e) {
			for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, o = i.length; r !== o; ++r) t.push(xn(i[r]).scale(n));
			return new wn(e.name, e.duration, t)
		},
		toJSON: function(e) {
			var t = [],
				i = e.tracks;
			e = {
				name: e.name,
				duration: e.duration,
				tracks: t,
				uuid: e.uuid
			};
			for (var n = 0, r = i.length; n !== r; ++n) t.push(dn.toJSON(i[n]));
			return e
		},
		CreateFromMorphTargetSequence: function(e, t, i, n) {
			for (var r = t.length, o = [], s = 0; s < r; s++) {
				var a = [],
					l = [];
				a.push((s + r - 1) % r, s, (s + 1) % r), l.push(0, 1, 0);
				var c = Vo.getKeyframeOrder(a);
				a = Vo.sortedArray(a, 1, c), l = Vo.sortedArray(l, 1, c), n || 0 !== a[0] || (a.push(r), l.push(l[0])), o.push(new mn(".morphTargetInfluences[" + t[s].name + "]", a, l).scale(1 / i))
			}
			return new wn(e, -1, o)
		},
		findByName: function(e, t) {
			var i = e;
			for (Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations), e = 0; e < i.length; e++)
				if (i[e].name === t) return i[e];
			return null
		},
		CreateClipsFromMorphTargetSequences: function(e, t, i) {
			for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, s = e.length; o < s; o++) {
				var a = e[o],
					l = a.name.match(r);
				if (l && 1 < l.length) {
					var c = l[1];
					(l = n[c]) || (n[c] = l = []), l.push(a)
				}
			}
			for (c in e = [], n) e.push(wn.CreateFromMorphTargetSequence(c, n[c], t, i));
			return e
		},
		parseAnimation: function(e, t) {
			if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
			var i = function(e, t, i, n, r) {
					if (0 !== i.length) {
						var o = [],
							s = [];
						Vo.flattenJSON(i, o, s, n), 0 !== o.length && r.push(new e(t, o, s))
					}
				},
				n = [],
				r = e.name || "default",
				o = e.length || -1,
				s = e.fps || 30;
			e = e.hierarchy || [];
			for (var a = 0; a < e.length; a++) {
				var l = e[a].keys;
				if (l && 0 !== l.length)
					if (l[0].morphTargets) {
						o = {};
						for (var c = 0; c < l.length; c++)
							if (l[c].morphTargets)
								for (var h = 0; h < l[c].morphTargets.length; h++) o[l[c].morphTargets[h]] = -1;
						for (var u in o) {
							var d = [],
								p = [];
							for (h = 0; h !== l[c].morphTargets.length; ++h) {
								var f = l[c];
								d.push(f.time), p.push(f.morphTarget === u ? 1 : 0)
							}
							n.push(new mn(".morphTargetInfluence[" + u + "]", d, p))
						}
						o = o.length * (s || 1)
					} else i(bn, (c = ".bones[" + t[a].name + "]") + ".position", l, "pos", n), i(vn, c + ".quaternion", l, "rot", n), i(bn, c + ".scale", l, "scl", n)
			}
			return 0 === n.length ? null : new wn(r, o, n)
		}
	}), Object.assign(wn.prototype, {
		resetDuration: function() {
			for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
				var n = this.tracks[t];
				e = Math.max(e, n.times[n.times.length - 1])
			}
			return this.duration = e, this
		},
		trim: function() {
			for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
			return this
		},
		validate: function() {
			for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
			return e
		},
		optimize: function() {
			for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
			return this
		},
		clone: function() {
			for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
			return new wn(this.name, this.duration, e)
		}
	});
	var Wo = {
			enabled: !1,
			files: {},
			add: function(e, t) {
				!1 !== this.enabled && (this.files[e] = t)
			},
			get: function(e) {
				if (!1 !== this.enabled) return this.files[e]
			},
			remove: function(e) {
				delete this.files[e]
			},
			clear: function() {
				this.files = {}
			}
		},
		qo = new _n,
		Xo = {};
	Object.assign(En.prototype, {
		load: function(e, t, i, n) {
			void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
			var r = this,
				o = Wo.get(e);
			if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
				t && t(o), r.manager.itemEnd(e)
			}), 0), o;
			if (void 0 === Xo[e]) {
				var s = e.match(/^data:(.*?)(;base64)?,(.*)$/);
				if (s) {
					i = s[1];
					var a = !!s[2];
					s = s[3], s = decodeURIComponent(s), a && (s = atob(s));
					try {
						var l = (this.responseType || "").toLowerCase();
						switch (l) {
							case "arraybuffer":
							case "blob":
								var c = new Uint8Array(s.length);
								for (a = 0; a < s.length; a++) c[a] = s.charCodeAt(a);
								var h = "blob" === l ? new Blob([c.buffer], {
									type: i
								}) : c.buffer;
								break;
							case "document":
								h = (new DOMParser).parseFromString(s, i);
								break;
							case "json":
								h = JSON.parse(s);
								break;
							default:
								h = s
						}
						setTimeout((function() {
							t && t(h), r.manager.itemEnd(e)
						}), 0)
					} catch (t) {
						setTimeout((function() {
							n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
						}), 0)
					}
				} else {
					Xo[e] = [], Xo[e].push({
						onLoad: t,
						onProgress: i,
						onError: n
					});
					var u = new XMLHttpRequest;
					for (a in u.open("GET", e, !0), u.addEventListener("load", (function(t) {
							var i = this.response;
							Wo.add(e, i);
							var n = Xo[e];
							if (delete Xo[e], 200 === this.status || 0 === this.status) {
								0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
								for (var o = 0, s = n.length; o < s; o++) {
									var a = n[o];
									a.onLoad && a.onLoad(i)
								}
							} else {
								for (o = 0, s = n.length; o < s; o++)(a = n[o]).onError && a.onError(t);
								r.manager.itemError(e)
							}
							r.manager.itemEnd(e)
						}), !1), u.addEventListener("progress", (function(t) {
							for (var i = Xo[e], n = 0, r = i.length; n < r; n++) {
								var o = i[n];
								o.onProgress && o.onProgress(t)
							}
						}), !1), u.addEventListener("error", (function(t) {
							var i = Xo[e];
							delete Xo[e];
							for (var n = 0, o = i.length; n < o; n++) {
								var s = i[n];
								s.onError && s.onError(t)
							}
							r.manager.itemError(e), r.manager.itemEnd(e)
						}), !1), u.addEventListener("abort", (function(t) {
							var i = Xo[e];
							delete Xo[e];
							for (var n = 0, o = i.length; n < o; n++) {
								var s = i[n];
								s.onError && s.onError(t)
							}
							r.manager.itemError(e), r.manager.itemEnd(e)
						}), !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(a, this.requestHeader[a]);
					u.send(null)
				}
				return r.manager.itemStart(e), u
			}
			Xo[e].push({
				onLoad: t,
				onProgress: i,
				onError: n
			})
		},
		setPath: function(e) {
			return this.path = e, this
		},
		setResponseType: function(e) {
			return this.responseType = e, this
		},
		setWithCredentials: function(e) {
			return this.withCredentials = e, this
		},
		setMimeType: function(e) {
			return this.mimeType = e, this
		},
		setRequestHeader: function(e) {
			return this.requestHeader = e, this
		}
	}), Object.assign(Mn.prototype, {
		load: function(e, t, i, n) {
			var r = this,
				o = new En(r.manager);
			o.setPath(r.path), o.load(e, (function(e) {
				t(r.parse(JSON.parse(e)))
			}), i, n)
		},
		parse: function(e) {
			for (var t = [], i = 0; i < e.length; i++) {
				var n = wn.parse(e[i]);
				t.push(n)
			}
			return t
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(Sn.prototype, {
		load: function(e, t, i, n) {
			function r(r) {
				l.load(e[r], (function(e) {
					e = o._parser(e, !0), s[r] = {
						width: e.width,
						height: e.height,
						format: e.format,
						mipmaps: e.mipmaps
					}, 6 === (c += 1) && (1 === e.mipmapCount && (a.minFilter = 1006), a.format = e.format, a.needsUpdate = !0, t && t(a))
				}), i, n)
			}
			var o = this,
				s = [],
				a = new Wt;
			a.image = s;
			var l = new En(this.manager);
			if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(e))
				for (var c = 0, h = 0, u = e.length; h < u; ++h) r(h);
			else l.load(e, (function(e) {
				if ((e = o._parser(e, !0)).isCubemap)
					for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
						s[n] = {
							mipmaps: []
						};
						for (var r = 0; r < e.mipmapCount; r++) s[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]), s[n].format = e.format, s[n].width = e.width, s[n].height = e.height
					} else a.image.width = e.width, a.image.height = e.height, a.mipmaps = e.mipmaps;
				1 === e.mipmapCount && (a.minFilter = 1006), a.format = e.format, a.needsUpdate = !0, t && t(a)
			}), i, n);
			return a
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(Tn.prototype, {
		load: function(e, t, i, n) {
			var r = this,
				o = new u,
				s = new En(this.manager);
			return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(e, (function(e) {
				(e = r._parser(e)) && (void 0 !== e.image ? o.image = e.image : void 0 !== e.data && (o.image.width = e.width, o.image.height = e.height, o.image.data = e.data), o.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001, o.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001, o.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006, o.minFilter = void 0 !== e.minFilter ? e.minFilter : 1008, o.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (o.format = e.format), void 0 !== e.type && (o.type = e.type), void 0 !== e.mipmaps && (o.mipmaps = e.mipmaps), 1 === e.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, t && t(o, e))
			}), i, n), o
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(An.prototype, {
		crossOrigin: "anonymous",
		load: function(e, t, i, n) {
			function r() {
				l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), Wo.add(e, this), t && t(this), s.manager.itemEnd(e)
			}

			function o(t) {
				l.removeEventListener("load", r, !1), l.removeEventListener("error", o, !1), n && n(t), s.manager.itemError(e), s.manager.itemEnd(e)
			}
			void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
			var s = this,
				a = Wo.get(e);
			if (void 0 !== a) return s.manager.itemStart(e), setTimeout((function() {
				t && t(a), s.manager.itemEnd(e)
			}), 0), a;
			var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
			return l.addEventListener("load", r, !1), l.addEventListener("error", o, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), s.manager.itemStart(e), l.src = e, l
		},
		setCrossOrigin: function(e) {
			return this.crossOrigin = e, this
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(Ln.prototype, {
		crossOrigin: "anonymous",
		load: function(e, t, i, n) {
			function r(i) {
				s.load(e[i], (function(e) {
					o.images[i] = e, 6 == ++a && (o.needsUpdate = !0, t && t(o))
				}), void 0, n)
			}
			var o = new ae,
				s = new An(this.manager);
			s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
			var a = 0;
			for (i = 0; i < e.length; ++i) r(i);
			return o
		},
		setCrossOrigin: function(e) {
			return this.crossOrigin = e, this
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(Cn.prototype, {
		crossOrigin: "anonymous",
		load: function(e, t, i, n) {
			var r = new s,
				o = new An(this.manager);
			return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function(i) {
				r.image = i, i = 0 < e.search(/\.jpe?g($|\?)/i) || 0 === e.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== t && t(r)
			}), i, n), r
		},
		setCrossOrigin: function(e) {
			return this.crossOrigin = e, this
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(Pn.prototype, {
		getPoint: function() {
			return console.warn("THREE.Curve: .getPoint() not implemented."), null
		},
		getPointAt: function(e, t) {
			return e = this.getUtoTmapping(e), this.getPoint(e, t)
		},
		getPoints: function(e) {
			void 0 === e && (e = 5);
			for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
			return t
		},
		getSpacedPoints: function(e) {
			void 0 === e && (e = 5);
			for (var t = [], i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
			return t
		},
		getLength: function() {
			var e = this.getLengths();
			return e[e.length - 1]
		},
		getLengths: function(e) {
			if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
			this.needsUpdate = !1;
			var t, i = [],
				n = this.getPoint(0),
				r = 0;
			for (i.push(0), t = 1; t <= e; t++) {
				var o = this.getPoint(t / e);
				r += o.distanceTo(n), i.push(r), n = o
			}
			return this.cacheArcLengths = i
		},
		updateArcLengths: function() {
			this.needsUpdate = !0, this.getLengths()
		},
		getUtoTmapping: function(e, t) {
			var i = this.getLengths(),
				n = i.length;
			t = t || e * i[n - 1];
			for (var r, o = 0, s = n - 1; o <= s;)
				if (0 > (r = i[e = Math.floor(o + (s - o) / 2)] - t)) o = e + 1;
				else {
					if (!(0 < r)) {
						s = e;
						break
					}
					s = e - 1
				} return i[e = s] === t ? e / (n - 1) : (e + (t - (o = i[e])) / (i[e + 1] - o)) / (n - 1)
		},
		getTangent: function(e) {
			var t = e - 1e-4;
			return 0 > t && (t = 0), 1 < (e += 1e-4) && (e = 1), t = this.getPoint(t), this.getPoint(e).clone().sub(t).normalize()
		},
		getTangentAt: function(e) {
			return e = this.getUtoTmapping(e), this.getTangent(e)
		},
		computeFrenetFrames: function(e, t) {
			var i, n = new r,
				o = [],
				s = [],
				a = [],
				l = new r,
				c = new g;
			for (i = 0; i <= e; i++) {
				var h = i / e;
				o[i] = this.getTangentAt(h), o[i].normalize()
			}
			s[0] = new r, a[0] = new r, i = Number.MAX_VALUE, h = Math.abs(o[0].x);
			var u = Math.abs(o[0].y),
				d = Math.abs(o[0].z);
			for (h <= i && (i = h, n.set(1, 0, 0)), u <= i && (i = u, n.set(0, 1, 0)), d <= i && n.set(0, 0, 1), l.crossVectors(o[0], n).normalize(), s[0].crossVectors(o[0], l), a[0].crossVectors(o[0], s[0]), i = 1; i <= e; i++) s[i] = s[i - 1].clone(), a[i] = a[i - 1].clone(), l.crossVectors(o[i - 1], o[i]), l.length() > Number.EPSILON && (l.normalize(), n = Math.acos(uo.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(c.makeRotationAxis(l, n))), a[i].crossVectors(o[i], s[i]);
			if (!0 === t)
				for (n = Math.acos(uo.clamp(s[0].dot(s[e]), -1, 1)), n /= e, 0 < o[0].dot(l.crossVectors(s[0], s[e])) && (n = -n), i = 1; i <= e; i++) s[i].applyMatrix4(c.makeRotationAxis(o[i], n * i)), a[i].crossVectors(o[i], s[i]);
			return {
				tangents: o,
				normals: s,
				binormals: a
			}
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.arcLengthDivisions = e.arcLengthDivisions, this
		},
		toJSON: function() {
			var e = {
				metadata: {
					version: 4.5,
					type: "Curve",
					generator: "Curve.toJSON"
				}
			};
			return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
		},
		fromJSON: function(e) {
			return this.arcLengthDivisions = e.arcLengthDivisions, this
		}
	}), In.prototype = Object.create(Pn.prototype), In.prototype.constructor = In, In.prototype.isEllipseCurve = !0, In.prototype.getPoint = function(e, t) {
		t = t || new i;
		for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; 0 > r;) r += n;
		for (; r > n;) r -= n;
		r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r = r === n ? -n : r - n), n = this.aStartAngle + e * r, e = this.aX + this.xRadius * Math.cos(n);
		var s = this.aY + this.yRadius * Math.sin(n);
		return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), e = (o = e - this.aX) * n - (s -= this.aY) * r + this.aX, s = o * r + s * n + this.aY), t.set(e, s)
	}, In.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
	}, In.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
	}, In.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
	}, Rn.prototype = Object.create(In.prototype), Rn.prototype.constructor = Rn, Rn.prototype.isArcCurve = !0;
	var Yo = new r,
		Zo = new On,
		Qo = new On,
		Jo = new On;
	Dn.prototype = Object.create(Pn.prototype), Dn.prototype.constructor = Dn, Dn.prototype.isCatmullRomCurve3 = !0, Dn.prototype.getPoint = function(e, t) {
		t = t || new r;
		var i = this.points,
			n = i.length;
		e *= n - (this.closed ? 0 : 1);
		var o = Math.floor(e);
		if (e -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === e && o === n - 1 && (o = n - 2, e = 1), this.closed || 0 < o) var s = i[(o - 1) % n];
		else Yo.subVectors(i[0], i[1]).add(i[0]), s = Yo;
		var a = i[o % n],
			l = i[(o + 1) % n];
		if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (Yo.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Yo), "centripetal" === this.curveType || "chordal" === this.curveType) {
			var c = "chordal" === this.curveType ? .5 : .25;
			n = Math.pow(s.distanceToSquared(a), c), 1e-4 > (o = Math.pow(a.distanceToSquared(l), c)) && (o = 1), 1e-4 > n && (n = o), 1e-4 > (c = Math.pow(l.distanceToSquared(i), c)) && (c = o), Zo.initNonuniformCatmullRom(s.x, a.x, l.x, i.x, n, o, c), Qo.initNonuniformCatmullRom(s.y, a.y, l.y, i.y, n, o, c), Jo.initNonuniformCatmullRom(s.z, a.z, l.z, i.z, n, o, c)
		} else "catmullrom" === this.curveType && (Zo.initCatmullRom(s.x, a.x, l.x, i.x, this.tension), Qo.initCatmullRom(s.y, a.y, l.y, i.y, this.tension), Jo.initCatmullRom(s.z, a.z, l.z, i.z, this.tension));
		return t.set(Zo.calc(e), Qo.calc(e), Jo.calc(e)), t
	}, Dn.prototype.copy = function(e) {
		Pn.prototype.copy.call(this, e), this.points = [];
		for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
		return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
	}, Dn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		e.points = [];
		for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
		return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
	}, Dn.prototype.fromJSON = function(e) {
		Pn.prototype.fromJSON.call(this, e), this.points = [];
		for (var t = 0, i = e.points.length; t < i; t++) {
			var n = e.points[t];
			this.points.push((new r).fromArray(n))
		}
		return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
	}, Bn.prototype = Object.create(Pn.prototype), Bn.prototype.constructor = Bn, Bn.prototype.isCubicBezierCurve = !0, Bn.prototype.getPoint = function(e, t) {
		t = t || new i;
		var n = this.v0,
			r = this.v1,
			o = this.v2,
			s = this.v3;
		return t.set(Nn(e, n.x, r.x, o.x, s.x), Nn(e, n.y, r.y, o.y, s.y)), t
	}, Bn.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
	}, Bn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
	}, Bn.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
	}, Hn.prototype = Object.create(Pn.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isCubicBezierCurve3 = !0, Hn.prototype.getPoint = function(e, t) {
		t = t || new r;
		var i = this.v0,
			n = this.v1,
			o = this.v2,
			s = this.v3;
		return t.set(Nn(e, i.x, n.x, o.x, s.x), Nn(e, i.y, n.y, o.y, s.y), Nn(e, i.z, n.z, o.z, s.z)), t
	}, Hn.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
	}, Hn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
	}, Hn.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
	}, Fn.prototype = Object.create(Pn.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isLineCurve = !0, Fn.prototype.getPoint = function(e, t) {
		return t = t || new i, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
	}, Fn.prototype.getPointAt = function(e, t) {
		return this.getPoint(e, t)
	}, Fn.prototype.getTangent = function() {
		return this.v2.clone().sub(this.v1).normalize()
	}, Fn.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}, Fn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}, Fn.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}, Un.prototype = Object.create(Pn.prototype), Un.prototype.constructor = Un, Un.prototype.isLineCurve3 = !0, Un.prototype.getPoint = function(e, t) {
		return t = t || new r, 1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1), t.multiplyScalar(e).add(this.v1)), t
	}, Un.prototype.getPointAt = function(e, t) {
		return this.getPoint(e, t)
	}, Un.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}, Un.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}, Un.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}, jn.prototype = Object.create(Pn.prototype), jn.prototype.constructor = jn, jn.prototype.isQuadraticBezierCurve = !0, jn.prototype.getPoint = function(e, t) {
		t = t || new i;
		var n = this.v0,
			r = this.v1,
			o = this.v2;
		return t.set(kn(e, n.x, r.x, o.x), kn(e, n.y, r.y, o.y)), t
	}, jn.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}, jn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}, jn.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}, Gn.prototype = Object.create(Pn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isQuadraticBezierCurve3 = !0, Gn.prototype.getPoint = function(e, t) {
		t = t || new r;
		var i = this.v0,
			n = this.v1,
			o = this.v2;
		return t.set(kn(e, i.x, n.x, o.x), kn(e, i.y, n.y, o.y), kn(e, i.z, n.z, o.z)), t
	}, Gn.prototype.copy = function(e) {
		return Pn.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
	}, Gn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
	}, Gn.prototype.fromJSON = function(e) {
		return Pn.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
	}, Vn.prototype = Object.create(Pn.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isSplineCurve = !0, Vn.prototype.getPoint = function(e, t) {
		t = t || new i;
		var n = this.points,
			r = (n.length - 1) * e;
		r -= e = Math.floor(r);
		var o = n[0 === e ? e : e - 1],
			s = n[e],
			a = n[e > n.length - 2 ? n.length - 1 : e + 1];
		return n = n[e > n.length - 3 ? n.length - 1 : e + 2], t.set(zn(r, o.x, s.x, a.x, n.x), zn(r, o.y, s.y, a.y, n.y)), t
	}, Vn.prototype.copy = function(e) {
		Pn.prototype.copy.call(this, e), this.points = [];
		for (var t = 0, i = e.points.length; t < i; t++) this.points.push(e.points[t].clone());
		return this
	}, Vn.prototype.toJSON = function() {
		var e = Pn.prototype.toJSON.call(this);
		e.points = [];
		for (var t = 0, i = this.points.length; t < i; t++) e.points.push(this.points[t].toArray());
		return e
	}, Vn.prototype.fromJSON = function(e) {
		Pn.prototype.fromJSON.call(this, e), this.points = [];
		for (var t = 0, n = e.points.length; t < n; t++) {
			var r = e.points[t];
			this.points.push((new i).fromArray(r))
		}
		return this
	};
	var Ko = Object.freeze({
		ArcCurve: Rn,
		CatmullRomCurve3: Dn,
		CubicBezierCurve: Bn,
		CubicBezierCurve3: Hn,
		EllipseCurve: In,
		LineCurve: Fn,
		LineCurve3: Un,
		QuadraticBezierCurve: jn,
		QuadraticBezierCurve3: Gn,
		SplineCurve: Vn
	});
	Wn.prototype = Object.assign(Object.create(Pn.prototype), {
		constructor: Wn,
		add: function(e) {
			this.curves.push(e)
		},
		closePath: function() {
			var e = this.curves[0].getPoint(0),
				t = this.curves[this.curves.length - 1].getPoint(1);
			e.equals(t) || this.curves.push(new Fn(t, e))
		},
		getPoint: function(e) {
			var t = e * this.getLength(),
				i = this.getCurveLengths();
			for (e = 0; e < i.length;) {
				if (i[e] >= t) return t = i[e] - t, i = (e = this.curves[e]).getLength(), e.getPointAt(0 === i ? 0 : 1 - t / i);
				e++
			}
			return null
		},
		getLength: function() {
			var e = this.getCurveLengths();
			return e[e.length - 1]
		},
		updateArcLengths: function() {
			this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
		},
		getCurveLengths: function() {
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
			for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
			return this.cacheLengths = e
		},
		getSpacedPoints: function(e) {
			void 0 === e && (e = 40);
			for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
			return this.autoClose && t.push(t[0]), t
		},
		getPoints: function(e) {
			e = e || 12;
			for (var t, i = [], n = 0, r = this.curves; n < r.length; n++) {
				var o = r[n];
				o = o.getPoints(o && o.isEllipseCurve ? 2 * e : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? e * o.points.length : e);
				for (var s = 0; s < o.length; s++) {
					var a = o[s];
					t && t.equals(a) || (i.push(a), t = a)
				}
			}
			return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
		},
		copy: function(e) {
			Pn.prototype.copy.call(this, e), this.curves = [];
			for (var t = 0, i = e.curves.length; t < i; t++) this.curves.push(e.curves[t].clone());
			return this.autoClose = e.autoClose, this
		},
		toJSON: function() {
			var e = Pn.prototype.toJSON.call(this);
			e.autoClose = this.autoClose, e.curves = [];
			for (var t = 0, i = this.curves.length; t < i; t++) e.curves.push(this.curves[t].toJSON());
			return e
		},
		fromJSON: function(e) {
			Pn.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
			for (var t = 0, i = e.curves.length; t < i; t++) {
				var n = e.curves[t];
				this.curves.push((new Ko[n.type]).fromJSON(n))
			}
			return this
		}
	}), qn.prototype = Object.assign(Object.create(Wn.prototype), {
		constructor: qn,
		setFromPoints: function(e) {
			this.moveTo(e[0].x, e[0].y);
			for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
		},
		moveTo: function(e, t) {
			this.currentPoint.set(e, t)
		},
		lineTo: function(e, t) {
			var n = new Fn(this.currentPoint.clone(), new i(e, t));
			this.curves.push(n), this.currentPoint.set(e, t)
		},
		quadraticCurveTo: function(e, t, n, r) {
			e = new jn(this.currentPoint.clone(), new i(e, t), new i(n, r)), this.curves.push(e), this.currentPoint.set(n, r)
		},
		bezierCurveTo: function(e, t, n, r, o, s) {
			e = new Bn(this.currentPoint.clone(), new i(e, t), new i(n, r), new i(o, s)), this.curves.push(e), this.currentPoint.set(o, s)
		},
		splineThru: function(e) {
			var t = [this.currentPoint.clone()].concat(e);
			t = new Vn(t), this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
		},
		arc: function(e, t, i, n, r, o) {
			this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o)
		},
		absarc: function(e, t, i, n, r, o) {
			this.absellipse(e, t, i, i, n, r, o)
		},
		ellipse: function(e, t, i, n, r, o, s, a) {
			this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, o, s, a)
		},
		absellipse: function(e, t, i, n, r, o, s, a) {
			e = new In(e, t, i, n, r, o, s, a), 0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)), this.curves.push(e), e = e.getPoint(1), this.currentPoint.copy(e)
		},
		copy: function(e) {
			return Wn.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
		},
		toJSON: function() {
			var e = Wn.prototype.toJSON.call(this);
			return e.currentPoint = this.currentPoint.toArray(), e
		},
		fromJSON: function(e) {
			return Wn.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
		}
	}), Xn.prototype = Object.assign(Object.create(qn.prototype), {
		constructor: Xn,
		getPointsHoles: function(e) {
			for (var t = [], i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
			return t
		},
		extractPoints: function(e) {
			return {
				shape: this.getPoints(e),
				holes: this.getPointsHoles(e)
			}
		},
		copy: function(e) {
			qn.prototype.copy.call(this, e), this.holes = [];
			for (var t = 0, i = e.holes.length; t < i; t++) this.holes.push(e.holes[t].clone());
			return this
		},
		toJSON: function() {
			var e = qn.prototype.toJSON.call(this);
			e.uuid = this.uuid, e.holes = [];
			for (var t = 0, i = this.holes.length; t < i; t++) e.holes.push(this.holes[t].toJSON());
			return e
		},
		fromJSON: function(e) {
			qn.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
			for (var t = 0, i = e.holes.length; t < i; t++) {
				var n = e.holes[t];
				this.holes.push((new qn).fromJSON(n))
			}
			return this
		}
	}), Yn.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Yn,
		isLight: !0,
		copy: function(e) {
			return S.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
		},
		toJSON: function(e) {
			return (e = S.prototype.toJSON.call(this, e)).object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
		}
	}), Zn.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: Zn,
		isHemisphereLight: !0,
		copy: function(e) {
			return Yn.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
		}
	}), Object.assign(Qn.prototype, {
		copy: function(e) {
			return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		toJSON: function() {
			var e = {};
			return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
		}
	}), Jn.prototype = Object.assign(Object.create(Qn.prototype), {
		constructor: Jn,
		isSpotLightShadow: !0,
		update: function(e) {
			var t = this.camera,
				i = 2 * uo.RAD2DEG * e.angle,
				n = this.mapSize.width / this.mapSize.height;
			e = e.distance || t.far, i === t.fov && n === t.aspect && e === t.far || (t.fov = i, t.aspect = n, t.far = e, t.updateProjectionMatrix())
		}
	}), Kn.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: Kn,
		isSpotLight: !0,
		copy: function(e) {
			return Yn.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
		}
	}), $n.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: $n,
		isPointLight: !0,
		copy: function(e) {
			return Yn.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
		}
	}), er.prototype = Object.assign(Object.create(wt.prototype), {
		constructor: er,
		isOrthographicCamera: !0,
		copy: function(e, t) {
			return wt.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
		},
		setViewOffset: function(e, t, i, n, r, o) {
			null === this.view && (this.view = {
				enabled: !0,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
		},
		clearViewOffset: function() {
			null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
		},
		updateProjectionMatrix: function() {
			var e = (this.right - this.left) / (2 * this.zoom),
				t = (this.top - this.bottom) / (2 * this.zoom),
				i = (this.right + this.left) / 2,
				n = (this.top + this.bottom) / 2,
				r = i - e;
			if (i += e, e = n + t, t = n - t, null !== this.view && this.view.enabled) {
				i = this.zoom / (this.view.width / this.view.fullWidth), t = this.zoom / (this.view.height / this.view.fullHeight);
				var o = (this.right - this.left) / this.view.width;
				n = (this.top - this.bottom) / this.view.height, i = (r += this.view.offsetX / i * o) + this.view.width / i * o, t = (e -= this.view.offsetY / t * n) - this.view.height / t * n
			}
			this.projectionMatrix.makeOrthographic(r, i, e, t, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
		},
		toJSON: function(e) {
			return (e = S.prototype.toJSON.call(this, e)).object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
		}
	}), tr.prototype = Object.assign(Object.create(Qn.prototype), {
		constructor: tr
	}), ir.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: ir,
		isDirectionalLight: !0,
		copy: function(e) {
			return Yn.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
		}
	}), nr.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: nr,
		isAmbientLight: !0
	}), rr.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: rr,
		isRectAreaLight: !0,
		copy: function(e) {
			return Yn.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
		},
		toJSON: function(e) {
			return (e = Yn.prototype.toJSON.call(this, e)).object.width = this.width, e.object.height = this.height, e
		}
	}), Object.assign(or.prototype, {
		load: function(e, t, i, n) {
			var r = this,
				o = new En(r.manager);
			o.setPath(r.path), o.load(e, (function(e) {
				t(r.parse(JSON.parse(e)))
			}), i, n)
		},
		parse: function(e) {
			function t(e) {
				return void 0 === n[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), n[e]
			}
			var n = this.textures,
				s = new Go[e.type];
			if (void 0 !== e.uuid && (s.uuid = e.uuid), void 0 !== e.name && (s.name = e.name), void 0 !== e.color && s.color.setHex(e.color), void 0 !== e.roughness && (s.roughness = e.roughness), void 0 !== e.metalness && (s.metalness = e.metalness), void 0 !== e.emissive && s.emissive.setHex(e.emissive), void 0 !== e.specular && s.specular.setHex(e.specular), void 0 !== e.shininess && (s.shininess = e.shininess), void 0 !== e.clearCoat && (s.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (s.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (s.vertexColors = e.vertexColors), void 0 !== e.fog && (s.fog = e.fog), void 0 !== e.flatShading && (s.flatShading = e.flatShading), void 0 !== e.blending && (s.blending = e.blending), void 0 !== e.combine && (s.combine = e.combine), void 0 !== e.side && (s.side = e.side), void 0 !== e.opacity && (s.opacity = e.opacity), void 0 !== e.transparent && (s.transparent = e.transparent), void 0 !== e.alphaTest && (s.alphaTest = e.alphaTest), void 0 !== e.depthTest && (s.depthTest = e.depthTest), void 0 !== e.depthWrite && (s.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (s.colorWrite = e.colorWrite), void 0 !== e.wireframe && (s.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (s.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (s.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (s.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (s.rotation = e.rotation), 1 !== e.linewidth && (s.linewidth = e.linewidth), void 0 !== e.dashSize && (s.dashSize = e.dashSize), void 0 !== e.gapSize && (s.gapSize = e.gapSize), void 0 !== e.scale && (s.scale = e.scale), void 0 !== e.polygonOffset && (s.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (s.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (s.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (s.skinning = e.skinning), void 0 !== e.morphTargets && (s.morphTargets = e.morphTargets), void 0 !== e.dithering && (s.dithering = e.dithering), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.uniforms)
				for (var l in e.uniforms) {
					var c = e.uniforms[l];
					switch (s.uniforms[l] = {}, c.type) {
						case "t":
							s.uniforms[l].value = t(c.value);
							break;
						case "c":
							s.uniforms[l].value = (new b).setHex(c.value);
							break;
						case "v2":
							s.uniforms[l].value = (new i).fromArray(c.value);
							break;
						case "v3":
							s.uniforms[l].value = (new r).fromArray(c.value);
							break;
						case "v4":
							s.uniforms[l].value = (new a).fromArray(c.value);
							break;
						case "m3":
							s.uniforms[l].value = (new o).fromArray(c.value);
						case "m4":
							s.uniforms[l].value = (new g).fromArray(c.value);
							break;
						default:
							s.uniforms[l].value = c.value
					}
				}
			if (void 0 !== e.defines && (s.defines = e.defines), void 0 !== e.vertexShader && (s.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (s.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
				for (var h in e.extensions) s.extensions[h] = e.extensions[h];
			return void 0 !== e.shading && (s.flatShading = 1 === e.shading), void 0 !== e.size && (s.size = e.size), void 0 !== e.sizeAttenuation && (s.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (s.map = t(e.map)), void 0 !== e.matcap && (s.matcap = t(e.matcap)), void 0 !== e.alphaMap && (s.alphaMap = t(e.alphaMap), s.transparent = !0), void 0 !== e.bumpMap && (s.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (s.bumpScale = e.bumpScale), void 0 !== e.normalMap && (s.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (s.normalMapType = e.normalMapType), void 0 !== e.normalScale && (l = e.normalScale, !1 === Array.isArray(l) && (l = [l, l]), s.normalScale = (new i).fromArray(l)), void 0 !== e.displacementMap && (s.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (s.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (s.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (s.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (s.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (s.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (s.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (s.specularMap = t(e.specularMap)), void 0 !== e.envMap && (s.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (s.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (s.reflectivity = e.reflectivity), void 0 !== e.lightMap && (s.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (s.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (s.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (s.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (s.gradientMap = t(e.gradientMap)), s
		},
		setPath: function(e) {
			return this.path = e, this
		},
		setTextures: function(e) {
			return this.textures = e, this
		}
	});
	var $o = {
		decodeText: function(e) {
			if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
			for (var t = "", i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
			try {
				return decodeURIComponent(escape(t))
			} catch (e) {
				return t
			}
		},
		extractUrlBase: function(e) {
			var t = e.lastIndexOf("/");
			return -1 === t ? "./" : e.substr(0, t + 1)
		}
	};
	sr.prototype = Object.assign(Object.create(H.prototype), {
		constructor: sr,
		isInstancedBufferGeometry: !0,
		copy: function(e) {
			return H.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		toJSON: function() {
			var e = H.prototype.toJSON.call(this);
			return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e
		}
	}), ar.prototype = Object.assign(Object.create(A.prototype), {
		constructor: ar,
		isInstancedBufferAttribute: !0,
		copy: function(e) {
			return A.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
		},
		toJSON: function() {
			var e = A.prototype.toJSON.call(this);
			return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
		}
	}), Object.assign(lr.prototype, {
		load: function(e, t, i, n) {
			var r = this,
				o = new En(r.manager);
			o.setPath(r.path), o.load(e, (function(e) {
				t(r.parse(JSON.parse(e)))
			}), i, n)
		},
		parse: function(e) {
			var t = e.isInstancedBufferGeometry ? new sr : new H,
				i = e.data.index;
			if (void 0 !== i) {
				var n = new es[i.type](i.array);
				t.setIndex(new A(n, 1))
			}
			for (var o in i = e.data.attributes) {
				var s = i[o];
				n = new es[s.type](s.array), n = new(s.isInstancedBufferAttribute ? ar : A)(n, s.itemSize, s.normalized), void 0 !== s.name && (n.name = s.name), t.addAttribute(o, n)
			}
			var a = e.data.morphAttributes;
			if (a)
				for (o in a) {
					var l = a[o],
						c = [];
					i = 0;
					for (var h = l.length; i < h; i++) s = l[i], n = new A(n = new es[s.type](s.array), s.itemSize, s.normalized), void 0 !== s.name && (n.name = s.name), c.push(n);
					t.morphAttributes[o] = c
				}
			if (void 0 !== (o = e.data.groups || e.data.drawcalls || e.data.offsets))
				for (i = 0, s = o.length; i !== s; ++i) n = o[i], t.addGroup(n.start, n.count, n.materialIndex);
			return void 0 !== (i = e.data.boundingSphere) && (o = new r, void 0 !== i.center && o.fromArray(i.center), t.boundingSphere = new p(o, i.radius)), e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
		},
		setPath: function(e) {
			return this.path = e, this
		}
	});
	var es = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};
	Object.assign(cr.prototype, {
		crossOrigin: "anonymous",
		load: function(e, t, i, n) {
			var r = this,
				o = void 0 === this.path ? $o.extractUrlBase(e) : this.path;
			this.resourcePath = this.resourcePath || o, (o = new En(r.manager)).setPath(this.path), o.load(e, (function(i) {
				var o = null;
				try {
					o = JSON.parse(i)
				} catch (t) {
					return void 0 !== n && n(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
				}
				void 0 === (i = o.metadata) || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + e) : r.parse(o, t)
			}), i, n)
		},
		setPath: function(e) {
			return this.path = e, this
		},
		setResourcePath: function(e) {
			return this.resourcePath = e, this
		},
		setCrossOrigin: function(e) {
			return this.crossOrigin = e, this
		},
		parse: function(e, t) {
			var i = this.parseShape(e.shapes);
			i = this.parseGeometries(e.geometries, i);
			var n = this.parseImages(e.images, (function() {
				void 0 !== t && t(r)
			}));
			n = this.parseTextures(e.textures, n), n = this.parseMaterials(e.materials, n);
			var r = this.parseObject(e.object, i, n);
			return e.animations && (r.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r), r
		},
		parseShape: function(e) {
			var t = {};
			if (void 0 !== e)
				for (var i = 0, n = e.length; i < n; i++) {
					var r = (new Xn).fromJSON(e[i]);
					t[r.uuid] = r
				}
			return t
		},
		parseGeometries: function(e, t) {
			var i = {};
			if (void 0 !== e)
				for (var n = new lr, r = 0, o = e.length; r < o; r++) {
					var s = e[r];
					switch (s.type) {
						case "PlaneGeometry":
						case "PlaneBufferGeometry":
							var a = new jo[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
							break;
						case "BoxGeometry":
						case "BoxBufferGeometry":
						case "CubeGeometry":
							a = new jo[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
							break;
						case "CircleGeometry":
						case "CircleBufferGeometry":
							a = new jo[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
							break;
						case "CylinderGeometry":
						case "CylinderBufferGeometry":
							a = new jo[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
							break;
						case "ConeGeometry":
						case "ConeBufferGeometry":
							a = new jo[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
							break;
						case "SphereGeometry":
						case "SphereBufferGeometry":
							a = new jo[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
							break;
						case "DodecahedronGeometry":
						case "DodecahedronBufferGeometry":
						case "IcosahedronGeometry":
						case "IcosahedronBufferGeometry":
						case "OctahedronGeometry":
						case "OctahedronBufferGeometry":
						case "TetrahedronGeometry":
						case "TetrahedronBufferGeometry":
							a = new jo[s.type](s.radius, s.detail);
							break;
						case "RingGeometry":
						case "RingBufferGeometry":
							a = new jo[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
							break;
						case "TorusGeometry":
						case "TorusBufferGeometry":
							a = new jo[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
							break;
						case "TorusKnotGeometry":
						case "TorusKnotBufferGeometry":
							a = new jo[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
							break;
						case "TubeGeometry":
						case "TubeBufferGeometry":
							a = new jo[s.type]((new Ko[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
							break;
						case "LatheGeometry":
						case "LatheBufferGeometry":
							a = new jo[s.type](s.points, s.segments, s.phiStart, s.phiLength);
							break;
						case "PolyhedronGeometry":
						case "PolyhedronBufferGeometry":
							a = new jo[s.type](s.vertices, s.indices, s.radius, s.details);
							break;
						case "ShapeGeometry":
						case "ShapeBufferGeometry":
							a = [];
							for (var l = 0, c = s.shapes.length; l < c; l++) {
								var h = t[s.shapes[l]];
								a.push(h)
							}
							a = new jo[s.type](a, s.curveSegments);
							break;
						case "ExtrudeGeometry":
						case "ExtrudeBufferGeometry":
							for (a = [], l = 0, c = s.shapes.length; l < c; l++) h = t[s.shapes[l]], a.push(h);
							void 0 !== (l = s.options.extrudePath) && (s.options.extrudePath = (new Ko[l.type]).fromJSON(l)), a = new jo[s.type](a, s.options);
							break;
						case "BufferGeometry":
						case "InstancedBufferGeometry":
							a = n.parse(s);
							break;
						case "Geometry":
							"THREE" in window && "LegacyJSONLoader" in THREE ? a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
							break;
						default:
							console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
							continue
					}
					a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), i[s.uuid] = a
				}
			return i
		},
		parseMaterials: function(e, t) {
			var i = {},
				n = {};
			if (void 0 !== e) {
				var r = new or;
				r.setTextures(t), t = 0;
				for (var o = e.length; t < o; t++) {
					var s = e[t];
					if ("MultiMaterial" === s.type) {
						for (var a = [], l = 0; l < s.materials.length; l++) {
							var c = s.materials[l];
							void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), a.push(i[c.uuid])
						}
						n[s.uuid] = a
					} else void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)), n[s.uuid] = i[s.uuid]
				}
			}
			return n
		},
		parseAnimations: function(e) {
			for (var t = [], i = 0; i < e.length; i++) {
				var n = e[i],
					r = wn.parse(n);
				void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r)
			}
			return t
		},
		parseImages: function(e, t) {
			function i(e) {
				return n.manager.itemStart(e), o.load(e, (function() {
					n.manager.itemEnd(e)
				}), void 0, (function() {
					n.manager.itemError(e), n.manager.itemEnd(e)
				}))
			}
			var n = this,
				r = {};
			if (void 0 !== e && 0 < e.length) {
				var o = new An(t = new _n(t));
				o.setCrossOrigin(this.crossOrigin), t = 0;
				for (var s = e.length; t < s; t++) {
					var a = e[t],
						l = a.url;
					if (Array.isArray(l)) {
						r[a.uuid] = [];
						for (var c = 0, h = l.length; c < h; c++) {
							var u = l[c];
							u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u, r[a.uuid].push(i(u))
						}
					} else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a.url) ? a.url : n.resourcePath + a.url, r[a.uuid] = i(u)
				}
			}
			return r
		},
		parseTextures: function(e, t) {
			function i(e, t) {
				return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
			}
			var n = {};
			if (void 0 !== e)
				for (var r = 0, o = e.length; r < o; r++) {
					var a = e[r];
					void 0 === a.image && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), void 0 === t[a.image] && console.warn("THREE.ObjectLoader: Undefined image", a.image);
					var l = Array.isArray(t[a.image]) ? new ae(t[a.image]) : new s(t[a.image]);
					l.needsUpdate = !0, l.uuid = a.uuid, void 0 !== a.name && (l.name = a.name), void 0 !== a.mapping && (l.mapping = i(a.mapping, ts)), void 0 !== a.offset && l.offset.fromArray(a.offset), void 0 !== a.repeat && l.repeat.fromArray(a.repeat), void 0 !== a.center && l.center.fromArray(a.center), void 0 !== a.rotation && (l.rotation = a.rotation), void 0 !== a.wrap && (l.wrapS = i(a.wrap[0], is), l.wrapT = i(a.wrap[1], is)), void 0 !== a.format && (l.format = a.format), void 0 !== a.type && (l.type = a.type), void 0 !== a.encoding && (l.encoding = a.encoding), void 0 !== a.minFilter && (l.minFilter = i(a.minFilter, ns)), void 0 !== a.magFilter && (l.magFilter = i(a.magFilter, ns)), void 0 !== a.anisotropy && (l.anisotropy = a.anisotropy), void 0 !== a.flipY && (l.flipY = a.flipY), void 0 !== a.premultiplyAlpha && (l.premultiplyAlpha = a.premultiplyAlpha), void 0 !== a.unpackAlignment && (l.unpackAlignment = a.unpackAlignment), n[a.uuid] = l
				}
			return n
		},
		parseObject: function(e, t, i) {
			function n(e) {
				return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
			}

			function r(e) {
				if (void 0 !== e) {
					if (Array.isArray(e)) {
						for (var t = [], n = 0, r = e.length; n < r; n++) {
							var o = e[n];
							void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), t.push(i[o])
						}
						return t
					}
					return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e]
				}
			}
			switch (e.type) {
				case "Scene":
					var o = new Ct;
					void 0 !== e.background && Number.isInteger(e.background) && (o.background = new b(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new Lt(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new At(e.fog.color, e.fog.density)));
					break;
				case "PerspectiveCamera":
					o = new xt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view));
					break;
				case "OrthographicCamera":
					o = new er(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.view && (o.view = Object.assign({}, e.view));
					break;
				case "AmbientLight":
					o = new nr(e.color, e.intensity);
					break;
				case "DirectionalLight":
					o = new ir(e.color, e.intensity);
					break;
				case "PointLight":
					o = new $n(e.color, e.intensity, e.distance, e.decay);
					break;
				case "RectAreaLight":
					o = new rr(e.color, e.intensity, e.width, e.height);
					break;
				case "SpotLight":
					o = new Kn(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
					break;
				case "HemisphereLight":
					o = new Zn(e.color, e.groundColor, e.intensity);
					break;
				case "SkinnedMesh":
					console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
				case "Mesh":
					o = n(e.geometry);
					var s = r(e.material);
					o = o.bones && 0 < o.bones.length ? new zt(o, s) : new Z(o, s), void 0 !== e.drawMode && o.setDrawMode(e.drawMode);
					break;
				case "LOD":
					o = new Dt;
					break;
				case "Line":
					o = new Ht(n(e.geometry), r(e.material), e.mode);
					break;
				case "LineLoop":
					o = new Ut(n(e.geometry), r(e.material));
					break;
				case "LineSegments":
					o = new Ft(n(e.geometry), r(e.material));
					break;
				case "PointCloud":
				case "Points":
					o = new Gt(n(e.geometry), r(e.material));
					break;
				case "Sprite":
					o = new Ot(r(e.material));
					break;
				case "Group":
					o = new bt;
					break;
				default:
					o = new S
			}
			if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (o.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.frustumCulled && (o.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (o.renderOrder = e.renderOrder), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.layers && (o.layers.mask = e.layers), void 0 !== e.children) {
				s = e.children;
				for (var a = 0; a < s.length; a++) o.add(this.parseObject(s[a], t, i))
			}
			if ("LOD" === e.type)
				for (e = e.levels, s = 0; s < e.length; s++) {
					a = e[s];
					var l = o.getObjectByProperty("uuid", a.object);
					void 0 !== l && o.addLevel(l, a.distance)
				}
			return o
		}
	});
	var ts = {
			UVMapping: 300,
			CubeReflectionMapping: 301,
			CubeRefractionMapping: 302,
			EquirectangularReflectionMapping: 303,
			EquirectangularRefractionMapping: 304,
			SphericalReflectionMapping: 305,
			CubeUVReflectionMapping: 306,
			CubeUVRefractionMapping: 307
		},
		is = {
			RepeatWrapping: 1e3,
			ClampToEdgeWrapping: 1001,
			MirroredRepeatWrapping: 1002
		},
		ns = {
			NearestFilter: 1003,
			NearestMipMapNearestFilter: 1004,
			NearestMipMapLinearFilter: 1005,
			LinearFilter: 1006,
			LinearMipMapNearestFilter: 1007,
			LinearMipMapLinearFilter: 1008
		};
	hr.prototype = {
		constructor: hr,
		setOptions: function(e) {
			return this.options = e, this
		},
		load: function(e, t, i, n) {
			void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
			var r = this,
				o = Wo.get(e);
			if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
				t && t(o), r.manager.itemEnd(e)
			}), 0), o;
			fetch(e).then((function(e) {
				return e.blob()
			})).then((function(e) {
				return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options)
			})).then((function(i) {
				Wo.add(e, i), t && t(i), r.manager.itemEnd(e)
			})).catch((function(t) {
				n && n(t), r.manager.itemError(e), r.manager.itemEnd(e)
			})), r.manager.itemStart(e)
		},
		setCrossOrigin: function() {
			return this
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}, Object.assign(ur.prototype, {
		moveTo: function(e, t) {
			this.currentPath = new qn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
		},
		lineTo: function(e, t) {
			this.currentPath.lineTo(e, t)
		},
		quadraticCurveTo: function(e, t, i, n) {
			this.currentPath.quadraticCurveTo(e, t, i, n)
		},
		bezierCurveTo: function(e, t, i, n, r, o) {
			this.currentPath.bezierCurveTo(e, t, i, n, r, o)
		},
		splineThru: function(e) {
			this.currentPath.splineThru(e)
		},
		toShapes: function(e, t) {
			function i(e) {
				for (var t = [], i = 0, n = e.length; i < n; i++) {
					var r = e[i],
						o = new Xn;
					o.curves = r.curves, t.push(o)
				}
				return t
			}

			function n(e, t) {
				for (var i = t.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
					var s = t[r],
						a = t[o],
						l = a.x - s.x,
						c = a.y - s.y;
					if (Math.abs(c) > Number.EPSILON) {
						if (0 > c && (s = t[o], l = -l, a = t[r], c = -c), !(e.y < s.y || e.y > a.y))
							if (e.y === s.y) {
								if (e.x === s.x) return !0
							} else {
								if (0 == (r = c * (e.x - s.x) - l * (e.y - s.y))) return !0;
								0 > r || (n = !n)
							}
					} else if (e.y === s.y && (a.x <= e.x && e.x <= s.x || s.x <= e.x && e.x <= a.x)) return !0
				}
				return n
			}
			var r = Fo.isClockWise,
				o = this.subPaths;
			if (0 === o.length) return [];
			if (!0 === t) return i(o);
			if (t = [], 1 === o.length) {
				var s = o[0],
					a = new Xn;
				return a.curves = s.curves, t.push(a), t
			}
			var l = !r(o[0].getPoints());
			l = e ? !l : l, a = [];
			var c = [],
				h = [],
				u = 0;
			c[u] = void 0, h[u] = [];
			for (var d = 0, p = o.length; d < p; d++) {
				var f = (s = o[d]).getPoints(),
					m = r(f);
				(m = e ? !m : m) ? (!l && c[u] && u++, c[u] = {
					s: new Xn,
					p: f
				}, c[u].s.curves = s.curves, l && u++, h[u] = []) : h[u].push({
					h: s,
					p: f[0]
				})
			}
			if (!c[0]) return i(o);
			if (1 < c.length) {
				for (d = !1, e = [], r = 0, o = c.length; r < o; r++) a[r] = [];
				for (r = 0, o = c.length; r < o; r++)
					for (s = h[r], m = 0; m < s.length; m++) {
						for (l = s[m], u = !0, f = 0; f < c.length; f++) n(l.p, c[f].p) && (r !== f && e.push({
							froms: r,
							tos: f,
							hole: m
						}), u ? (u = !1, a[f].push(l)) : d = !0);
						u && a[r].push(l)
					}
				0 < e.length && (d || (h = a))
			}
			for (d = 0, r = c.length; d < r; d++)
				for (a = c[d].s, t.push(a), o = 0, s = (e = h[d]).length; o < s; o++) a.holes.push(e[o].h);
			return t
		}
	}), Object.assign(dr.prototype, {
		isFont: !0,
		generateShapes: function(e, t) {
			void 0 === t && (t = 100);
			var i = [],
				n = t;
			t = this.data;
			var r = Array.from ? Array.from(e) : String(e).split("");
			n /= t.resolution;
			var o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n;
			e = [];
			for (var s = 0, a = 0, l = 0; l < r.length; l++) {
				var c = r[l];
				if ("\n" === c) s = 0, a -= o;
				else {
					var h = n,
						u = s,
						d = a;
					if (c = t.glyphs[c] || t.glyphs["?"]) {
						var p = new ur;
						if (c.o)
							for (var f = c._cachedOutline || (c._cachedOutline = c.o.split(" ")), m = 0, g = f.length; m < g;) switch (f[m++]) {
								case "m":
									var v = f[m++] * h + u,
										y = f[m++] * h + d;
									p.moveTo(v, y);
									break;
								case "l":
									v = f[m++] * h + u, y = f[m++] * h + d, p.lineTo(v, y);
									break;
								case "q":
									var b = f[m++] * h + u,
										w = f[m++] * h + d,
										x = f[m++] * h + u,
										_ = f[m++] * h + d;
									p.quadraticCurveTo(x, _, b, w);
									break;
								case "b":
									b = f[m++] * h + u, w = f[m++] * h + d, x = f[m++] * h + u, _ = f[m++] * h + d, v = f[m++] * h + u, y = f[m++] * h + d, p.bezierCurveTo(x, _, v, y, b, w)
							}
						h = {
							offsetX: c.ha * h,
							path: p
						}
					} else h = void 0;
					s += h.offsetX, e.push(h.path)
				}
			}
			for (t = 0, r = e.length; t < r; t++) Array.prototype.push.apply(i, e[t].toShapes());
			return i
		}
	}), Object.assign(pr.prototype, {
		load: function(e, t, i, n) {
			var r = this,
				o = new En(this.manager);
			o.setPath(this.path), o.load(e, (function(e) {
				try {
					var i = JSON.parse(e)
				} catch (t) {
					console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
				}
				e = r.parse(i), t && t(e)
			}), i, n)
		},
		parse: function(e) {
			return new dr(e)
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), fr.Handlers = {
		handlers: [],
		add: function(e, t) {
			this.handlers.push(e, t)
		},
		get: function(e) {
			for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
				var r = t[i + 1];
				if (t[i].test(e)) return r
			}
			return null
		}
	}, Object.assign(fr.prototype, {
		crossOrigin: "anonymous",
		onLoadStart: function() {},
		onLoadProgress: function() {},
		onLoadComplete: function() {},
		initMaterials: function(e, t, i) {
			for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i);
			return n
		},
		createMaterial: function() {
			var e = {
					NoBlending: 0,
					NormalBlending: 1,
					AdditiveBlending: 2,
					SubtractiveBlending: 3,
					MultiplyBlending: 4,
					CustomBlending: 5
				},
				t = new b,
				i = new Cn,
				n = new or;
			return function(r, o, s) {
				function a(e, t, n, r, a) {
					e = o + e;
					var l = fr.Handlers.get(e);
					return null !== l ? e = l.load(e) : (i.setCrossOrigin(s), e = i.load(e)), void 0 !== t && (e.repeat.fromArray(t), 1 !== t[0] && (e.wrapS = 1e3), 1 !== t[1] && (e.wrapT = 1e3)), void 0 !== n && e.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (e.wrapS = 1e3), "mirror" === r[0] && (e.wrapS = 1002), "repeat" === r[1] && (e.wrapT = 1e3), "mirror" === r[1] && (e.wrapT = 1002)), void 0 !== a && (e.anisotropy = a), t = uo.generateUUID(), c[t] = e, t
				}
				var l, c = {},
					h = {
						uuid: uo.generateUUID(),
						type: "MeshLambertMaterial"
					};
				for (l in r) {
					var u = r[l];
					switch (l) {
						case "DbgColor":
						case "DbgIndex":
						case "opticalDensity":
						case "illumination":
							break;
						case "DbgName":
							h.name = u;
							break;
						case "blending":
							h.blending = e[u];
							break;
						case "colorAmbient":
						case "mapAmbient":
							console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
							break;
						case "colorDiffuse":
							h.color = t.fromArray(u).getHex();
							break;
						case "colorSpecular":
							h.specular = t.fromArray(u).getHex();
							break;
						case "colorEmissive":
							h.emissive = t.fromArray(u).getHex();
							break;
						case "specularCoef":
							h.shininess = u;
							break;
						case "shading":
							"basic" === u.toLowerCase() && (h.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (h.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (h.type = "MeshStandardMaterial");
							break;
						case "mapDiffuse":
							h.map = a(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
							break;
						case "mapDiffuseRepeat":
						case "mapDiffuseOffset":
						case "mapDiffuseWrap":
						case "mapDiffuseAnisotropy":
							break;
						case "mapEmissive":
							h.emissiveMap = a(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
							break;
						case "mapEmissiveRepeat":
						case "mapEmissiveOffset":
						case "mapEmissiveWrap":
						case "mapEmissiveAnisotropy":
							break;
						case "mapLight":
							h.lightMap = a(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
							break;
						case "mapLightRepeat":
						case "mapLightOffset":
						case "mapLightWrap":
						case "mapLightAnisotropy":
							break;
						case "mapAO":
							h.aoMap = a(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
							break;
						case "mapAORepeat":
						case "mapAOOffset":
						case "mapAOWrap":
						case "mapAOAnisotropy":
							break;
						case "mapBump":
							h.bumpMap = a(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
							break;
						case "mapBumpScale":
							h.bumpScale = u;
							break;
						case "mapBumpRepeat":
						case "mapBumpOffset":
						case "mapBumpWrap":
						case "mapBumpAnisotropy":
							break;
						case "mapNormal":
							h.normalMap = a(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
							break;
						case "mapNormalFactor":
							h.normalScale = u;
							break;
						case "mapNormalRepeat":
						case "mapNormalOffset":
						case "mapNormalWrap":
						case "mapNormalAnisotropy":
							break;
						case "mapSpecular":
							h.specularMap = a(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
							break;
						case "mapSpecularRepeat":
						case "mapSpecularOffset":
						case "mapSpecularWrap":
						case "mapSpecularAnisotropy":
							break;
						case "mapMetalness":
							h.metalnessMap = a(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
							break;
						case "mapMetalnessRepeat":
						case "mapMetalnessOffset":
						case "mapMetalnessWrap":
						case "mapMetalnessAnisotropy":
							break;
						case "mapRoughness":
							h.roughnessMap = a(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
							break;
						case "mapRoughnessRepeat":
						case "mapRoughnessOffset":
						case "mapRoughnessWrap":
						case "mapRoughnessAnisotropy":
							break;
						case "mapAlpha":
							h.alphaMap = a(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
							break;
						case "mapAlphaRepeat":
						case "mapAlphaOffset":
						case "mapAlphaWrap":
						case "mapAlphaAnisotropy":
							break;
						case "flipSided":
							h.side = 1;
							break;
						case "doubleSided":
							h.side = 2;
							break;
						case "transparency":
							console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), h.opacity = u;
							break;
						case "depthTest":
						case "depthWrite":
						case "colorWrite":
						case "opacity":
						case "reflectivity":
						case "transparent":
						case "visible":
						case "wireframe":
							h[l] = u;
							break;
						case "vertexColors":
							!0 === u && (h.vertexColors = 2), "face" === u && (h.vertexColors = 1);
							break;
						default:
							console.error("THREE.Loader.createMaterial: Unsupported", l, u)
					}
				}
				return "MeshBasicMaterial" === h.type && delete h.emissive, "MeshPhongMaterial" !== h.type && delete h.specular, 1 > h.opacity && (h.transparent = !0), n.setTextures(c), n.parse(h)
			}
		}()
	});
	var rs, os, ss, as = {
		getContext: function() {
			return void 0 === rs && (rs = new(window.AudioContext || window.webkitAudioContext)), rs
		},
		setContext: function(e) {
			rs = e
		}
	};
	Object.assign(mr.prototype, {
		load: function(e, t, i, n) {
			var r = new En(this.manager);
			r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, (function(e) {
				e = e.slice(0), as.getContext().decodeAudioData(e, (function(e) {
					t(e)
				}))
			}), i, n)
		},
		setPath: function(e) {
			return this.path = e, this
		}
	}), Object.assign(gr.prototype, {
		isSphericalHarmonics3: !0,
		set: function(e) {
			for (var t = 0; 9 > t; t++) this.coefficients[t].copy(e[t]);
			return this
		},
		zero: function() {
			for (var e = 0; 9 > e; e++) this.coefficients[e].set(0, 0, 0);
			return this
		},
		getAt: function(e, t) {
			var i = e.x,
				n = e.y;
			e = e.z;
			var r = this.coefficients;
			return t = .282095 * r[0], t += .488603 * r[1] * n, t += .488603 * r[2] * e, t += .488603 * r[3] * i, t += 1.092548 * r[4] * i * n, t += 1.092548 * r[5] * n * e, t += .315392 * r[6] * (3 * e * e - 1), (t += 1.092548 * r[7] * i * e) + .546274 * r[8] * (i * i - n * n)
		},
		getIrradianceAt: function(e, t) {
			var i = e.x,
				n = e.y;
			e = e.z;
			var r = this.coefficients;
			return t = .886227 * r[0], t += 1.023328 * r[1] * n, t += 1.023328 * r[2] * e, t += 1.023328 * r[3] * i, t += .858086 * r[4] * i * n, t += .858086 * r[5] * n * e, t += r[6] * (.743125 * e * e - .247708), (t += .858086 * r[7] * i * e) + .429043 * r[8] * (i * i - n * n)
		},
		add: function(e) {
			for (var t = 0; 9 > t; t++) this.coefficients[t].add(e.coefficients[t]);
			return this
		},
		scale: function(e) {
			for (var t = 0; 9 > t; t++) this.coefficients[t].multiplyScalar(e);
			return this
		},
		lerp: function(e, t) {
			for (var i = 0; 9 > i; i++) this.coefficients[i].lerp(e.coefficients[i], t);
			return this
		},
		equals: function(e) {
			for (var t = 0; 9 > t; t++)
				if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
			return !0
		},
		copy: function(e) {
			return this.set(e.coefficients)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		fromArray: function(e) {
			for (var t = this.coefficients, i = 0; 9 > i; i++) t[i].fromArray(e, 3 * i);
			return this
		},
		toArray: function() {
			for (var e = [], t = this.coefficients, i = 0; 9 > i; i++) t[i].toArray(e, 3 * i);
			return e
		}
	}), Object.assign(gr, {
		getBasisAt: function(e, t) {
			var i = e.x,
				n = e.y;
			e = e.z, t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * e, t[3] = .488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * i * e, t[8] = .546274 * (i * i - n * n)
		}
	}), vr.prototype = Object.assign(Object.create(Yn.prototype), {
		constructor: vr,
		isLightProbe: !0,
		copy: function(e) {
			return Yn.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this
		},
		toJSON: function(e) {
			return Yn.prototype.toJSON.call(this, e)
		}
	}), yr.prototype = Object.assign(Object.create(vr.prototype), {
		constructor: yr,
		isHemisphereLightProbe: !0,
		copy: function(e) {
			return vr.prototype.copy.call(this, e), this
		},
		toJSON: function(e) {
			return vr.prototype.toJSON.call(this, e)
		}
	}), br.prototype = Object.assign(Object.create(vr.prototype), {
		constructor: br,
		isAmbientLightProbe: !0,
		copy: function(e) {
			return vr.prototype.copy.call(this, e), this
		},
		toJSON: function(e) {
			return vr.prototype.toJSON.call(this, e)
		}
	}), Object.assign(wr.prototype, {
		update: function() {
			var e, t, i, n, r, o, s, a, l = new g,
				c = new g;
			return function(h) {
				if (e !== this || t !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || o !== h.far || s !== h.zoom || a !== this.eyeSep) {
					e = this, t = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, o = h.far, s = h.zoom;
					var u = h.projectionMatrix.clone(),
						d = (a = this.eyeSep / 2) * r / t,
						p = r * Math.tan(uo.DEG2RAD * i * .5) / s;
					c.elements[12] = -a, l.elements[12] = a;
					var f = -p * n + d,
						m = p * n + d;
					u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraL.projectionMatrix.copy(u), f = -p * n - d, m = p * n - d, u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraR.projectionMatrix.copy(u)
				}
				this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(c), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(l)
			}
		}()
	}), xr.prototype = Object.create(S.prototype), xr.prototype.constructor = xr, Object.assign(_r.prototype, {
		start: function() {
			this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
		},
		stop: function() {
			this.getElapsedTime(), this.autoStart = this.running = !1
		},
		getElapsedTime: function() {
			return this.getDelta(), this.elapsedTime
		},
		getDelta: function() {
			var e = 0;
			if (this.autoStart && !this.running) return this.start(), 0;
			if (this.running) {
				var t = ("undefined" == typeof performance ? Date : performance).now();
				e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
			}
			return e
		}
	}), Er.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Er,
		getInput: function() {
			return this.gain
		},
		removeFilter: function() {
			return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
		},
		getFilter: function() {
			return this.filter
		},
		setFilter: function(e) {
			return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
		},
		getMasterVolume: function() {
			return this.gain.gain.value
		},
		setMasterVolume: function(e) {
			return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
		},
		updateMatrixWorld: function() {
			var e = new r,
				t = new n,
				i = new r,
				o = new r,
				s = new _r;
			return function(n) {
				S.prototype.updateMatrixWorld.call(this, n), n = this.context.listener;
				var r = this.up;
				if (this.timeDelta = s.getDelta(), this.matrixWorld.decompose(e, t, i), o.set(0, 0, -1).applyQuaternion(t), n.positionX) {
					var a = this.context.currentTime + this.timeDelta;
					n.positionX.linearRampToValueAtTime(e.x, a), n.positionY.linearRampToValueAtTime(e.y, a), n.positionZ.linearRampToValueAtTime(e.z, a), n.forwardX.linearRampToValueAtTime(o.x, a), n.forwardY.linearRampToValueAtTime(o.y, a), n.forwardZ.linearRampToValueAtTime(o.z, a), n.upX.linearRampToValueAtTime(r.x, a), n.upY.linearRampToValueAtTime(r.y, a), n.upZ.linearRampToValueAtTime(r.z, a)
				} else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z, r.x, r.y, r.z)
			}
		}()
	}), Mr.prototype = Object.assign(Object.create(S.prototype), {
		constructor: Mr,
		getOutput: function() {
			return this.gain
		},
		setNodeSource: function(e) {
			return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
		},
		setMediaElementSource: function(e) {
			return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
		},
		setBuffer: function(e) {
			return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
		},
		play: function() {
			if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
			else {
				if (!1 !== this.hasPlaybackControl) {
					var e = this.context.createBufferSource();
					return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
				}
				console.warn("THREE.Audio: this Audio has no playback control.")
			}
		},
		pause: function() {
			if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
			console.warn("THREE.Audio: this Audio has no playback control.")
		},
		stop: function() {
			if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
			console.warn("THREE.Audio: this Audio has no playback control.")
		},
		connect: function() {
			if (0 < this.filters.length) {
				this.source.connect(this.filters[0]);
				for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
				this.filters[this.filters.length - 1].connect(this.getOutput())
			} else this.source.connect(this.getOutput());
			return this
		},
		disconnect: function() {
			if (0 < this.filters.length) {
				this.source.disconnect(this.filters[0]);
				for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
				this.filters[this.filters.length - 1].disconnect(this.getOutput())
			} else this.source.disconnect(this.getOutput());
			return this
		},
		getFilters: function() {
			return this.filters
		},
		setFilters: function(e) {
			return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
		},
		setDetune: function(e) {
			if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
		},
		getDetune: function() {
			return this.detune
		},
		getFilter: function() {
			return this.getFilters()[0]
		},
		setFilter: function(e) {
			return this.setFilters(e ? [e] : [])
		},
		setPlaybackRate: function(e) {
			if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
			console.warn("THREE.Audio: this Audio has no playback control.")
		},
		getPlaybackRate: function() {
			return this.playbackRate
		},
		onEnded: function() {
			this.isPlaying = !1
		},
		getLoop: function() {
			return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
		},
		setLoop: function(e) {
			if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
			console.warn("THREE.Audio: this Audio has no playback control.")
		},
		getVolume: function() {
			return this.gain.gain.value
		},
		setVolume: function(e) {
			return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
		}
	}), Sr.prototype = Object.assign(Object.create(Mr.prototype), {
		constructor: Sr,
		getOutput: function() {
			return this.panner
		},
		getRefDistance: function() {
			return this.panner.refDistance
		},
		setRefDistance: function(e) {
			return this.panner.refDistance = e, this
		},
		getRolloffFactor: function() {
			return this.panner.rolloffFactor
		},
		setRolloffFactor: function(e) {
			return this.panner.rolloffFactor = e, this
		},
		getDistanceModel: function() {
			return this.panner.distanceModel
		},
		setDistanceModel: function(e) {
			return this.panner.distanceModel = e, this
		},
		getMaxDistance: function() {
			return this.panner.maxDistance
		},
		setMaxDistance: function(e) {
			return this.panner.maxDistance = e, this
		},
		setDirectionalCone: function(e, t, i) {
			return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
		},
		updateMatrixWorld: function() {
			var e = new r,
				t = new n,
				i = new r,
				o = new r;
			return function(n) {
				if (S.prototype.updateMatrixWorld.call(this, n), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
					if (this.matrixWorld.decompose(e, t, i), o.set(0, 0, 1).applyQuaternion(t), (n = this.panner).positionX) {
						var r = this.context.currentTime + this.listener.timeDelta;
						n.positionX.linearRampToValueAtTime(e.x, r), n.positionY.linearRampToValueAtTime(e.y, r), n.positionZ.linearRampToValueAtTime(e.z, r), n.orientationX.linearRampToValueAtTime(o.x, r), n.orientationY.linearRampToValueAtTime(o.y, r), n.orientationZ.linearRampToValueAtTime(o.z, r)
					} else n.setPosition(e.x, e.y, e.z), n.setOrientation(o.x, o.y, o.z)
			}
		}()
	}), Object.assign(Tr.prototype, {
		getFrequencyData: function() {
			return this.analyser.getByteFrequencyData(this.data), this.data
		},
		getAverageFrequency: function() {
			for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i];
			return e / t.length
		}
	}), Object.assign(Ar.prototype, {
		accumulate: function(e, t) {
			var i = this.buffer,
				n = this.valueSize;
			e = e * n + n;
			var r = this.cumulativeWeight;
			if (0 === r) {
				for (r = 0; r !== n; ++r) i[e + r] = i[r];
				r = t
			} else r += t, this._mixBufferRegion(i, e, 0, t / r, n);
			this.cumulativeWeight = r
		},
		apply: function(e) {
			var t = this.valueSize,
				i = this.buffer;
			e = e * t + t;
			var n = this.cumulativeWeight,
				r = this.binding;
			this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, e, 3 * t, 1 - n, t), n = t;
			for (var o = t + t; n !== o; ++n)
				if (i[n] !== i[n + t]) {
					r.setValue(i, e);
					break
				}
		},
		saveOriginalState: function() {
			var e = this.buffer,
				t = this.valueSize,
				i = 3 * t;
			this.binding.getValue(e, i);
			for (var n = t; n !== i; ++n) e[n] = e[i + n % t];
			this.cumulativeWeight = 0
		},
		restoreOriginalState: function() {
			this.binding.setValue(this.buffer, 3 * this.valueSize)
		},
		_select: function(e, t, i, n, r) {
			if (.5 <= n)
				for (n = 0; n !== r; ++n) e[t + n] = e[i + n]
		},
		_slerp: function(e, t, i, r) {
			n.slerpFlat(e, t, e, t, e, i, r)
		},
		_lerp: function(e, t, i, n, r) {
			for (var o = 1 - n, s = 0; s !== r; ++s) {
				var a = t + s;
				e[a] = e[a] * o + e[i + s] * n
			}
		}
	}), Object.assign(Lr.prototype, {
		getValue: function(e, t) {
			this.bind();
			var i = this._bindings[this._targetGroup.nCachedObjects_];
			void 0 !== i && i.getValue(e, t)
		},
		setValue: function(e, t) {
			for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
		},
		bind: function() {
			for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
		},
		unbind: function() {
			for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
		}
	}), Object.assign(Cr, {
		Composite: Lr,
		create: function(e, t, i) {
			return e && e.isAnimationObjectGroup ? new Cr.Composite(e, t, i) : new Cr(e, t, i)
		},
		sanitizeNodeName: function() {
			var e = /[\[\]\.:\/]/g;
			return function(t) {
				return t.replace(/\s/g, "_").replace(e, "")
			}
		}(),
		parseTrackName: function() {
			var e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
				t = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
			e = /(WCOD+)?/.source.replace("WCOD", e);
			var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
				n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
				r = new RegExp("^" + t + e + i + n + "$"),
				o = ["material", "materials", "bones"];
			return function(e) {
				var t = r.exec(e);
				if (!t) throw Error("PropertyBinding: Cannot parse trackName: " + e);
				var i = (t = {
					nodeName: t[2],
					objectName: t[3],
					objectIndex: t[4],
					propertyName: t[5],
					propertyIndex: t[6]
				}).nodeName && t.nodeName.lastIndexOf(".");
				if (void 0 !== i && -1 !== i) {
					var n = t.nodeName.substring(i + 1); - 1 !== o.indexOf(n) && (t.nodeName = t.nodeName.substring(0, i), t.objectName = n)
				}
				if (null === t.propertyName || 0 === t.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
				return t
			}
		}(),
		findNode: function(e, t) {
			if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
			if (e.skeleton) {
				var i = e.skeleton.getBoneByName(t);
				if (void 0 !== i) return i
			}
			if (e.children) {
				var n = function(e) {
					for (var i = 0; i < e.length; i++) {
						var r = e[i];
						if (r.name === t || r.uuid === t || (r = n(r.children))) return r
					}
					return null
				};
				if (e = n(e.children)) return e
			}
			return null
		}
	}), Object.assign(Cr.prototype, {
		_getValue_unavailable: function() {},
		_setValue_unavailable: function() {},
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
		GetterByBindingType: [function(e, t) {
			e[t] = this.node[this.propertyName]
		}, function(e, t) {
			for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
		}, function(e, t) {
			e[t] = this.resolvedProperty[this.propertyIndex]
		}, function(e, t) {
			this.resolvedProperty.toArray(e, t)
		}],
		SetterByBindingTypeAndVersioning: [
			[function(e, t) {
				this.targetObject[this.propertyName] = e[t]
			}, function(e, t) {
				this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
			}, function(e, t) {
				this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
			}],
			[function(e, t) {
				for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
			}, function(e, t) {
				for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
				this.targetObject.needsUpdate = !0
			}, function(e, t) {
				for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}],
			[function(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t]
			}, function(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
			}, function(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
			}],
			[function(e, t) {
				this.resolvedProperty.fromArray(e, t)
			}, function(e, t) {
				this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
			}, function(e, t) {
				this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
			}]
		],
		getValue: function(e, t) {
			this.bind(), this.getValue(e, t)
		},
		setValue: function(e, t) {
			this.bind(), this.setValue(e, t)
		},
		bind: function() {
			var e = this.node,
				t = this.parsedPath,
				i = t.objectName,
				n = t.propertyName,
				r = t.propertyIndex;
			if (e || (this.node = e = Cr.findNode(this.rootNode, t.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
				if (i) {
					var o = t.objectIndex;
					switch (i) {
						case "materials":
							if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
							if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
							e = e.material.materials;
							break;
						case "bones":
							if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
							for (e = e.skeleton.bones, i = 0; i < e.length; i++)
								if (e[i].name === o) {
									o = i;
									break
								} break;
						default:
							if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
							e = e[i]
					}
					if (void 0 !== o) {
						if (void 0 === e[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
						e = e[o]
					}
				}
				if (void 0 === (o = e[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + n + " but it wasn't found.", e);
				else {
					if (t = this.Versioning.None, this.targetObject = e, void 0 !== e.needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) {
						if ("morphTargetInfluences" === n) {
							if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
							if (e.geometry.isBufferGeometry) {
								if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
								for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
									if (e.geometry.morphAttributes.position[i].name === r) {
										r = i;
										break
									}
							} else {
								if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
								for (i = 0; i < this.node.geometry.morphTargets.length; i++)
									if (e.geometry.morphTargets[i].name === r) {
										r = i;
										break
									}
							}
						}
						i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
					} else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n;
					this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][t]
				}
			} else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
		},
		unbind: function() {
			this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
		}
	}), Object.assign(Cr.prototype, {
		_getValue_unbound: Cr.prototype.getValue,
		_setValue_unbound: Cr.prototype.setValue
	}), Object.assign(Pr.prototype, {
		isAnimationObjectGroup: !0,
		add: function() {
			for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, s = this._bindings, a = s.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) {
				var u = arguments[c],
					d = u.uuid,
					p = n[d];
				if (void 0 === p) {
					p = t++, n[d] = p, e.push(u), d = 0;
					for (var f = a; d !== f; ++d) s[d].push(new Cr(u, r[d], o[d]))
				} else if (p < i) {
					l = e[p];
					var m = --i;
					for (n[(f = e[m]).uuid] = p, e[p] = f, n[d] = m, e[m] = u, d = 0, f = a; d !== f; ++d) {
						var g = s[d],
							v = g[p];
						g[p] = g[m], void 0 === v && (v = new Cr(u, r[d], o[d])), g[m] = v
					}
				} else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
			}
			this.nCachedObjects_ = i
		},
		remove: function() {
			for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, s = arguments.length; o !== s; ++o) {
				var a = arguments[o],
					l = a.uuid,
					c = i[l];
				if (void 0 !== c && c >= t) {
					var h = t++,
						u = e[h];
					for (i[u.uuid] = c, e[c] = u, i[l] = h, e[h] = a, a = 0, l = r; a !== l; ++a) {
						var d = (u = n[a])[c];
						u[c] = u[h], u[h] = d
					}
				}
			}
			this.nCachedObjects_ = t
		},
		uncache: function() {
			for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, s = 0, a = arguments.length; s !== a; ++s) {
				var l = arguments[s].uuid,
					c = n[l];
				if (void 0 !== c)
					if (delete n[l], c < i) {
						var h = e[l = --i],
							u = --t,
							d = e[u];
						for (n[h.uuid] = c, e[c] = h, n[d.uuid] = l, e[l] = d, e.pop(), h = 0, d = o; h !== d; ++h) {
							var p = r[h],
								f = p[u];
							p[c] = p[l], p[l] = f, p.pop()
						}
					} else
						for (n[(d = e[u = --t]).uuid] = c, e[c] = d, e.pop(), h = 0, d = o; h !== d; ++h)(p = r[h])[c] = p[u], p.pop()
			}
			this.nCachedObjects_ = i
		},
		subscribe_: function(e, t) {
			var i = this._bindingsIndicesByPath,
				n = i[e],
				r = this._bindings;
			if (void 0 !== n) return r[n];
			var o = this._paths,
				s = this._parsedPaths,
				a = this._objects,
				l = this.nCachedObjects_,
				c = Array(a.length);
			for (n = r.length, i[e] = n, o.push(e), s.push(t), r.push(c), i = l, n = a.length; i !== n; ++i) c[i] = new Cr(a[i], e, t);
			return c
		},
		unsubscribe_: function(e) {
			var t = this._bindingsIndicesByPath,
				i = t[e];
			if (void 0 !== i) {
				var n = this._paths,
					r = this._parsedPaths,
					o = this._bindings,
					s = o.length - 1,
					a = o[s];
				t[e[s]] = i, o[i] = a, o.pop(), r[i] = r[s], r.pop(), n[i] = n[s], n.pop()
			}
		}
	}), Object.assign(Ir.prototype, {
		play: function() {
			return this._mixer._activateAction(this), this
		},
		stop: function() {
			return this._mixer._deactivateAction(this), this.reset()
		},
		reset: function() {
			return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
		},
		isRunning: function() {
			return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
		},
		isScheduled: function() {
			return this._mixer._isActiveAction(this)
		},
		startAt: function(e) {
			return this._startTime = e, this
		},
		setLoop: function(e, t) {
			return this.loop = e, this.repetitions = t, this
		},
		setEffectiveWeight: function(e) {
			return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
		},
		getEffectiveWeight: function() {
			return this._effectiveWeight
		},
		fadeIn: function(e) {
			return this._scheduleFading(e, 0, 1)
		},
		fadeOut: function(e) {
			return this._scheduleFading(e, 1, 0)
		},
		crossFadeFrom: function(e, t, i) {
			if (e.fadeOut(t), this.fadeIn(t), i) {
				i = this._clip.duration;
				var n = e._clip.duration,
					r = i / n;
				e.warp(1, n / i, t), this.warp(r, 1, t)
			}
			return this
		},
		crossFadeTo: function(e, t, i) {
			return e.crossFadeFrom(this, t, i)
		},
		stopFading: function() {
			var e = this._weightInterpolant;
			return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
		},
		setEffectiveTimeScale: function(e) {
			return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
		},
		getEffectiveTimeScale: function() {
			return this._effectiveTimeScale
		},
		setDuration: function(e) {
			return this.timeScale = this._clip.duration / e, this.stopWarping()
		},
		syncWith: function(e) {
			return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
		},
		halt: function(e) {
			return this.warp(this._effectiveTimeScale, 0, e)
		},
		warp: function(e, t, i) {
			var n = this._mixer,
				r = n.time,
				o = this._timeScaleInterpolant,
				s = this.timeScale;
			return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = e / s, o[1] = t / s, this
		},
		stopWarping: function() {
			var e = this._timeScaleInterpolant;
			return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
		},
		getMixer: function() {
			return this._mixer
		},
		getClip: function() {
			return this._clip
		},
		getRoot: function() {
			return this._localRoot || this._mixer._root
		},
		_update: function(e, t, i, n) {
			if (this.enabled) {
				var r = this._startTime;
				if (null !== r) {
					if (0 > (t = (e - r) * i) || 0 === i) return;
					this._startTime = null, t *= i
				}
				if (t *= this._updateTimeScale(e), i = this._updateTime(t), 0 < (e = this._updateWeight(e))) {
					t = this._interpolants, r = this._propertyBindings;
					for (var o = 0, s = t.length; o !== s; ++o) t[o].evaluate(i), r[o].accumulate(n, e)
				}
			} else this._updateWeight(e)
		},
		_updateWeight: function(e) {
			var t = 0;
			if (this.enabled) {
				t = this.weight;
				var i = this._weightInterpolant;
				if (null !== i) {
					var n = i.evaluate(e)[0];
					t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
				}
			}
			return this._effectiveWeight = t
		},
		_updateTimeScale: function(e) {
			var t = 0;
			if (!this.paused) {
				t = this.timeScale;
				var i = this._timeScaleInterpolant;
				null !== i && (t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t))
			}
			return this._effectiveTimeScale = t
		},
		_updateTime: function(e) {
			var t = this.time + e,
				i = this._clip.duration,
				n = this.loop,
				r = this._loopCount,
				o = 2202 === n;
			if (0 === e) return -1 === r ? t : o && 1 == (1 & r) ? i - t : t;
			if (2200 === n) e: {
				if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), t >= i) t = i;
				else {
					if (!(0 > t)) {
						this.time = t;
						break e
					}
					t = 0
				}
				this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
				this.time = t,
				this._mixer.dispatchEvent({
					type: "finished",
					action: this,
					direction: 0 > e ? -1 : 1
				})
			}
			else {
				if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), t >= i || 0 > t) {
					t -= i * (n = Math.floor(t / i)), r += Math.abs(n);
					var s = this.repetitions - r;
					0 >= s ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t = 0 < e ? i : 0, this._mixer.dispatchEvent({
						type: "finished",
						action: this,
						direction: 0 < e ? 1 : -1
					})) : (1 === s ? (e = 0 > e, this._setEndings(e, !e, o)) : this._setEndings(!1, !1, o), this._loopCount = r, this.time = t, this._mixer.dispatchEvent({
						type: "loop",
						action: this,
						loopDelta: n
					}))
				} else this.time = t;
				if (o && 1 == (1 & r)) return i - t
			}
			return t
		},
		_setEndings: function(e, t, i) {
			var n = this._interpolantSettings;
			i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
		},
		_scheduleFading: function(e, t, i) {
			var n = this._mixer,
				r = n.time,
				o = this._weightInterpolant;
			return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = t, n[1] = r + e, o[1] = i, this
		}
	}), Rr.prototype = Object.assign(Object.create(t.prototype), {
		constructor: Rr,
		_bindAction: function(e, t) {
			var i = e._localRoot || this._root,
				n = e._clip.tracks,
				r = n.length,
				o = e._propertyBindings;
			e = e._interpolants;
			var s = i.uuid,
				a = this._bindingsByRootAndName,
				l = a[s];
			for (void 0 === l && (l = {}, a[s] = l), a = 0; a !== r; ++a) {
				var c = n[a],
					h = c.name,
					u = l[h];
				if (void 0 === u) {
					if (void 0 !== (u = o[a])) {
						null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, s, h));
						continue
					}++(u = new Ar(Cr.create(i, h, t && t._propertyBindings[a].binding.parsedPath), c.ValueTypeName, c.getValueSize())).referenceCount, this._addInactiveBinding(u, s, h)
				}
				o[a] = u, e[a].resultBuffer = u.buffer
			}
		},
		_activateAction: function(e) {
			if (!this._isActiveAction(e)) {
				if (null === e._cacheIndex) {
					var t = (e._localRoot || this._root).uuid,
						i = e._clip.uuid,
						n = this._actionsByClip[i];
					this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
				}
				for (i = 0, n = (t = e._propertyBindings).length; i !== n; ++i) {
					var r = t[i];
					0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
				}
				this._lendAction(e)
			}
		},
		_deactivateAction: function(e) {
			if (this._isActiveAction(e)) {
				for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
					var r = t[i];
					0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
				}
				this._takeBackAction(e)
			}
		},
		_initMemoryManager: function() {
			this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
			var e = this;
			this.stats = {
				actions: {
					get total() {
						return e._actions.length
					},
					get inUse() {
						return e._nActiveActions
					}
				},
				bindings: {
					get total() {
						return e._bindings.length
					},
					get inUse() {
						return e._nActiveBindings
					}
				},
				controlInterpolants: {
					get total() {
						return e._controlInterpolants.length
					},
					get inUse() {
						return e._nActiveControlInterpolants
					}
				}
			}
		},
		_isActiveAction: function(e) {
			return null !== (e = e._cacheIndex) && e < this._nActiveActions
		},
		_addInactiveAction: function(e, t, i) {
			var n = this._actions,
				r = this._actionsByClip,
				o = r[t];
			void 0 === o ? (o = {
				knownActions: [e],
				actionByRoot: {}
			}, e._byClipCacheIndex = 0, r[t] = o) : (t = o.knownActions, e._byClipCacheIndex = t.length, t.push(e)), e._cacheIndex = n.length, n.push(e), o.actionByRoot[i] = e
		},
		_removeInactiveAction: function(e) {
			var t = this._actions,
				i = t[t.length - 1],
				n = e._cacheIndex;
			i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null, t = e._clip.uuid;
			var r = (n = (i = this._actionsByClip)[t]).knownActions,
				o = r[r.length - 1],
				s = e._byClipCacheIndex;
			o._byClipCacheIndex = s, r[s] = o, r.pop(), e._byClipCacheIndex = null, delete n.actionByRoot[(e._localRoot || this._root).uuid], 0 === r.length && delete i[t], this._removeInactiveBindingsForAction(e)
		},
		_removeInactiveBindingsForAction: function(e) {
			for (var t = 0, i = (e = e._propertyBindings).length; t !== i; ++t) {
				var n = e[t];
				0 == --n.referenceCount && this._removeInactiveBinding(n)
			}
		},
		_lendAction: function(e) {
			var t = this._actions,
				i = e._cacheIndex,
				n = this._nActiveActions++,
				r = t[n];
			e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
		},
		_takeBackAction: function(e) {
			var t = this._actions,
				i = e._cacheIndex,
				n = --this._nActiveActions,
				r = t[n];
			e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
		},
		_addInactiveBinding: function(e, t, i) {
			var n = this._bindingsByRootAndName,
				r = n[t],
				o = this._bindings;
			void 0 === r && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = o.length, o.push(e)
		},
		_removeInactiveBinding: function(e) {
			var t = this._bindings,
				i = e.binding,
				n = i.rootNode.uuid;
			i = i.path;
			var r = this._bindingsByRootAndName,
				o = r[n],
				s = t[t.length - 1];
			e = e._cacheIndex, s._cacheIndex = e, t[e] = s, t.pop(), delete o[i];
			e: {
				for (var a in o) break e;delete r[n]
			}
		},
		_lendBinding: function(e) {
			var t = this._bindings,
				i = e._cacheIndex,
				n = this._nActiveBindings++,
				r = t[n];
			e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
		},
		_takeBackBinding: function(e) {
			var t = this._bindings,
				i = e._cacheIndex,
				n = --this._nActiveBindings,
				r = t[n];
			e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r
		},
		_lendControlInterpolant: function() {
			var e = this._controlInterpolants,
				t = this._nActiveControlInterpolants++,
				i = e[t];
			return void 0 === i && ((i = new hn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = i), i
		},
		_takeBackControlInterpolant: function(e) {
			var t = this._controlInterpolants,
				i = e.__cacheIndex,
				n = --this._nActiveControlInterpolants,
				r = t[n];
			e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r
		},
		_controlInterpolantsResultBuffer: new Float32Array(1),
		clipAction: function(e, t) {
			var i = t || this._root,
				n = i.uuid;
			e = null !== (i = "string" == typeof e ? wn.findByName(i, e) : e) ? i.uuid : e;
			var r = this._actionsByClip[e],
				o = null;
			if (void 0 !== r) {
				if (void 0 !== (o = r.actionByRoot[n])) return o;
				o = r.knownActions[0], null === i && (i = o._clip)
			}
			return null === i ? null : (t = new Ir(this, i, t), this._bindAction(t, o), this._addInactiveAction(t, e, n), t)
		},
		existingAction: function(e, t) {
			var i = t || this._root;
			return t = i.uuid, i = "string" == typeof e ? wn.findByName(i, e) : e, void 0 !== (e = this._actionsByClip[i ? i.uuid : e]) && e.actionByRoot[t] || null
		},
		stopAllAction: function() {
			for (var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== t; ++r) e[r].reset();
			for (r = 0; r !== n; ++r) i[r].useCount = 0;
			return this
		},
		update: function(e) {
			e *= this.timeScale;
			for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1, s = 0; s !== i; ++s) t[s]._update(n, e, r, o);
			for (e = this._bindings, t = this._nActiveBindings, s = 0; s !== t; ++s) e[s].apply(o);
			return this
		},
		getRoot: function() {
			return this._root
		},
		uncacheClip: function(e) {
			var t = this._actions;
			e = e.uuid;
			var i = this._actionsByClip,
				n = i[e];
			if (void 0 !== n) {
				for (var r = 0, o = (n = n.knownActions).length; r !== o; ++r) {
					var s = n[r];
					this._deactivateAction(s);
					var a = s._cacheIndex,
						l = t[t.length - 1];
					s._cacheIndex = null, s._byClipCacheIndex = null, l._cacheIndex = a, t[a] = l, t.pop(), this._removeInactiveBindingsForAction(s)
				}
				delete i[e]
			}
		},
		uncacheRoot: function(e) {
			e = e.uuid;
			var t = this._actionsByClip;
			for (n in t) {
				var i = t[n].actionByRoot[e];
				void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
			}
			var n = this._bindingsByRootAndName[e];
			if (void 0 !== n)
				for (var r in n)(e = n[r]).restoreOriginalState(), this._removeInactiveBinding(e)
		},
		uncacheAction: function(e, t) {
			null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e))
		}
	}), Or.prototype.clone = function() {
		return new Or(void 0 === this.value.clone ? this.value : this.value.clone())
	}, Dr.prototype = Object.assign(Object.create(Pt.prototype), {
		constructor: Dr,
		isInstancedInterleavedBuffer: !0,
		copy: function(e) {
			return Pt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
		}
	}), Object.assign(zr.prototype, {
		linePrecision: 1,
		set: function(e, t) {
			this.ray.set(e, t)
		},
		setFromCamera: function(e, t) {
			t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
		},
		intersectObject: function(e, t, i) {
			return Nr(e, this, i = i || [], t), i.sort(kr), i
		},
		intersectObjects: function(e, t, i) {
			if (i = i || [], !1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
			for (var n = 0, r = e.length; n < r; n++) Nr(e[n], this, i, t);
			return i.sort(kr), i
		}
	}), Object.assign(Br.prototype, {
		set: function(e, t, i) {
			return this.radius = e, this.phi = t, this.theta = i, this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
		},
		makeSafe: function() {
			return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
		},
		setFromVector3: function(e) {
			return this.setFromCartesianCoords(e.x, e.y, e.z)
		},
		setFromCartesianCoords: function(e, t, i) {
			return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, i), this.phi = Math.acos(uo.clamp(t / this.radius, -1, 1))), this
		}
	}), Object.assign(Hr.prototype, {
		set: function(e, t, i) {
			return this.radius = e, this.theta = t, this.y = i, this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
		},
		setFromVector3: function(e) {
			return this.setFromCartesianCoords(e.x, e.y, e.z)
		},
		setFromCartesianCoords: function(e, t, i) {
			return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
		}
	}), Object.assign(Fr.prototype, {
		set: function(e, t) {
			return this.min.copy(e), this.max.copy(t), this
		},
		setFromPoints: function(e) {
			this.makeEmpty();
			for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
			return this
		},
		setFromCenterAndSize: function() {
			var e = new i;
			return function(t, i) {
				return i = e.copy(i).multiplyScalar(.5), this.min.copy(t).sub(i), this.max.copy(t).add(i), this
			}
		}(),
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.min.copy(e.min), this.max.copy(e.max), this
		},
		makeEmpty: function() {
			return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
		},
		isEmpty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y
		},
		getCenter: function(e) {
			return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
		},
		getSize: function(e) {
			return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new i), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
		},
		expandByPoint: function(e) {
			return this.min.min(e), this.max.max(e), this
		},
		expandByVector: function(e) {
			return this.min.sub(e), this.max.add(e), this
		},
		expandByScalar: function(e) {
			return this.min.addScalar(-e), this.max.addScalar(e), this
		},
		containsPoint: function(e) {
			return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
		},
		containsBox: function(e) {
			return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
		},
		getParameter: function(e, t) {
			return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new i), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
		},
		intersectsBox: function(e) {
			return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
		},
		clampPoint: function(e, t) {
			return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new i), t.copy(e).clamp(this.min, this.max)
		},
		distanceToPoint: function() {
			var e = new i;
			return function(t) {
				return e.copy(t).clamp(this.min, this.max).sub(t).length()
			}
		}(),
		intersect: function(e) {
			return this.min.max(e.min), this.max.min(e.max), this
		},
		union: function(e) {
			return this.min.min(e.min), this.max.max(e.max), this
		},
		translate: function(e) {
			return this.min.add(e), this.max.add(e), this
		},
		equals: function(e) {
			return e.min.equals(this.min) && e.max.equals(this.max)
		}
	}), Object.assign(Ur.prototype, {
		set: function(e, t) {
			return this.start.copy(e), this.end.copy(t), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(e) {
			return this.start.copy(e.start), this.end.copy(e.end), this
		},
		getCenter: function(e) {
			return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new r), e.addVectors(this.start, this.end).multiplyScalar(.5)
		},
		delta: function(e) {
			return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new r), e.subVectors(this.end, this.start)
		},
		distanceSq: function() {
			return this.start.distanceToSquared(this.end)
		},
		distance: function() {
			return this.start.distanceTo(this.end)
		},
		at: function(e, t) {
			return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new r), this.delta(t).multiplyScalar(e).add(this.start)
		},
		closestPointToPointParameter: function() {
			var e = new r,
				t = new r;
			return function(i, n) {
				return e.subVectors(i, this.start), t.subVectors(this.end, this.start), i = t.dot(t), i = t.dot(e) / i, n && (i = uo.clamp(i, 0, 1)), i
			}
		}(),
		closestPointToPoint: function(e, t, i) {
			return e = this.closestPointToPointParameter(e, t), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new r), this.delta(i).multiplyScalar(e).add(this.start)
		},
		applyMatrix4: function(e) {
			return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
		},
		equals: function(e) {
			return e.start.equals(this.start) && e.end.equals(this.end)
		}
	}), jr.prototype = Object.create(S.prototype), jr.prototype.constructor = jr, jr.prototype.isImmediateRenderObject = !0, Gr.prototype = Object.create(Ft.prototype), Gr.prototype.constructor = Gr, Gr.prototype.update = function() {
		var e = new r,
			t = new r,
			i = new o;
		return function() {
			var n = ["a", "b", "c"];
			this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
			var r = this.object.matrixWorld,
				o = this.geometry.attributes.position,
				s = this.object.geometry;
			if (s && s.isGeometry)
				for (var a = s.vertices, l = s.faces, c = s = 0, h = l.length; c < h; c++)
					for (var u = l[c], d = 0, p = u.vertexNormals.length; d < p; d++) {
						var f = u.vertexNormals[d];
						e.copy(a[u[n[d]]]).applyMatrix4(r), t.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(s, e.x, e.y, e.z), s += 1, o.setXYZ(s, t.x, t.y, t.z), s += 1
					} else if (s && s.isBufferGeometry)
						for (n = s.attributes.position, a = s.attributes.normal, d = s = 0, p = n.count; d < p; d++) e.set(n.getX(d), n.getY(d), n.getZ(d)).applyMatrix4(r), t.set(a.getX(d), a.getY(d), a.getZ(d)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), o.setXYZ(s, e.x, e.y, e.z), s += 1, o.setXYZ(s, t.x, t.y, t.z), s += 1;
			o.needsUpdate = !0
		}
	}(), Vr.prototype = Object.create(S.prototype), Vr.prototype.constructor = Vr, Vr.prototype.dispose = function() {
		this.cone.geometry.dispose(), this.cone.material.dispose()
	}, Vr.prototype.update = function() {
		var e = new r;
		return function() {
			this.light.updateMatrixWorld();
			var t = this.light.distance ? this.light.distance : 1e3,
				i = t * Math.tan(this.light.angle);
			this.cone.scale.set(i, i, t), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
		}
	}(), Wr.prototype = Object.create(Ft.prototype), Wr.prototype.constructor = Wr, Wr.prototype.updateMatrixWorld = function() {
		var e = new r,
			t = new g,
			i = new g;
		return function(n) {
			var r = this.bones,
				o = this.geometry,
				s = o.getAttribute("position");
			i.getInverse(this.root.matrixWorld);
			for (var a = 0, l = 0; a < r.length; a++) {
				var c = r[a];
				c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), s.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), s.setXYZ(l + 1, e.x, e.y, e.z), l += 2)
			}
			o.getAttribute("position").needsUpdate = !0, S.prototype.updateMatrixWorld.call(this, n)
		}
	}(), qr.prototype = Object.create(Z.prototype), qr.prototype.constructor = qr, qr.prototype.dispose = function() {
		this.geometry.dispose(), this.material.dispose()
	}, qr.prototype.update = function() {
		void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
	}, Xr.prototype = Object.create(Ht.prototype), Xr.prototype.constructor = Xr, Xr.prototype.update = function() {
		if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
		else {
			this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
			var e = this.material.color,
				t = Math.max(e.r, e.g, e.b);
			1 < t && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color)
		}
	}, Xr.prototype.dispose = function() {
		this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
	}, Yr.prototype = Object.create(S.prototype), Yr.prototype.constructor = Yr, Yr.prototype.dispose = function() {
		this.children[0].geometry.dispose(), this.children[0].material.dispose()
	}, Yr.prototype.update = function() {
		var e = new r,
			t = new b,
			i = new b;
		return function() {
			var n = this.children[0];
			if (void 0 !== this.color) this.material.color.set(this.color);
			else {
				var r = n.geometry.getAttribute("color");
				t.copy(this.light.color), i.copy(this.light.groundColor);
				for (var o = 0, s = r.count; o < s; o++) {
					var a = o < s / 2 ? t : i;
					r.setXYZ(o, a.r, a.g, a.b)
				}
				r.needsUpdate = !0
			}
			n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
		}
	}(), Zr.prototype = Object.create(Z.prototype), Zr.prototype.constructor = Zr, Zr.prototype.dispose = function() {
		this.geometry.dispose(), this.material.dispose()
	}, Zr.prototype.onBeforeRender = function() {
		this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
	}, Qr.prototype = Object.assign(Object.create(Ft.prototype), {
		constructor: Qr,
		copy: function(e) {
			return Ft.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		}
	}), Jr.prototype = Object.create(Ft.prototype), Jr.prototype.constructor = Jr, Kr.prototype = Object.create(Ht.prototype), Kr.prototype.constructor = Kr, Kr.prototype.update = function() {
		function e(e, n, o, s) {
			for (o = (n - e) / o, p.setXYZ(h, 0, 0, 0), u++, t = e; t < n; t += o) i = h + u, p.setXYZ(i, Math.sin(t) * r, 0, Math.cos(t) * r), p.setXYZ(i + 1, Math.sin(Math.min(t + o, n)) * r, 0, Math.cos(Math.min(t + o, n)) * r), p.setXYZ(i + 2, 0, 0, 0), u += 3;
			d.addGroup(h, u, s), h += u, u = 0
		}
		var t, i, n = this.audio,
			r = this.range,
			o = this.divisionsInnerAngle,
			s = this.divisionsOuterAngle,
			a = uo.degToRad(n.panner.coneInnerAngle),
			l = a / 2,
			c = (n = uo.degToRad(n.panner.coneOuterAngle)) / 2,
			h = 0,
			u = 0,
			d = this.geometry,
			p = d.attributes.position;
		d.clearGroups(), e(-c, -l, s, 0), e(-l, l, o, 1), e(l, c, s, 0), p.needsUpdate = !0, a === n && (this.material[0].visible = !1)
	}, Kr.prototype.dispose = function() {
		this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
	}, $r.prototype = Object.create(Ft.prototype), $r.prototype.constructor = $r, $r.prototype.update = function() {
		var e = new r,
			t = new r,
			i = new o;
		return function() {
			this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
			for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, s = o.vertices, a = 0, l = 0, c = (o = o.faces).length; l < c; l++) {
				var h = o[l],
					u = h.normal;
				e.copy(s[h.a]).add(s[h.b]).add(s[h.c]).divideScalar(3).applyMatrix4(n), t.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), r.setXYZ(a, e.x, e.y, e.z), a += 1, r.setXYZ(a, t.x, t.y, t.z), a += 1
			}
			r.needsUpdate = !0
		}
	}(), eo.prototype = Object.create(S.prototype), eo.prototype.constructor = eo, eo.prototype.dispose = function() {
		this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
	}, eo.prototype.update = function() {
		var e = new r,
			t = new r,
			i = new r;
		return function() {
			e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(t), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(t), this.targetLine.scale.z = i.length()
		}
	}(), to.prototype = Object.create(Ft.prototype), to.prototype.constructor = to, to.prototype.update = function() {
		function e(e, r, s, a) {
			if (n.set(r, s, a).unproject(o), void 0 !== (e = i[e]))
				for (r = t.getAttribute("position"), s = 0, a = e.length; s < a; s++) r.setXYZ(e[s], n.x, n.y, n.z)
		}
		var t, i, n = new r,
			o = new wt;
		return function() {
			t = this.geometry, i = this.pointMap, o.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
		}
	}(), io.prototype = Object.create(Ft.prototype), io.prototype.constructor = io, io.prototype.update = function() {
		var e = new d;
		return function(t) {
			if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
				t = e.min;
				var i = e.max,
					n = this.geometry.attributes.position,
					r = n.array;
				r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
			}
		}
	}(), io.prototype.setFromObject = function(e) {
		return this.object = e, this.update(), this
	}, io.prototype.copy = function(e) {
		return Ft.prototype.copy.call(this, e), this.object = e.object, this
	}, io.prototype.clone = function() {
		return (new this.constructor).copy(this)
	}, no.prototype = Object.create(Ft.prototype), no.prototype.constructor = no, no.prototype.updateMatrixWorld = function(e) {
		var t = this.box;
		t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), S.prototype.updateMatrixWorld.call(this, e))
	}, ro.prototype = Object.create(Ht.prototype), ro.prototype.constructor = ro, ro.prototype.updateMatrixWorld = function(e) {
		var t = -this.plane.constant;
		1e-8 > Math.abs(t) && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = 0 > t ? 1 : 0, this.lookAt(this.plane.normal), S.prototype.updateMatrixWorld.call(this, e)
	}, oo.prototype = Object.create(S.prototype), oo.prototype.constructor = oo, oo.prototype.setDirection = function() {
		var e, t = new r;
		return function(i) {
			.99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
		}
	}(), oo.prototype.setLength = function(e, t, i) {
		void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
	}, oo.prototype.setColor = function(e) {
		this.line.material.color.copy(e), this.cone.material.color.copy(e)
	}, oo.prototype.copy = function(e) {
		return S.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
	}, oo.prototype.clone = function() {
		return (new this.constructor).copy(this)
	}, so.prototype = Object.create(Ft.prototype), so.prototype.constructor = so, Pn.create = function(e, t) {
		return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Pn.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
	}, Object.assign(Wn.prototype, {
		createPointsGeometry: function(e) {
			return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getPoints(e), this.createGeometry(e)
		},
		createSpacedPointsGeometry: function(e) {
			return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), e = this.getSpacedPoints(e), this.createGeometry(e)
		},
		createGeometry: function(e) {
			console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
			for (var t = new T, i = 0, n = e.length; i < n; i++) {
				var o = e[i];
				t.vertices.push(new r(o.x, o.y, o.z || 0))
			}
			return t
		}
	}), Object.assign(qn.prototype, {
		fromPoints: function(e) {
			console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
		}
	}), ao.prototype = Object.create(Dn.prototype), lo.prototype = Object.create(Dn.prototype), co.prototype = Object.create(Dn.prototype), Object.assign(co.prototype, {
		initFromArray: function() {
			console.error("THREE.Spline: .initFromArray() has been removed.")
		},
		getControlPointsArray: function() {
			console.error("THREE.Spline: .getControlPointsArray() has been removed.")
		},
		reparametrizeByArcLength: function() {
			console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
		}
	}), Qr.prototype.setColors = function() {
		console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
	}, Wr.prototype.update = function() {
		console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
	}, Object.assign(fr.prototype, {
		extractUrlBase: function(e) {
			return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), $o.extractUrlBase(e)
		}
	}), Object.assign(cr.prototype, {
		setTexturePath: function(e) {
			return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
		}
	}), Object.assign(Fr.prototype, {
		center: function(e) {
			return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
		},
		empty: function() {
			return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
		},
		isIntersectionBox: function(e) {
			return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
		},
		size: function(e) {
			return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
		}
	}), Object.assign(d.prototype, {
		center: function(e) {
			return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
		},
		empty: function() {
			return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
		},
		isIntersectionBox: function(e) {
			return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
		},
		isIntersectionSphere: function(e) {
			return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
		},
		size: function(e) {
			return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
		}
	}), Ur.prototype.center = function(e) {
		return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
	}, Object.assign(uo, {
		random16: function() {
			return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
		},
		nearestPowerOfTwo: function(e) {
			return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), uo.floorPowerOfTwo(e)
		},
		nextPowerOfTwo: function(e) {
			return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), uo.ceilPowerOfTwo(e)
		}
	}), Object.assign(o.prototype, {
		flattenToArrayOffset: function(e, t) {
			return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
		},
		multiplyVector3: function(e) {
			return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
		},
		multiplyVector3Array: function() {
			console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
		},
		applyToBuffer: function(e) {
			return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
		},
		applyToVector3Array: function() {
			console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
		}
	}), Object.assign(g.prototype, {
		extractPosition: function(e) {
			return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
		},
		flattenToArrayOffset: function(e, t) {
			return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
		},
		getPosition: function() {
			var e;
			return function() {
				return void 0 === e && (e = new r), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
			}
		}(),
		setRotationFromQuaternion: function(e) {
			return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
		},
		multiplyToArray: function() {
			console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
		},
		multiplyVector3: function(e) {
			return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		multiplyVector4: function(e) {
			return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		multiplyVector3Array: function() {
			console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
		},
		rotateAxis: function(e) {
			console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
		},
		crossVector: function(e) {
			return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
		},
		translate: function() {
			console.error("THREE.Matrix4: .translate() has been removed.")
		},
		rotateX: function() {
			console.error("THREE.Matrix4: .rotateX() has been removed.")
		},
		rotateY: function() {
			console.error("THREE.Matrix4: .rotateY() has been removed.")
		},
		rotateZ: function() {
			console.error("THREE.Matrix4: .rotateZ() has been removed.")
		},
		rotateByAxis: function() {
			console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
		},
		applyToBuffer: function(e) {
			return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
		},
		applyToVector3Array: function() {
			console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
		},
		makeFrustum: function(e, t, i, n, r, o) {
			return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, o)
		}
	}), f.prototype.isIntersectionLine = function(e) {
		return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
	}, n.prototype.multiplyVector3 = function(e) {
		return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
	}, Object.assign(q.prototype, {
		isIntersectionBox: function(e) {
			return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
		},
		isIntersectionPlane: function(e) {
			return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
		},
		isIntersectionSphere: function(e) {
			return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
		}
	}), Object.assign(X.prototype, {
		area: function() {
			return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
		},
		barycoordFromPoint: function(e, t) {
			return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
		},
		midpoint: function(e) {
			return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
		},
		normal: function(e) {
			return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
		},
		plane: function(e) {
			return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
		}
	}), Object.assign(X, {
		barycoordFromPoint: function(e, t, i, n, r) {
			return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(e, t, i, n, r)
		},
		normal: function(e, t, i, n) {
			return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(e, t, i, n)
		}
	}), Object.assign(Xn.prototype, {
		extractAllPoints: function(e) {
			return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
		},
		extrude: function(e) {
			return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pi(this, e)
		},
		makeGeometry: function(e) {
			return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ui(this, e)
		}
	}), Object.assign(i.prototype, {
		fromAttribute: function(e, t, i) {
			return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
		},
		distanceToManhattan: function(e) {
			return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
		},
		lengthManhattan: function() {
			return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
		}
	}), Object.assign(r.prototype, {
		setEulerFromRotationMatrix: function() {
			console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
		},
		setEulerFromQuaternion: function() {
			console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
		},
		getPositionFromMatrix: function(e) {
			return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
		},
		getScaleFromMatrix: function(e) {
			return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
		},
		getColumnFromMatrix: function(e, t) {
			return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
		},
		applyProjection: function(e) {
			return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
		},
		fromAttribute: function(e, t, i) {
			return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
		},
		distanceToManhattan: function(e) {
			return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
		},
		lengthManhattan: function() {
			return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
		}
	}), Object.assign(a.prototype, {
		fromAttribute: function(e, t, i) {
			return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
		},
		lengthManhattan: function() {
			return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
		}
	}), Object.assign(T.prototype, {
		computeTangents: function() {
			console.error("THREE.Geometry: .computeTangents() has been removed.")
		},
		computeLineDistances: function() {
			console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
		}
	}), Object.assign(S.prototype, {
		getChildByName: function(e) {
			return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
		},
		renderDepth: function() {
			console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
		},
		translate: function(e, t) {
			return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
		},
		getWorldRotation: function() {
			console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
		}
	}), Object.defineProperties(S.prototype, {
		eulerOrder: {
			get: function() {
				return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
			},
			set: function(e) {
				console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
			}
		},
		useQuaternion: {
			get: function() {
				console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
			},
			set: function() {
				console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
			}
		}
	}), Object.defineProperties(Dt.prototype, {
		objects: {
			get: function() {
				return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
			}
		}
	}), Object.defineProperty(kt.prototype, "useVertexTexture", {
		get: function() {
			console.warn("THREE.Skeleton: useVertexTexture has been removed.")
		},
		set: function() {
			console.warn("THREE.Skeleton: useVertexTexture has been removed.")
		}
	}), zt.prototype.initBones = function() {
		console.error("THREE.SkinnedMesh: initBones() has been removed.")
	}, Object.defineProperty(Pn.prototype, "__arcLengthDivisions", {
		get: function() {
			return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
		},
		set: function(e) {
			console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
		}
	}), xt.prototype.setLens = function(e, t) {
		console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
	}, Object.defineProperties(Yn.prototype, {
		onlyShadow: {
			set: function() {
				console.warn("THREE.Light: .onlyShadow has been removed.")
			}
		},
		shadowCameraFov: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
			}
		},
		shadowCameraLeft: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
			}
		},
		shadowCameraRight: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
			}
		},
		shadowCameraTop: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
			}
		},
		shadowCameraBottom: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
			}
		},
		shadowCameraNear: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
			}
		},
		shadowCameraFar: {
			set: function(e) {
				console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
			}
		},
		shadowCameraVisible: {
			set: function() {
				console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
			}
		},
		shadowBias: {
			set: function(e) {
				console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
			}
		},
		shadowDarkness: {
			set: function() {
				console.warn("THREE.Light: .shadowDarkness has been removed.")
			}
		},
		shadowMapWidth: {
			set: function(e) {
				console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
			}
		},
		shadowMapHeight: {
			set: function(e) {
				console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
			}
		}
	}), Object.defineProperties(A.prototype, {
		length: {
			get: function() {
				return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
			}
		},
		copyIndicesArray: function() {
			console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
		}
	}), Object.assign(H.prototype, {
		addIndex: function(e) {
			console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
		},
		addDrawCall: function(e, t, i) {
			void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
		},
		clearDrawCalls: function() {
			console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
		},
		computeTangents: function() {
			console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
		},
		computeOffsets: function() {
			console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
		}
	}), Object.defineProperties(H.prototype, {
		drawcalls: {
			get: function() {
				return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
			}
		},
		offsets: {
			get: function() {
				return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
			}
		}
	}), Object.assign(Ii.prototype, {
		getArrays: function() {
			console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
		},
		addShapeList: function() {
			console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
		},
		addShape: function() {
			console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
		}
	}), Object.defineProperties(Or.prototype, {
		dynamic: {
			set: function() {
				console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
			}
		},
		onUpdate: {
			value: function() {
				return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
			}
		}
	}), Object.defineProperties(V.prototype, {
		wrapAround: {
			get: function() {
				console.warn("THREE.Material: .wrapAround has been removed.")
			},
			set: function() {
				console.warn("THREE.Material: .wrapAround has been removed.")
			}
		},
		overdraw: {
			get: function() {
				console.warn("THREE.Material: .overdraw has been removed.")
			},
			set: function() {
				console.warn("THREE.Material: .overdraw has been removed.")
			}
		},
		wrapRGB: {
			get: function() {
				return console.warn("THREE.Material: .wrapRGB has been removed."), new b
			}
		},
		shading: {
			get: function() {
				console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
			},
			set: function(e) {
				console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
			}
		}
	}), Object.defineProperties(tn.prototype, {
		metal: {
			get: function() {
				return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
			},
			set: function() {
				console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
			}
		}
	}), Object.defineProperties(W.prototype, {
		derivatives: {
			get: function() {
				return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
			},
			set: function(e) {
				console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
			}
		}
	}), Object.assign(Tt.prototype, {
		clearTarget: function(e, t, i, n) {
			console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n)
		},
		animate: function(e) {
			console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
		},
		getCurrentRenderTarget: function() {
			return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
		},
		getMaxAnisotropy: function() {
			return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
		},
		getPrecision: function() {
			return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
		},
		resetGLState: function() {
			return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
		},
		supportsFloatTextures: function() {
			return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
		},
		supportsHalfFloatTextures: function() {
			return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
		},
		supportsStandardDerivatives: function() {
			return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
		},
		supportsCompressedTextureS3TC: function() {
			return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
		},
		supportsCompressedTexturePVRTC: function() {
			return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
		},
		supportsBlendMinMax: function() {
			return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
		},
		supportsVertexTextures: function() {
			return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
		},
		supportsInstancedArrays: function() {
			return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
		},
		enableScissorTest: function(e) {
			console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
		},
		initMaterial: function() {
			console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
		},
		addPrePlugin: function() {
			console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
		},
		addPostPlugin: function() {
			console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
		},
		updateShadowMap: function() {
			console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
		},
		setFaceCulling: function() {
			console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
		},
		allocTextureUnit: function() {
			console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
		},
		setTexture: function() {
			console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
		},
		setTexture2D: function() {
			console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
		},
		setTextureCube: function() {
			console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
		}
	}), Object.defineProperties(Tt.prototype, {
		shadowMapEnabled: {
			get: function() {
				return this.shadowMap.enabled
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
			}
		},
		shadowMapType: {
			get: function() {
				return this.shadowMap.type
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
			}
		},
		shadowMapCullFace: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
			}
		}
	}), Object.defineProperties(mt.prototype, {
		cullFace: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
			}
		},
		renderReverseSided: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
			}
		},
		renderSingleSided: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
			}
		}
	}), Object.defineProperties(h.prototype, {
		activeCubeFace: {
			set: function() {
				console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
			}
		},
		activeMipMapLevel: {
			set: function() {
				console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
			}
		}
	}), Object.defineProperties(l.prototype, {
		wrapS: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
			}
		},
		wrapT: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
			}
		},
		magFilter: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
			}
		},
		minFilter: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
			}
		},
		anisotropy: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
			}
		},
		offset: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
			}
		},
		repeat: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
			}
		},
		format: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
			}
		},
		type: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
			}
		},
		generateMipmaps: {
			get: function() {
				return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
			},
			set: function(e) {
				console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
			}
		}
	}), Object.defineProperties(Mt.prototype, {
		standing: {
			set: function() {
				console.warn("THREE.WebVRManager: .standing has been removed.")
			}
		},
		userHeight: {
			set: function() {
				console.warn("THREE.WebVRManager: .userHeight has been removed.")
			}
		}
	}), Mr.prototype.load = function(e) {
		console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
		var t = this;
		return (new mr).load(e, (function(e) {
			t.setBuffer(e)
		})), this
	}, Tr.prototype.getData = function() {
		return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
	}, xr.prototype.updateCubeMap = function(e, t) {
		return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
	}, fo.crossOrigin = void 0, fo.loadTexture = function(e, t, i, n) {
		console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
		var r = new Cn;
		return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
	}, fo.loadTextureCube = function(e, t, i, n) {
		console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
		var r = new Ln;
		return r.setCrossOrigin(this.crossOrigin), e = r.load(e, i, void 0, n), t && (e.mapping = t), e
	}, fo.loadCompressedTexture = function() {
		console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
	}, fo.loadCompressedTextureCube = function() {
		console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
	}, e.ACESFilmicToneMapping = 5, e.AddEquation = 100, e.AddOperation = 2, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AmbientLight = nr, e.AmbientLightProbe = br, e.AnimationClip = wn, e.AnimationLoader = Mn, e.AnimationMixer = Rr, e.AnimationObjectGroup = Pr, e.AnimationUtils = Vo, e.ArcCurve = Rn, e.ArrayCamera = _t, e.ArrowHelper = oo, e.Audio = Mr, e.AudioAnalyser = Tr, e.AudioContext = as, e.AudioListener = Er, e.AudioLoader = mr, e.AxesHelper = so, e.AxisHelper = function(e) {
		return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new so(e)
	}, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function(e) {
		return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Tn(e)
	}, e.Bone = Nt, e.BooleanKeyframeTrack = pn, e.BoundingBoxHelper = function(e, t) {
		return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new io(e, t)
	}, e.Box2 = Fr, e.Box3 = d, e.Box3Helper = no, e.BoxBufferGeometry = U, e.BoxGeometry = F, e.BoxHelper = io, e.BufferAttribute = A, e.BufferGeometry = H, e.BufferGeometryLoader = lr, e.ByteType = 1010, e.Cache = Wo, e.Camera = wt, e.CameraHelper = to, e.CanvasRenderer = function() {
		console.error("THREE.CanvasRenderer has been removed")
	}, e.CanvasTexture = qt, e.CatmullRomCurve3 = Dn, e.CineonToneMapping = 4, e.CircleBufferGeometry = Qi, e.CircleGeometry = Zi, e.ClampToEdgeWrapping = 1001, e.Clock = _r, e.ClosedSplineCurve3 = ao, e.Color = b, e.ColorKeyframeTrack = fn, e.CompressedTexture = Wt, e.CompressedTextureLoader = Sn, e.ConeBufferGeometry = Yi, e.ConeGeometry = Xi, e.CubeCamera = xr, e.CubeGeometry = F, e.CubeReflectionMapping = 301, e.CubeRefractionMapping = 302, e.CubeTexture = ae, e.CubeTextureLoader = Ln, e.CubeUVReflectionMapping = 306, e.CubeUVRefractionMapping = 307, e.CubicBezierCurve = Bn, e.CubicBezierCurve3 = Hn, e.CubicInterpolant = cn, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = Pn, e.CurvePath = Wn, e.CustomBlending = 5, e.CylinderBufferGeometry = qi, e.CylinderGeometry = Wi, e.Cylindrical = Hr, e.DataTexture = u, e.DataTexture2DArray = le, e.DataTexture3D = ce, e.DataTextureLoader = Tn, e.DefaultLoadingManager = qo, e.DepthFormat = 1026, e.DepthStencilFormat = 1027, e.DepthTexture = Xt, e.DirectionalLight = ir, e.DirectionalLightHelper = eo, e.DirectionalLightShadow = tr, e.DiscreteInterpolant = un, e.DodecahedronBufferGeometry = si, e.DodecahedronGeometry = oi, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function(e, t) {
		return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new A(e, t).setDynamic(!0)
	}, e.EdgesGeometry = Vi, e.EdgesHelper = function(e, t) {
		return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ft(new Vi(e.geometry), new Bt({
			color: void 0 !== t ? t : 16777215
		}))
	}, e.EllipseCurve = In, e.EqualDepth = 4, e.EquirectangularReflectionMapping = 303, e.EquirectangularRefractionMapping = 304, e.Euler = E, e.EventDispatcher = t, e.ExtrudeBufferGeometry = Ii, e.ExtrudeGeometry = Pi, e.Face3 = _, e.Face4 = function(e, t, i, n, r, o, s) {
		return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new _(e, t, i, r, o, s)
	}, e.FaceColors = 1, e.FaceNormalsHelper = $r, e.FileLoader = En, e.FlatShading = 1, e.Float32Attribute = function(e, t) {
		return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new z(e, t)
	}, e.Float32BufferAttribute = z, e.Float64Attribute = function(e, t) {
		return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new k(e, t)
	}, e.Float64BufferAttribute = k, e.FloatType = 1015, e.Fog = Lt, e.FogExp2 = At, e.Font = dr, e.FontLoader = pr, e.FrontFaceDirectionCCW = 1, e.FrontFaceDirectionCW = 0, e.FrontSide = 0, e.Frustum = m, e.GammaEncoding = 3007, e.Geometry = T, e.GeometryUtils = {
		merge: function(e, t, i) {
			if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh) {
				t.matrixAutoUpdate && t.updateMatrix();
				var n = t.matrix;
				t = t.geometry
			}
			e.merge(t, n, i)
		},
		center: function(e) {
			return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
		}
	}, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GridHelper = Qr, e.Group = bt, e.HalfFloatType = 1016, e.HemisphereLight = Zn, e.HemisphereLightHelper = Yr, e.HemisphereLightProbe = yr, e.IcosahedronBufferGeometry = ri, e.IcosahedronGeometry = ni, e.ImageBitmapLoader = hr, e.ImageLoader = An, e.ImageUtils = fo, e.ImmediateRenderObject = jr, e.InstancedBufferAttribute = ar, e.InstancedBufferGeometry = sr, e.InstancedInterleavedBuffer = Dr, e.Int16Attribute = function(e, t) {
		return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new I(e, t)
	}, e.Int16BufferAttribute = I, e.Int32Attribute = function(e, t) {
		return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new O(e, t)
	}, e.Int32BufferAttribute = O, e.Int8Attribute = function(e, t) {
		return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new L(e, t)
	}, e.Int8BufferAttribute = L, e.IntType = 1013, e.InterleavedBuffer = Pt, e.InterleavedBufferAttribute = It, e.Interpolant = ln, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.JSONLoader = function() {
		console.error("THREE.JSONLoader has been removed.")
	}, e.KeyframeTrack = dn, e.LOD = Dt, e.LatheBufferGeometry = Fi, e.LatheGeometry = Hi, e.Layers = M, e.LensFlare = function() {
		console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
	}, e.LessDepth = 2, e.LessEqualDepth = 3, e.Light = Yn, e.LightProbe = vr, e.LightProbeHelper = Zr, e.LightShadow = Qn, e.Line = Ht, e.Line3 = Ur, e.LineBasicMaterial = Bt, e.LineCurve = Fn, e.LineCurve3 = Un, e.LineDashedMaterial = an, e.LineLoop = Ut, e.LinePieces = 1, e.LineSegments = Ft, e.LineStrip = 0, e.LinearEncoding = 3e3, e.LinearFilter = 1006, e.LinearInterpolant = hn, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearToneMapping = 1, e.Loader = fr, e.LoaderUtils = $o, e.LoadingManager = _n, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2
	}, e.Material = V, e.MaterialLoader = or, e.Math = uo, e.Matrix3 = o, e.Matrix4 = g, e.MaxEquation = 104, e.Mesh = Z, e.MeshBasicMaterial = Y, e.MeshDepthMaterial = pt, e.MeshDistanceMaterial = ft, e.MeshFaceMaterial = function(e) {
		return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
	}, e.MeshLambertMaterial = on, e.MeshMatcapMaterial = sn, e.MeshNormalMaterial = rn, e.MeshPhongMaterial = tn, e.MeshPhysicalMaterial = en, e.MeshStandardMaterial = $i, e.MeshToonMaterial = nn, e.MinEquation = 103, e.MirroredRepeatWrapping = 1002, e.MixOperation = 1, e.MultiMaterial = function(e) {
		return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function() {
			return e.slice()
		}, e
	}, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = 1003, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NeverDepth = 0, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NumberKeyframeTrack = mn, e.Object3D = S, e.ObjectLoader = cr, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = ii, e.OctahedronGeometry = ti, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = er, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.ParametricBufferGeometry = Qt, e.ParametricGeometry = Zt, e.Particle = function(e) {
		return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ot(e)
	}, e.ParticleBasicMaterial = function(e) {
		return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new jt(e)
	}, e.ParticleSystem = function(e, t) {
		return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Gt(e, t)
	}, e.ParticleSystemMaterial = function(e) {
		return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new jt(e)
	}, e.Path = qn, e.PerspectiveCamera = xt, e.Plane = f, e.PlaneBufferGeometry = G, e.PlaneGeometry = j, e.PlaneHelper = ro, e.PointCloud = function(e, t) {
		return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Gt(e, t)
	}, e.PointCloudMaterial = function(e) {
		return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new jt(e)
	}, e.PointLight = $n, e.PointLightHelper = qr, e.Points = Gt, e.PointsMaterial = jt, e.PolarGridHelper = Jr, e.PolyhedronBufferGeometry = Kt, e.PolyhedronGeometry = Jt, e.PositionalAudio = Sr, e.PositionalAudioHelper = Kr, e.PropertyBinding = Cr, e.PropertyMixer = Ar, e.QuadraticBezierCurve = jn, e.QuadraticBezierCurve3 = Gn, e.Quaternion = n, e.QuaternionKeyframeTrack = vn, e.QuaternionLinearInterpolant = gn, e.REVISION = "105", e.RGBADepthPacking = 3201, e.RGBAFormat = 1023, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_PVRTC_2BPPV1_Format = 35843, e.RGBA_PVRTC_4BPPV1_Format = 35842, e.RGBA_S3TC_DXT1_Format = 33777, e.RGBA_S3TC_DXT3_Format = 33778, e.RGBA_S3TC_DXT5_Format = 33779, e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = 1022, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, e.RGB_PVRTC_2BPPV1_Format = 35841, e.RGB_PVRTC_4BPPV1_Format = 35840, e.RGB_S3TC_DXT1_Format = 33776, e.RawShaderMaterial = Ki, e.Ray = q, e.Raycaster = zr, e.RectAreaLight = rr, e.RectAreaLightHelper = Xr, e.RedFormat = 1028, e.ReinhardToneMapping = 2, e.RepeatWrapping = 1e3, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = Bi, e.RingGeometry = Ni, e.Scene = Ct, e.SceneUtils = {
		createMultiMaterialObject: function() {
			console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
		},
		detach: function() {
			console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
		},
		attach: function() {
			console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
		}
	}, e.ShaderChunk = go, e.ShaderLib = wo, e.ShaderMaterial = W, e.ShadowMaterial = Ji, e.Shape = Xn, e.ShapeBufferGeometry = ji, e.ShapeGeometry = Ui, e.ShapePath = ur, e.ShapeUtils = Fo, e.ShortType = 1011, e.Skeleton = kt, e.SkeletonHelper = Wr, e.SkinnedMesh = zt, e.SmoothShading = 2, e.Sphere = p, e.SphereBufferGeometry = ki, e.SphereGeometry = zi, e.Spherical = Br, e.SphericalHarmonics3 = gr, e.SphericalReflectionMapping = 305, e.Spline = co, e.SplineCurve = Vn, e.SplineCurve3 = lo, e.SpotLight = Kn, e.SpotLightHelper = Vr, e.SpotLightShadow = Jn, e.Sprite = Ot, e.SpriteMaterial = Rt, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StereoCamera = wr, e.StringKeyframeTrack = yn, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = ei, e.TetrahedronGeometry = $t, e.TextBufferGeometry = Di, e.TextGeometry = Oi, e.Texture = s, e.TextureLoader = Cn, e.TorusBufferGeometry = di, e.TorusGeometry = ui, e.TorusKnotBufferGeometry = hi, e.TorusKnotGeometry = ci, e.Triangle = X, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = li, e.TubeGeometry = ai, e.UVMapping = 300, e.Uint16Attribute = function(e, t) {
		return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new R(e, t)
	}, e.Uint16BufferAttribute = R, e.Uint32Attribute = function(e, t) {
		return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new D(e, t)
	}, e.Uint32BufferAttribute = D, e.Uint8Attribute = function(e, t) {
		return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new C(e, t)
	}, e.Uint8BufferAttribute = C, e.Uint8ClampedAttribute = function(e, t) {
		return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new P(e, t)
	}, e.Uint8ClampedBufferAttribute = P, e.Uncharted2ToneMapping = 3, e.Uniform = Or, e.UniformsLib = bo, e.UniformsUtils = vo, e.UnsignedByteType = 1009, e.UnsignedInt248Type = 1020, e.UnsignedIntType = 1014, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = 1012, e.Vector2 = i, e.Vector3 = r, e.Vector4 = a, e.VectorKeyframeTrack = bn, e.Vertex = function(e, t, i) {
		return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r(e, t, i)
	}, e.VertexColors = 2, e.VertexNormalsHelper = Gr, e.VideoTexture = Vt, e.WebGLMultisampleRenderTarget = c, e.WebGLRenderTarget = l, e.WebGLRenderTargetCube = h, e.WebGLRenderer = Tt, e.WebGLUtils = yt, e.WireframeGeometry = Yt, e.WireframeHelper = function(e, t) {
		return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ft(new Yt(e.geometry), new Bt({
			color: void 0 !== t ? t : 16777215
		}))
	}, e.WrapAroundEnding = 2402, e.XHRLoader = function(e) {
		return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new En(e)
	}, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", {
		value: !0
	})
})),
function(e, t) {
	"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t()
}(this, (function() {
	"use strict";

	function e(e, t) {
		for (var i = 0; i < t.length; i++) {
			var n = t[i];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
		}
	}

	function t(t, i, n) {
		return i && e(t.prototype, i), n && e(t, n), t
	}

	function i() {
		return (i = Object.assign || function(e) {
			for (var t = 1; t < arguments.length; t++) {
				var i = arguments[t];
				for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
			}
			return e
		}).apply(this, arguments)
	}

	function n(e, t) {
		e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
	}
	var r, o, s = function(e) {
			do {
				e += Math.floor(1e6 * Math.random())
			} while (document.getElementById(e));
			return e
		},
		a = function(e) {
			var t = e.getAttribute("data-bs-target");
			if (!t || "#" === t) {
				var i = e.getAttribute("href");
				t = i && "#" !== i ? i.trim() : null
			}
			return t
		},
		l = function(e) {
			var t = a(e);
			return t && document.querySelector(t) ? t : null
		},
		c = function(e) {
			var t = a(e);
			return t ? document.querySelector(t) : null
		},
		h = function(e) {
			if (!e) return 0;
			var t = window.getComputedStyle(e),
				i = t.transitionDuration,
				n = t.transitionDelay,
				r = Number.parseFloat(i),
				o = Number.parseFloat(n);
			return r || o ? (i = i.split(",")[0], n = n.split(",")[0], 1e3 * (Number.parseFloat(i) + Number.parseFloat(n))) : 0
		},
		u = function(e) {
			e.dispatchEvent(new Event("transitionend"))
		},
		d = function(e) {
			return (e[0] || e).nodeType
		},
		p = function(e, t) {
			var i = !1,
				n = t + 5;
			e.addEventListener("transitionend", (function t() {
				i = !0, e.removeEventListener("transitionend", t)
			})), setTimeout((function() {
				i || u(e)
			}), n)
		},
		f = function(e, t, i) {
			Object.keys(i).forEach((function(n) {
				var r, o = i[n],
					s = t[n],
					a = s && d(s) ? "element" : null == (r = s) ? "" + r : {}.toString.call(r).match(/\s([a-z]+)/i)[1].toLowerCase();
				if (!new RegExp(o).test(a)) throw new Error(e.toUpperCase() + ': Option "' + n + '" provided type "' + a + '" but expected type "' + o + '".')
			}))
		},
		m = function(e) {
			if (!e) return !1;
			if (e.style && e.parentNode && e.parentNode.style) {
				var t = getComputedStyle(e),
					i = getComputedStyle(e.parentNode);
				return "none" !== t.display && "none" !== i.display && "hidden" !== t.visibility
			}
			return !1
		},
		g = function() {
			return function() {}
		},
		v = function(e) {
			return e.offsetHeight
		},
		y = function() {
			var e = window.jQuery;
			return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null
		},
		b = function(e) {
			"loading" === document.readyState ? document.addEventListener("DOMContentLoaded", e) : e()
		},
		w = "rtl" === document.documentElement.dir,
		x = (r = {}, o = 1, {
			set: function(e, t, i) {
				void 0 === e.bsKey && (e.bsKey = {
					key: t,
					id: o
				}, o++), r[e.bsKey.id] = i
			},
			get: function(e, t) {
				if (!e || void 0 === e.bsKey) return null;
				var i = e.bsKey;
				return i.key === t ? r[i.id] : null
			},
			delete: function(e, t) {
				if (void 0 !== e.bsKey) {
					var i = e.bsKey;
					i.key === t && (delete r[i.id], delete e.bsKey)
				}
			}
		}),
		_ = function(e, t, i) {
			x.set(e, t, i)
		},
		E = function(e, t) {
			return x.get(e, t)
		},
		M = /[^.]*(?=\..*)\.|.*/,
		S = /\..*/,
		T = /::\d+$/,
		A = {},
		L = 1,
		C = {
			mouseenter: "mouseover",
			mouseleave: "mouseout"
		},
		P = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

	function I(e, t) {
		return t && t + "::" + L++ || e.uidEvent || L++
	}

	function R(e) {
		var t = I(e);
		return e.uidEvent = t, A[t] = A[t] || {}, A[t]
	}

	function O(e, t, i) {
		void 0 === i && (i = null);
		for (var n = Object.keys(e), r = 0, o = n.length; r < o; r++) {
			var s = e[n[r]];
			if (s.originalHandler === t && s.delegationSelector === i) return s
		}
		return null
	}

	function D(e, t, i) {
		var n = "string" == typeof t,
			r = n ? i : t,
			o = e.replace(S, ""),
			s = C[o];
		return s && (o = s), P.has(o) || (o = e), [n, r, o]
	}

	function z(e, t, i, n, r) {
		if ("string" == typeof t && e) {
			i || (i = n, n = null);
			var o = D(t, i, n),
				s = o[0],
				a = o[1],
				l = o[2],
				c = R(e),
				h = c[l] || (c[l] = {}),
				u = O(h, a, s ? i : null);
			if (u) u.oneOff = u.oneOff && r;
			else {
				var d = I(a, t.replace(M, "")),
					p = s ? function(e, t, i) {
						return function n(r) {
							for (var o = e.querySelectorAll(t), s = r.target; s && s !== this; s = s.parentNode)
								for (var a = o.length; a--;)
									if (o[a] === s) return r.delegateTarget = s, n.oneOff && N.off(e, r.type, i), i.apply(s, [r]);
							return null
						}
					}(e, i, n) : function(e, t) {
						return function i(n) {
							return n.delegateTarget = e, i.oneOff && N.off(e, n.type, t), t.apply(e, [n])
						}
					}(e, i);
				p.delegationSelector = s ? i : null, p.originalHandler = a, p.oneOff = r, p.uidEvent = d, h[d] = p, e.addEventListener(l, p, s)
			}
		}
	}

	function k(e, t, i, n, r) {
		var o = O(t[i], n, r);
		o && (e.removeEventListener(i, o, Boolean(r)), delete t[i][o.uidEvent])
	}
	var N = {
			on: function(e, t, i, n) {
				z(e, t, i, n, !1)
			},
			one: function(e, t, i, n) {
				z(e, t, i, n, !0)
			},
			off: function(e, t, i, n) {
				if ("string" == typeof t && e) {
					var r = D(t, i, n),
						o = r[0],
						s = r[1],
						a = r[2],
						l = a !== t,
						c = R(e),
						h = t.startsWith(".");
					if (void 0 === s) {
						h && Object.keys(c).forEach((function(i) {
							! function(e, t, i, n) {
								var r = t[i] || {};
								Object.keys(r).forEach((function(o) {
									if (o.includes(n)) {
										var s = r[o];
										k(e, t, i, s.originalHandler, s.delegationSelector)
									}
								}))
							}(e, c, i, t.slice(1))
						}));
						var u = c[a] || {};
						Object.keys(u).forEach((function(i) {
							var n = i.replace(T, "");
							if (!l || t.includes(n)) {
								var r = u[i];
								k(e, c, a, r.originalHandler, r.delegationSelector)
							}
						}))
					} else {
						if (!c || !c[a]) return;
						k(e, c, a, s, o ? i : null)
					}
				}
			},
			trigger: function(e, t, i) {
				if ("string" != typeof t || !e) return null;
				var n, r = y(),
					o = t.replace(S, ""),
					s = t !== o,
					a = P.has(o),
					l = !0,
					c = !0,
					h = !1,
					u = null;
				return s && r && (n = r.Event(t, i), r(e).trigger(n), l = !n.isPropagationStopped(), c = !n.isImmediatePropagationStopped(), h = n.isDefaultPrevented()), a ? (u = document.createEvent("HTMLEvents")).initEvent(o, l, !0) : u = new CustomEvent(t, {
					bubbles: l,
					cancelable: !0
				}), void 0 !== i && Object.keys(i).forEach((function(e) {
					Object.defineProperty(u, e, {
						get: function() {
							return i[e]
						}
					})
				})), h && u.preventDefault(), c && e.dispatchEvent(u), u.defaultPrevented && void 0 !== n && n.preventDefault(), u
			}
		},
		B = function() {
			function e(e) {
				e && (this._element = e, _(e, this.constructor.DATA_KEY, this))
			}
			return e.prototype.dispose = function() {
				(function(e, t) {
					x.delete(e, t)
				})(this._element, this.constructor.DATA_KEY), this._element = null
			}, e.getInstance = function(e) {
				return E(e, this.DATA_KEY)
			}, t(e, null, [{
				key: "VERSION",
				get: function() {
					return "5.0.0-beta1"
				}
			}]), e
		}(),
		H = "alert",
		F = function(e) {
			function i() {
				return e.apply(this, arguments) || this
			}
			n(i, e);
			var r = i.prototype;
			return r.close = function(e) {
				var t = e ? this._getRootElement(e) : this._element,
					i = this._triggerCloseEvent(t);
				null === i || i.defaultPrevented || this._removeElement(t)
			}, r._getRootElement = function(e) {
				return c(e) || e.closest(".alert")
			}, r._triggerCloseEvent = function(e) {
				return N.trigger(e, "close.bs.alert")
			}, r._removeElement = function(e) {
				var t = this;
				if (e.classList.remove("show"), e.classList.contains("fade")) {
					var i = h(e);
					N.one(e, "transitionend", (function() {
						return t._destroyElement(e)
					})), p(e, i)
				} else this._destroyElement(e)
			}, r._destroyElement = function(e) {
				e.parentNode && e.parentNode.removeChild(e), N.trigger(e, "closed.bs.alert")
			}, i.jQueryInterface = function(e) {
				return this.each((function() {
					var t = E(this, "bs.alert");
					t || (t = new i(this)), "close" === e && t[e](this)
				}))
			}, i.handleDismiss = function(e) {
				return function(t) {
					t && t.preventDefault(), e.close(this)
				}
			}, t(i, null, [{
				key: "DATA_KEY",
				get: function() {
					return "bs.alert"
				}
			}]), i
		}(B);
	N.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', F.handleDismiss(new F)), b((function() {
		var e = y();
		if (e) {
			var t = e.fn[H];
			e.fn[H] = F.jQueryInterface, e.fn[H].Constructor = F, e.fn[H].noConflict = function() {
				return e.fn[H] = t, F.jQueryInterface
			}
		}
	}));
	var U = function(e) {
		function i() {
			return e.apply(this, arguments) || this
		}
		return n(i, e), i.prototype.toggle = function() {
			this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
		}, i.jQueryInterface = function(e) {
			return this.each((function() {
				var t = E(this, "bs.button");
				t || (t = new i(this)), "toggle" === e && t[e]()
			}))
		}, t(i, null, [{
			key: "DATA_KEY",
			get: function() {
				return "bs.button"
			}
		}]), i
	}(B);

	function j(e) {
		return "true" === e || "false" !== e && (e === Number(e).toString() ? Number(e) : "" === e || "null" === e ? null : e)
	}

	function G(e) {
		return e.replace(/[A-Z]/g, (function(e) {
			return "-" + e.toLowerCase()
		}))
	}
	N.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', (function(e) {
		e.preventDefault();
		var t = e.target.closest('[data-bs-toggle="button"]'),
			i = E(t, "bs.button");
		i || (i = new U(t)), i.toggle()
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn.button;
			e.fn.button = U.jQueryInterface, e.fn.button.Constructor = U, e.fn.button.noConflict = function() {
				return e.fn.button = t, U.jQueryInterface
			}
		}
	}));
	var V = {
			setDataAttribute: function(e, t, i) {
				e.setAttribute("data-bs-" + G(t), i)
			},
			removeDataAttribute: function(e, t) {
				e.removeAttribute("data-bs-" + G(t))
			},
			getDataAttributes: function(e) {
				if (!e) return {};
				var t = {};
				return Object.keys(e.dataset).filter((function(e) {
					return e.startsWith("bs")
				})).forEach((function(i) {
					var n = i.replace(/^bs/, "");
					n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = j(e.dataset[i])
				})), t
			},
			getDataAttribute: function(e, t) {
				return j(e.getAttribute("data-bs-" + G(t)))
			},
			offset: function(e) {
				var t = e.getBoundingClientRect();
				return {
					top: t.top + document.body.scrollTop,
					left: t.left + document.body.scrollLeft
				}
			},
			position: function(e) {
				return {
					top: e.offsetTop,
					left: e.offsetLeft
				}
			}
		},
		W = {
			matches: function(e, t) {
				return e.matches(t)
			},
			find: function(e, t) {
				var i;
				return void 0 === t && (t = document.documentElement), (i = []).concat.apply(i, Element.prototype.querySelectorAll.call(t, e))
			},
			findOne: function(e, t) {
				return void 0 === t && (t = document.documentElement), Element.prototype.querySelector.call(t, e)
			},
			children: function(e, t) {
				var i;
				return (i = []).concat.apply(i, e.children).filter((function(e) {
					return e.matches(t)
				}))
			},
			parents: function(e, t) {
				for (var i = [], n = e.parentNode; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) this.matches(n, t) && i.push(n), n = n.parentNode;
				return i
			},
			prev: function(e, t) {
				for (var i = e.previousElementSibling; i;) {
					if (i.matches(t)) return [i];
					i = i.previousElementSibling
				}
				return []
			},
			next: function(e, t) {
				for (var i = e.nextElementSibling; i;) {
					if (this.matches(i, t)) return [i];
					i = i.nextElementSibling
				}
				return []
			}
		},
		q = "carousel",
		X = {
			interval: 5e3,
			keyboard: !0,
			slide: !1,
			pause: "hover",
			wrap: !0,
			touch: !0
		},
		Y = {
			interval: "(number|boolean)",
			keyboard: "boolean",
			slide: "(boolean|string)",
			pause: "(string|boolean)",
			wrap: "boolean",
			touch: "boolean"
		},
		Z = {
			TOUCH: "touch",
			PEN: "pen"
		},
		Q = function(e) {
			function r(t, i) {
				var n;
				return (n = e.call(this, t) || this)._items = null, n._interval = null, n._activeElement = null, n._isPaused = !1, n._isSliding = !1, n.touchTimeout = null, n.touchStartX = 0, n.touchDeltaX = 0, n._config = n._getConfig(i), n._indicatorsElement = W.findOne(".carousel-indicators", n._element), n._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, n._pointerEvent = Boolean(window.PointerEvent), n._addEventListeners(), n
			}
			n(r, e);
			var o = r.prototype;
			return o.next = function() {
				this._isSliding || this._slide("next")
			}, o.nextWhenVisible = function() {
				!document.hidden && m(this._element) && this.next()
			}, o.prev = function() {
				this._isSliding || this._slide("prev")
			}, o.pause = function(e) {
				e || (this._isPaused = !0), W.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (u(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
			}, o.cycle = function(e) {
				e || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
			}, o.to = function(e) {
				var t = this;
				this._activeElement = W.findOne(".active.carousel-item", this._element);
				var i = this._getItemIndex(this._activeElement);
				if (!(e > this._items.length - 1 || e < 0))
					if (this._isSliding) N.one(this._element, "slid.bs.carousel", (function() {
						return t.to(e)
					}));
					else {
						if (i === e) return this.pause(), void this.cycle();
						var n = e > i ? "next" : "prev";
						this._slide(n, this._items[e])
					}
			}, o.dispose = function() {
				e.prototype.dispose.call(this), N.off(this._element, ".bs.carousel"), this._items = null, this._config = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
			}, o._getConfig = function(e) {
				return e = i({}, X, e), f(q, e, Y), e
			}, o._handleSwipe = function() {
				var e = Math.abs(this.touchDeltaX);
				if (!(e <= 40)) {
					var t = e / this.touchDeltaX;
					this.touchDeltaX = 0, t > 0 && this.prev(), t < 0 && this.next()
				}
			}, o._addEventListeners = function() {
				var e = this;
				this._config.keyboard && N.on(this._element, "keydown.bs.carousel", (function(t) {
					return e._keydown(t)
				})), "hover" === this._config.pause && (N.on(this._element, "mouseenter.bs.carousel", (function(t) {
					return e.pause(t)
				})), N.on(this._element, "mouseleave.bs.carousel", (function(t) {
					return e.cycle(t)
				}))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
			}, o._addTouchEventListeners = function() {
				var e = this,
					t = function(t) {
						e._pointerEvent && Z[t.pointerType.toUpperCase()] ? e.touchStartX = t.clientX : e._pointerEvent || (e.touchStartX = t.touches[0].clientX)
					},
					i = function(t) {
						e._pointerEvent && Z[t.pointerType.toUpperCase()] && (e.touchDeltaX = t.clientX - e.touchStartX), e._handleSwipe(), "hover" === e._config.pause && (e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout((function(t) {
							return e.cycle(t)
						}), 500 + e._config.interval))
					};
				W.find(".carousel-item img", this._element).forEach((function(e) {
					N.on(e, "dragstart.bs.carousel", (function(e) {
						return e.preventDefault()
					}))
				})), this._pointerEvent ? (N.on(this._element, "pointerdown.bs.carousel", (function(e) {
					return t(e)
				})), N.on(this._element, "pointerup.bs.carousel", (function(e) {
					return i(e)
				})), this._element.classList.add("pointer-event")) : (N.on(this._element, "touchstart.bs.carousel", (function(e) {
					return t(e)
				})), N.on(this._element, "touchmove.bs.carousel", (function(t) {
					return function(t) {
						t.touches && t.touches.length > 1 ? e.touchDeltaX = 0 : e.touchDeltaX = t.touches[0].clientX - e.touchStartX
					}(t)
				})), N.on(this._element, "touchend.bs.carousel", (function(e) {
					return i(e)
				})))
			}, o._keydown = function(e) {
				if (!/input|textarea/i.test(e.target.tagName)) switch (e.key) {
					case "ArrowLeft":
						e.preventDefault(), this.prev();
						break;
					case "ArrowRight":
						e.preventDefault(), this.next()
				}
			}, o._getItemIndex = function(e) {
				return this._items = e && e.parentNode ? W.find(".carousel-item", e.parentNode) : [], this._items.indexOf(e)
			}, o._getItemByDirection = function(e, t) {
				var i = "next" === e,
					n = "prev" === e,
					r = this._getItemIndex(t),
					o = this._items.length - 1;
				if ((n && 0 === r || i && r === o) && !this._config.wrap) return t;
				var s = (r + ("prev" === e ? -1 : 1)) % this._items.length;
				return -1 === s ? this._items[this._items.length - 1] : this._items[s]
			}, o._triggerSlideEvent = function(e, t) {
				var i = this._getItemIndex(e),
					n = this._getItemIndex(W.findOne(".active.carousel-item", this._element));
				return N.trigger(this._element, "slide.bs.carousel", {
					relatedTarget: e,
					direction: t,
					from: n,
					to: i
				})
			}, o._setActiveIndicatorElement = function(e) {
				if (this._indicatorsElement) {
					for (var t = W.find(".active", this._indicatorsElement), i = 0; i < t.length; i++) t[i].classList.remove("active");
					var n = this._indicatorsElement.children[this._getItemIndex(e)];
					n && n.classList.add("active")
				}
			}, o._updateInterval = function() {
				var e = this._activeElement || W.findOne(".active.carousel-item", this._element);
				if (e) {
					var t = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
					t ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = t) : this._config.interval = this._config.defaultInterval || this._config.interval
				}
			}, o._slide = function(e, t) {
				var i, n, r, o = this,
					s = W.findOne(".active.carousel-item", this._element),
					a = this._getItemIndex(s),
					l = t || s && this._getItemByDirection(e, s),
					c = this._getItemIndex(l),
					u = Boolean(this._interval);
				if ("next" === e ? (i = "carousel-item-start", n = "carousel-item-next", r = "left") : (i = "carousel-item-end", n = "carousel-item-prev", r = "right"), l && l.classList.contains("active")) this._isSliding = !1;
				else if (!this._triggerSlideEvent(l, r).defaultPrevented && s && l) {
					if (this._isSliding = !0, u && this.pause(), this._setActiveIndicatorElement(l), this._activeElement = l, this._element.classList.contains("slide")) {
						l.classList.add(n), v(l), s.classList.add(i), l.classList.add(i);
						var d = h(s);
						N.one(s, "transitionend", (function() {
							l.classList.remove(i, n), l.classList.add("active"), s.classList.remove("active", n, i), o._isSliding = !1, setTimeout((function() {
								N.trigger(o._element, "slid.bs.carousel", {
									relatedTarget: l,
									direction: r,
									from: a,
									to: c
								})
							}), 0)
						})), p(s, d)
					} else s.classList.remove("active"), l.classList.add("active"), this._isSliding = !1, N.trigger(this._element, "slid.bs.carousel", {
						relatedTarget: l,
						direction: r,
						from: a,
						to: c
					});
					u && this.cycle()
				}
			}, r.carouselInterface = function(e, t) {
				var n = E(e, "bs.carousel"),
					o = i({}, X, V.getDataAttributes(e));
				"object" == typeof t && (o = i({}, o, t));
				var s = "string" == typeof t ? t : o.slide;
				if (n || (n = new r(e, o)), "number" == typeof t) n.to(t);
				else if ("string" == typeof s) {
					if (void 0 === n[s]) throw new TypeError('No method named "' + s + '"');
					n[s]()
				} else o.interval && o.ride && (n.pause(), n.cycle())
			}, r.jQueryInterface = function(e) {
				return this.each((function() {
					r.carouselInterface(this, e)
				}))
			}, r.dataApiClickHandler = function(e) {
				var t = c(this);
				if (t && t.classList.contains("carousel")) {
					var n = i({}, V.getDataAttributes(t), V.getDataAttributes(this)),
						o = this.getAttribute("data-bs-slide-to");
					o && (n.interval = !1), r.carouselInterface(t, n), o && E(t, "bs.carousel").to(o), e.preventDefault()
				}
			}, t(r, null, [{
				key: "Default",
				get: function() {
					return X
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.carousel"
				}
			}]), r
		}(B);
	N.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", Q.dataApiClickHandler), N.on(window, "load.bs.carousel.data-api", (function() {
		for (var e = W.find('[data-bs-ride="carousel"]'), t = 0, i = e.length; t < i; t++) Q.carouselInterface(e[t], E(e[t], "bs.carousel"))
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn[q];
			e.fn[q] = Q.jQueryInterface, e.fn[q].Constructor = Q, e.fn[q].noConflict = function() {
				return e.fn[q] = t, Q.jQueryInterface
			}
		}
	}));
	var J = "collapse",
		K = {
			toggle: !0,
			parent: ""
		},
		$ = {
			toggle: "boolean",
			parent: "(string|element)"
		},
		ee = function(e) {
			function r(t, i) {
				var n;
				(n = e.call(this, t) || this)._isTransitioning = !1, n._config = n._getConfig(i), n._triggerArray = W.find('[data-bs-toggle="collapse"][href="#' + t.id + '"],[data-bs-toggle="collapse"][data-bs-target="#' + t.id + '"]');
				for (var r = W.find('[data-bs-toggle="collapse"]'), o = 0, s = r.length; o < s; o++) {
					var a = r[o],
						c = l(a),
						h = W.find(c).filter((function(e) {
							return e === t
						}));
					null !== c && h.length && (n._selector = c, n._triggerArray.push(a))
				}
				return n._parent = n._config.parent ? n._getParent() : null, n._config.parent || n._addAriaAndCollapsedClass(n._element, n._triggerArray), n._config.toggle && n.toggle(), n
			}
			n(r, e);
			var o = r.prototype;
			return o.toggle = function() {
				this._element.classList.contains("show") ? this.hide() : this.show()
			}, o.show = function() {
				var e = this;
				if (!this._isTransitioning && !this._element.classList.contains("show")) {
					var t, i;
					this._parent && 0 === (t = W.find(".show, .collapsing", this._parent).filter((function(t) {
						return "string" == typeof e._config.parent ? t.getAttribute("data-bs-parent") === e._config.parent : t.classList.contains("collapse")
					}))).length && (t = null);
					var n = W.findOne(this._selector);
					if (t) {
						var o = t.find((function(e) {
							return n !== e
						}));
						if ((i = o ? E(o, "bs.collapse") : null) && i._isTransitioning) return
					}
					if (!N.trigger(this._element, "show.bs.collapse").defaultPrevented) {
						t && t.forEach((function(e) {
							n !== e && r.collapseInterface(e, "hide"), i || _(e, "bs.collapse", null)
						}));
						var s = this._getDimension();
						this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[s] = 0, this._triggerArray.length && this._triggerArray.forEach((function(e) {
							e.classList.remove("collapsed"), e.setAttribute("aria-expanded", !0)
						})), this.setTransitioning(!0);
						var a = "scroll" + (s[0].toUpperCase() + s.slice(1)),
							l = h(this._element);
						N.one(this._element, "transitionend", (function() {
							e._element.classList.remove("collapsing"), e._element.classList.add("collapse", "show"), e._element.style[s] = "", e.setTransitioning(!1), N.trigger(e._element, "shown.bs.collapse")
						})), p(this._element, l), this._element.style[s] = this._element[a] + "px"
					}
				}
			}, o.hide = function() {
				var e = this;
				if (!this._isTransitioning && this._element.classList.contains("show") && !N.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
					var t = this._getDimension();
					this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", v(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
					var i = this._triggerArray.length;
					if (i > 0)
						for (var n = 0; n < i; n++) {
							var r = this._triggerArray[n],
								o = c(r);
							o && !o.classList.contains("show") && (r.classList.add("collapsed"), r.setAttribute("aria-expanded", !1))
						}
					this.setTransitioning(!0), this._element.style[t] = "";
					var s = h(this._element);
					N.one(this._element, "transitionend", (function() {
						e.setTransitioning(!1), e._element.classList.remove("collapsing"), e._element.classList.add("collapse"), N.trigger(e._element, "hidden.bs.collapse")
					})), p(this._element, s)
				}
			}, o.setTransitioning = function(e) {
				this._isTransitioning = e
			}, o.dispose = function() {
				e.prototype.dispose.call(this), this._config = null, this._parent = null, this._triggerArray = null, this._isTransitioning = null
			}, o._getConfig = function(e) {
				return (e = i({}, K, e)).toggle = Boolean(e.toggle), f(J, e, $), e
			}, o._getDimension = function() {
				return this._element.classList.contains("width") ? "width" : "height"
			}, o._getParent = function() {
				var e = this,
					t = this._config.parent;
				d(t) ? void 0 === t.jquery && void 0 === t[0] || (t = t[0]) : t = W.findOne(t);
				var i = '[data-bs-toggle="collapse"][data-bs-parent="' + t + '"]';
				return W.find(i, t).forEach((function(t) {
					var i = c(t);
					e._addAriaAndCollapsedClass(i, [t])
				})), t
			}, o._addAriaAndCollapsedClass = function(e, t) {
				if (e && t.length) {
					var i = e.classList.contains("show");
					t.forEach((function(e) {
						i ? e.classList.remove("collapsed") : e.classList.add("collapsed"), e.setAttribute("aria-expanded", i)
					}))
				}
			}, r.collapseInterface = function(e, t) {
				var n = E(e, "bs.collapse"),
					o = i({}, K, V.getDataAttributes(e), "object" == typeof t && t ? t : {});
				if (!n && o.toggle && "string" == typeof t && /show|hide/.test(t) && (o.toggle = !1), n || (n = new r(e, o)), "string" == typeof t) {
					if (void 0 === n[t]) throw new TypeError('No method named "' + t + '"');
					n[t]()
				}
			}, r.jQueryInterface = function(e) {
				return this.each((function() {
					r.collapseInterface(this, e)
				}))
			}, t(r, null, [{
				key: "Default",
				get: function() {
					return K
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.collapse"
				}
			}]), r
		}(B);
	N.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', (function(e) {
		"A" === e.target.tagName && e.preventDefault();
		var t = V.getDataAttributes(this),
			i = l(this);
		W.find(i).forEach((function(e) {
			var i, n = E(e, "bs.collapse");
			n ? (null === n._parent && "string" == typeof t.parent && (n._config.parent = t.parent, n._parent = n._getParent()), i = "toggle") : i = t, ee.collapseInterface(e, i)
		}))
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn[J];
			e.fn[J] = ee.jQueryInterface, e.fn[J].Constructor = ee, e.fn[J].noConflict = function() {
				return e.fn[J] = t, ee.jQueryInterface
			}
		}
	}));
	var te = "top",
		ie = "bottom",
		ne = "right",
		re = "left",
		oe = [te, ie, ne, re],
		se = oe.reduce((function(e, t) {
			return e.concat([t + "-start", t + "-end"])
		}), []),
		ae = [].concat(oe, ["auto"]).reduce((function(e, t) {
			return e.concat([t, t + "-start", t + "-end"])
		}), []),
		le = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

	function ce(e) {
		return e ? (e.nodeName || "").toLowerCase() : null
	}

	function he(e) {
		if ("[object Window]" !== e.toString()) {
			var t = e.ownerDocument;
			return t && t.defaultView || window
		}
		return e
	}

	function ue(e) {
		return e instanceof he(e).Element || e instanceof Element
	}

	function de(e) {
		return e instanceof he(e).HTMLElement || e instanceof HTMLElement
	}
	var pe = {
		name: "applyStyles",
		enabled: !0,
		phase: "write",
		fn: function(e) {
			var t = e.state;
			Object.keys(t.elements).forEach((function(e) {
				var i = t.styles[e] || {},
					n = t.attributes[e] || {},
					r = t.elements[e];
				de(r) && ce(r) && (Object.assign(r.style, i), Object.keys(n).forEach((function(e) {
					var t = n[e];
					!1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? "" : t)
				})))
			}))
		},
		effect: function(e) {
			var t = e.state,
				i = {
					popper: {
						position: t.options.strategy,
						left: "0",
						top: "0",
						margin: "0"
					},
					arrow: {
						position: "absolute"
					},
					reference: {}
				};
			return Object.assign(t.elements.popper.style, i.popper), t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
				function() {
					Object.keys(t.elements).forEach((function(e) {
						var n = t.elements[e],
							r = t.attributes[e] || {},
							o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function(e, t) {
								return e[t] = "", e
							}), {});
						de(n) && ce(n) && (Object.assign(n.style, o), Object.keys(r).forEach((function(e) {
							n.removeAttribute(e)
						})))
					}))
				}
		},
		requires: ["computeStyles"]
	};

	function fe(e) {
		return e.split("-")[0]
	}

	function me(e) {
		return {
			x: e.offsetLeft,
			y: e.offsetTop,
			width: e.offsetWidth,
			height: e.offsetHeight
		}
	}

	function ge(e, t) {
		var i, n = t.getRootNode && t.getRootNode();
		if (e.contains(t)) return !0;
		if (n && ((i = n) instanceof he(i).ShadowRoot || i instanceof ShadowRoot)) {
			var r = t;
			do {
				if (r && e.isSameNode(r)) return !0;
				r = r.parentNode || r.host
			} while (r)
		}
		return !1
	}

	function ve(e) {
		return he(e).getComputedStyle(e)
	}

	function ye(e) {
		return ["table", "td", "th"].indexOf(ce(e)) >= 0
	}

	function be(e) {
		return ((ue(e) ? e.ownerDocument : e.document) || window.document).documentElement
	}

	function we(e) {
		return "html" === ce(e) ? e : e.assignedSlot || e.parentNode || e.host || be(e)
	}

	function xe(e) {
		if (!de(e) || "fixed" === ve(e).position) return null;
		var t = e.offsetParent;
		if (t) {
			var i = be(t);
			if ("body" === ce(t) && "static" === ve(t).position && "static" !== ve(i).position) return i
		}
		return t
	}

	function _e(e) {
		for (var t = he(e), i = xe(e); i && ye(i) && "static" === ve(i).position;) i = xe(i);
		return i && "body" === ce(i) && "static" === ve(i).position ? t : i || function(e) {
			for (var t = we(e); de(t) && ["html", "body"].indexOf(ce(t)) < 0;) {
				var i = ve(t);
				if ("none" !== i.transform || "none" !== i.perspective || i.willChange && "auto" !== i.willChange) return t;
				t = t.parentNode
			}
			return null
		}(e) || t
	}

	function Ee(e) {
		return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
	}

	function Me(e, t, i) {
		return Math.max(e, Math.min(t, i))
	}

	function Se(e) {
		return Object.assign(Object.assign({}, {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0
		}), e)
	}

	function Te(e, t) {
		return t.reduce((function(t, i) {
			return t[i] = e, t
		}), {})
	}
	var Ae = {
			name: "arrow",
			enabled: !0,
			phase: "main",
			fn: function(e) {
				var t, i = e.state,
					n = e.name,
					r = i.elements.arrow,
					o = i.modifiersData.popperOffsets,
					s = fe(i.placement),
					a = Ee(s),
					l = [re, ne].indexOf(s) >= 0 ? "height" : "width";
				if (r && o) {
					var c = i.modifiersData[n + "#persistent"].padding,
						h = me(r),
						u = "y" === a ? te : re,
						d = "y" === a ? ie : ne,
						p = i.rects.reference[l] + i.rects.reference[a] - o[a] - i.rects.popper[l],
						f = o[a] - i.rects.reference[a],
						m = _e(r),
						g = m ? "y" === a ? m.clientHeight || 0 : m.clientWidth || 0 : 0,
						v = p / 2 - f / 2,
						y = c[u],
						b = g - h[l] - c[d],
						w = g / 2 - h[l] / 2 + v,
						x = Me(y, w, b),
						_ = a;
					i.modifiersData[n] = ((t = {})[_] = x, t.centerOffset = x - w, t)
				}
			},
			effect: function(e) {
				var t = e.state,
					i = e.options,
					n = e.name,
					r = i.element,
					o = void 0 === r ? "[data-popper-arrow]" : r,
					s = i.padding,
					a = void 0 === s ? 0 : s;
				null != o && ("string" != typeof o || (o = t.elements.popper.querySelector(o))) && ge(t.elements.popper, o) && (t.elements.arrow = o, t.modifiersData[n + "#persistent"] = {
					padding: Se("number" != typeof a ? a : Te(a, oe))
				})
			},
			requires: ["popperOffsets"],
			requiresIfExists: ["preventOverflow"]
		},
		Le = {
			top: "auto",
			right: "auto",
			bottom: "auto",
			left: "auto"
		};

	function Ce(e) {
		var t, i = e.popper,
			n = e.popperRect,
			r = e.placement,
			o = e.offsets,
			s = e.position,
			a = e.gpuAcceleration,
			l = e.adaptive,
			c = function(e) {
				var t = e.x,
					i = e.y,
					n = window.devicePixelRatio || 1;
				return {
					x: Math.round(t * n) / n || 0,
					y: Math.round(i * n) / n || 0
				}
			}(o),
			h = c.x,
			u = c.y,
			d = o.hasOwnProperty("x"),
			p = o.hasOwnProperty("y"),
			f = re,
			m = te,
			g = window;
		if (l) {
			var v = _e(i);
			v === he(i) && (v = be(i)), r === te && (m = ie, u -= v.clientHeight - n.height, u *= a ? 1 : -1), r === re && (f = ne, h -= v.clientWidth - n.width, h *= a ? 1 : -1)
		}
		var y, b = Object.assign({
			position: s
		}, l && Le);
		return a ? Object.assign(Object.assign({}, b), {}, ((y = {})[m] = p ? "0" : "", y[f] = d ? "0" : "", y.transform = (g.devicePixelRatio || 1) < 2 ? "translate(" + h + "px, " + u + "px)" : "translate3d(" + h + "px, " + u + "px, 0)", y)) : Object.assign(Object.assign({}, b), {}, ((t = {})[m] = p ? u + "px" : "", t[f] = d ? h + "px" : "", t.transform = "", t))
	}
	var Pe = {
			name: "computeStyles",
			enabled: !0,
			phase: "beforeWrite",
			fn: function(e) {
				var t = e.state,
					i = e.options,
					n = i.gpuAcceleration,
					r = void 0 === n || n,
					o = i.adaptive,
					s = void 0 === o || o,
					a = {
						placement: fe(t.placement),
						popper: t.elements.popper,
						popperRect: t.rects.popper,
						gpuAcceleration: r
					};
				null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign(Object.assign({}, t.styles.popper), Ce(Object.assign(Object.assign({}, a), {}, {
					offsets: t.modifiersData.popperOffsets,
					position: t.options.strategy,
					adaptive: s
				})))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign(Object.assign({}, t.styles.arrow), Ce(Object.assign(Object.assign({}, a), {}, {
					offsets: t.modifiersData.arrow,
					position: "absolute",
					adaptive: !1
				})))), t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, {
					"data-popper-placement": t.placement
				})
			},
			data: {}
		},
		Ie = {
			passive: !0
		},
		Re = {
			name: "eventListeners",
			enabled: !0,
			phase: "write",
			fn: function() {},
			effect: function(e) {
				var t = e.state,
					i = e.instance,
					n = e.options,
					r = n.scroll,
					o = void 0 === r || r,
					s = n.resize,
					a = void 0 === s || s,
					l = he(t.elements.popper),
					c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
				return o && c.forEach((function(e) {
						e.addEventListener("scroll", i.update, Ie)
					})), a && l.addEventListener("resize", i.update, Ie),
					function() {
						o && c.forEach((function(e) {
							e.removeEventListener("scroll", i.update, Ie)
						})), a && l.removeEventListener("resize", i.update, Ie)
					}
			},
			data: {}
		},
		Oe = {
			left: "right",
			right: "left",
			bottom: "top",
			top: "bottom"
		};

	function De(e) {
		return e.replace(/left|right|bottom|top/g, (function(e) {
			return Oe[e]
		}))
	}
	var ze = {
		start: "end",
		end: "start"
	};

	function ke(e) {
		return e.replace(/start|end/g, (function(e) {
			return ze[e]
		}))
	}

	function Ne(e) {
		var t = e.getBoundingClientRect();
		return {
			width: t.width,
			height: t.height,
			top: t.top,
			right: t.right,
			bottom: t.bottom,
			left: t.left,
			x: t.left,
			y: t.top
		}
	}

	function Be(e) {
		var t = he(e);
		return {
			scrollLeft: t.pageXOffset,
			scrollTop: t.pageYOffset
		}
	}

	function He(e) {
		return Ne(be(e)).left + Be(e).scrollLeft
	}

	function Fe(e) {
		var t = ve(e),
			i = t.overflow,
			n = t.overflowX,
			r = t.overflowY;
		return /auto|scroll|overlay|hidden/.test(i + r + n)
	}

	function Ue(e, t) {
		void 0 === t && (t = []);
		var i = function e(t) {
				return ["html", "body", "#document"].indexOf(ce(t)) >= 0 ? t.ownerDocument.body : de(t) && Fe(t) ? t : e(we(t))
			}(e),
			n = "body" === ce(i),
			r = he(i),
			o = n ? [r].concat(r.visualViewport || [], Fe(i) ? i : []) : i,
			s = t.concat(o);
		return n ? s : s.concat(Ue(we(o)))
	}

	function je(e) {
		return Object.assign(Object.assign({}, e), {}, {
			left: e.x,
			top: e.y,
			right: e.x + e.width,
			bottom: e.y + e.height
		})
	}

	function Ge(e, t) {
		return "viewport" === t ? je(function(e) {
			var t = he(e),
				i = be(e),
				n = t.visualViewport,
				r = i.clientWidth,
				o = i.clientHeight,
				s = 0,
				a = 0;
			return n && (r = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (s = n.offsetLeft, a = n.offsetTop)), {
				width: r,
				height: o,
				x: s + He(e),
				y: a
			}
		}(e)) : de(t) ? function(e) {
			var t = Ne(e);
			return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t
		}(t) : je(function(e) {
			var t = be(e),
				i = Be(e),
				n = e.ownerDocument.body,
				r = Math.max(t.scrollWidth, t.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0),
				o = Math.max(t.scrollHeight, t.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0),
				s = -i.scrollLeft + He(e),
				a = -i.scrollTop;
			return "rtl" === ve(n || t).direction && (s += Math.max(t.clientWidth, n ? n.clientWidth : 0) - r), {
				width: r,
				height: o,
				x: s,
				y: a
			}
		}(be(e)))
	}

	function Ve(e) {
		return e.split("-")[1]
	}

	function We(e) {
		var t, i = e.reference,
			n = e.element,
			r = e.placement,
			o = r ? fe(r) : null,
			s = r ? Ve(r) : null,
			a = i.x + i.width / 2 - n.width / 2,
			l = i.y + i.height / 2 - n.height / 2;
		switch (o) {
			case te:
				t = {
					x: a,
					y: i.y - n.height
				};
				break;
			case ie:
				t = {
					x: a,
					y: i.y + i.height
				};
				break;
			case ne:
				t = {
					x: i.x + i.width,
					y: l
				};
				break;
			case re:
				t = {
					x: i.x - n.width,
					y: l
				};
				break;
			default:
				t = {
					x: i.x,
					y: i.y
				}
		}
		var c = o ? Ee(o) : null;
		if (null != c) {
			var h = "y" === c ? "height" : "width";
			switch (s) {
				case "start":
					t[c] = Math.floor(t[c]) - Math.floor(i[h] / 2 - n[h] / 2);
					break;
				case "end":
					t[c] = Math.floor(t[c]) + Math.ceil(i[h] / 2 - n[h] / 2)
			}
		}
		return t
	}

	function qe(e, t) {
		void 0 === t && (t = {});
		var i = t,
			n = i.placement,
			r = void 0 === n ? e.placement : n,
			o = i.boundary,
			s = void 0 === o ? "clippingParents" : o,
			a = i.rootBoundary,
			l = void 0 === a ? "viewport" : a,
			c = i.elementContext,
			h = void 0 === c ? "popper" : c,
			u = i.altBoundary,
			d = void 0 !== u && u,
			p = i.padding,
			f = void 0 === p ? 0 : p,
			m = Se("number" != typeof f ? f : Te(f, oe)),
			g = "popper" === h ? "reference" : "popper",
			v = e.elements.reference,
			y = e.rects.popper,
			b = e.elements[d ? g : h],
			w = function(e, t, i) {
				var n = "clippingParents" === t ? function(e) {
						var t = Ue(we(e)),
							i = ["absolute", "fixed"].indexOf(ve(e).position) >= 0 && de(e) ? _e(e) : e;
						return ue(i) ? t.filter((function(e) {
							return ue(e) && ge(e, i) && "body" !== ce(e)
						})) : []
					}(e) : [].concat(t),
					r = [].concat(n, [i]),
					o = r[0],
					s = r.reduce((function(t, i) {
						var n = Ge(e, i);
						return t.top = Math.max(n.top, t.top), t.right = Math.min(n.right, t.right), t.bottom = Math.min(n.bottom, t.bottom), t.left = Math.max(n.left, t.left), t
					}), Ge(e, o));
				return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s
			}(ue(b) ? b : b.contextElement || be(e.elements.popper), s, l),
			x = Ne(v),
			_ = We({
				reference: x,
				element: y,
				strategy: "absolute",
				placement: r
			}),
			E = je(Object.assign(Object.assign({}, y), _)),
			M = "popper" === h ? E : x,
			S = {
				top: w.top - M.top + m.top,
				bottom: M.bottom - w.bottom + m.bottom,
				left: w.left - M.left + m.left,
				right: M.right - w.right + m.right
			},
			T = e.modifiersData.offset;
		if ("popper" === h && T) {
			var A = T[r];
			Object.keys(S).forEach((function(e) {
				var t = [ne, ie].indexOf(e) >= 0 ? 1 : -1,
					i = [te, ie].indexOf(e) >= 0 ? "y" : "x";
				S[e] += A[i] * t
			}))
		}
		return S
	}
	var Xe = {
		name: "flip",
		enabled: !0,
		phase: "main",
		fn: function(e) {
			var t = e.state,
				i = e.options,
				n = e.name;
			if (!t.modifiersData[n]._skip) {
				for (var r = i.mainAxis, o = void 0 === r || r, s = i.altAxis, a = void 0 === s || s, l = i.fallbackPlacements, c = i.padding, h = i.boundary, u = i.rootBoundary, d = i.altBoundary, p = i.flipVariations, f = void 0 === p || p, m = i.allowedAutoPlacements, g = t.options.placement, v = fe(g), y = l || (v !== g && f ? function(e) {
						if ("auto" === fe(e)) return [];
						var t = De(e);
						return [ke(e), t, ke(t)]
					}(g) : [De(g)]), b = [g].concat(y).reduce((function(e, i) {
						return e.concat("auto" === fe(i) ? function(e, t) {
							void 0 === t && (t = {});
							var i = t,
								n = i.placement,
								r = i.boundary,
								o = i.rootBoundary,
								s = i.padding,
								a = i.flipVariations,
								l = i.allowedAutoPlacements,
								c = void 0 === l ? ae : l,
								h = Ve(n),
								u = h ? a ? se : se.filter((function(e) {
									return Ve(e) === h
								})) : oe,
								d = u.filter((function(e) {
									return c.indexOf(e) >= 0
								}));
							0 === d.length && (d = u);
							var p = d.reduce((function(t, i) {
								return t[i] = qe(e, {
									placement: i,
									boundary: r,
									rootBoundary: o,
									padding: s
								})[fe(i)], t
							}), {});
							return Object.keys(p).sort((function(e, t) {
								return p[e] - p[t]
							}))
						}(t, {
							placement: i,
							boundary: h,
							rootBoundary: u,
							padding: c,
							flipVariations: f,
							allowedAutoPlacements: m
						}) : i)
					}), []), w = t.rects.reference, x = t.rects.popper, _ = new Map, E = !0, M = b[0], S = 0; S < b.length; S++) {
					var T = b[S],
						A = fe(T),
						L = "start" === Ve(T),
						C = [te, ie].indexOf(A) >= 0,
						P = C ? "width" : "height",
						I = qe(t, {
							placement: T,
							boundary: h,
							rootBoundary: u,
							altBoundary: d,
							padding: c
						}),
						R = C ? L ? ne : re : L ? ie : te;
					w[P] > x[P] && (R = De(R));
					var O = De(R),
						D = [];
					if (o && D.push(I[A] <= 0), a && D.push(I[R] <= 0, I[O] <= 0), D.every((function(e) {
							return e
						}))) {
						M = T, E = !1;
						break
					}
					_.set(T, D)
				}
				if (E)
					for (var z = function(e) {
							var t = b.find((function(t) {
								var i = _.get(t);
								if (i) return i.slice(0, e).every((function(e) {
									return e
								}))
							}));
							if (t) return M = t, "break"
						}, k = f ? 3 : 1; k > 0 && "break" !== z(k); k--);
				t.placement !== M && (t.modifiersData[n]._skip = !0, t.placement = M, t.reset = !0)
			}
		},
		requiresIfExists: ["offset"],
		data: {
			_skip: !1
		}
	};

	function Ye(e, t, i) {
		return void 0 === i && (i = {
			x: 0,
			y: 0
		}), {
			top: e.top - t.height - i.y,
			right: e.right - t.width + i.x,
			bottom: e.bottom - t.height + i.y,
			left: e.left - t.width - i.x
		}
	}

	function Ze(e) {
		return [te, ne, ie, re].some((function(t) {
			return e[t] >= 0
		}))
	}
	var Qe = {
			name: "hide",
			enabled: !0,
			phase: "main",
			requiresIfExists: ["preventOverflow"],
			fn: function(e) {
				var t = e.state,
					i = e.name,
					n = t.rects.reference,
					r = t.rects.popper,
					o = t.modifiersData.preventOverflow,
					s = qe(t, {
						elementContext: "reference"
					}),
					a = qe(t, {
						altBoundary: !0
					}),
					l = Ye(s, n),
					c = Ye(a, r, o),
					h = Ze(l),
					u = Ze(c);
				t.modifiersData[i] = {
					referenceClippingOffsets: l,
					popperEscapeOffsets: c,
					isReferenceHidden: h,
					hasPopperEscaped: u
				}, t.attributes.popper = Object.assign(Object.assign({}, t.attributes.popper), {}, {
					"data-popper-reference-hidden": h,
					"data-popper-escaped": u
				})
			}
		},
		Je = {
			name: "offset",
			enabled: !0,
			phase: "main",
			requires: ["popperOffsets"],
			fn: function(e) {
				var t = e.state,
					i = e.options,
					n = e.name,
					r = i.offset,
					o = void 0 === r ? [0, 0] : r,
					s = ae.reduce((function(e, i) {
						return e[i] = function(e, t, i) {
							var n = fe(e),
								r = [re, te].indexOf(n) >= 0 ? -1 : 1,
								o = "function" == typeof i ? i(Object.assign(Object.assign({}, t), {}, {
									placement: e
								})) : i,
								s = o[0],
								a = o[1];
							return s = s || 0, a = (a || 0) * r, [re, ne].indexOf(n) >= 0 ? {
								x: a,
								y: s
							} : {
								x: s,
								y: a
							}
						}(i, t.rects, o), e
					}), {}),
					a = s[t.placement],
					l = a.x,
					c = a.y;
				null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[n] = s
			}
		},
		Ke = {
			name: "popperOffsets",
			enabled: !0,
			phase: "read",
			fn: function(e) {
				var t = e.state,
					i = e.name;
				t.modifiersData[i] = We({
					reference: t.rects.reference,
					element: t.rects.popper,
					strategy: "absolute",
					placement: t.placement
				})
			},
			data: {}
		},
		$e = {
			name: "preventOverflow",
			enabled: !0,
			phase: "main",
			fn: function(e) {
				var t = e.state,
					i = e.options,
					n = e.name,
					r = i.mainAxis,
					o = void 0 === r || r,
					s = i.altAxis,
					a = void 0 !== s && s,
					l = i.boundary,
					c = i.rootBoundary,
					h = i.altBoundary,
					u = i.padding,
					d = i.tether,
					p = void 0 === d || d,
					f = i.tetherOffset,
					m = void 0 === f ? 0 : f,
					g = qe(t, {
						boundary: l,
						rootBoundary: c,
						padding: u,
						altBoundary: h
					}),
					v = fe(t.placement),
					y = Ve(t.placement),
					b = !y,
					w = Ee(v),
					x = "x" === w ? "y" : "x",
					_ = t.modifiersData.popperOffsets,
					E = t.rects.reference,
					M = t.rects.popper,
					S = "function" == typeof m ? m(Object.assign(Object.assign({}, t.rects), {}, {
						placement: t.placement
					})) : m,
					T = {
						x: 0,
						y: 0
					};
				if (_) {
					if (o) {
						var A = "y" === w ? te : re,
							L = "y" === w ? ie : ne,
							C = "y" === w ? "height" : "width",
							P = _[w],
							I = _[w] + g[A],
							R = _[w] - g[L],
							O = p ? -M[C] / 2 : 0,
							D = "start" === y ? E[C] : M[C],
							z = "start" === y ? -M[C] : -E[C],
							k = t.elements.arrow,
							N = p && k ? me(k) : {
								width: 0,
								height: 0
							},
							B = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : {
								top: 0,
								right: 0,
								bottom: 0,
								left: 0
							},
							H = B[A],
							F = B[L],
							U = Me(0, E[C], N[C]),
							j = b ? E[C] / 2 - O - U - H - S : D - U - H - S,
							G = b ? -E[C] / 2 + O + U + F + S : z + U + F + S,
							V = t.elements.arrow && _e(t.elements.arrow),
							W = V ? "y" === w ? V.clientTop || 0 : V.clientLeft || 0 : 0,
							q = t.modifiersData.offset ? t.modifiersData.offset[t.placement][w] : 0,
							X = _[w] + j - q - W,
							Y = _[w] + G - q,
							Z = Me(p ? Math.min(I, X) : I, P, p ? Math.max(R, Y) : R);
						_[w] = Z, T[w] = Z - P
					}
					if (a) {
						var Q = "x" === w ? te : re,
							J = "x" === w ? ie : ne,
							K = _[x],
							$ = Me(K + g[Q], K, K - g[J]);
						_[x] = $, T[x] = $ - K
					}
					t.modifiersData[n] = T
				}
			},
			requiresIfExists: ["offset"]
		};

	function et(e, t, i) {
		void 0 === i && (i = !1);
		var n, r, o = be(t),
			s = Ne(e),
			a = de(t),
			l = {
				scrollLeft: 0,
				scrollTop: 0
			},
			c = {
				x: 0,
				y: 0
			};
		return (a || !a && !i) && (("body" !== ce(t) || Fe(o)) && (l = (n = t) !== he(n) && de(n) ? {
			scrollLeft: (r = n).scrollLeft,
			scrollTop: r.scrollTop
		} : Be(n)), de(t) ? ((c = Ne(t)).x += t.clientLeft, c.y += t.clientTop) : o && (c.x = He(o))), {
			x: s.left + l.scrollLeft - c.x,
			y: s.top + l.scrollTop - c.y,
			width: s.width,
			height: s.height
		}
	}
	var tt = {
		placement: "bottom",
		modifiers: [],
		strategy: "absolute"
	};

	function it() {
		for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
		return !t.some((function(e) {
			return !(e && "function" == typeof e.getBoundingClientRect)
		}))
	}

	function nt(e) {
		void 0 === e && (e = {});
		var t = e,
			i = t.defaultModifiers,
			n = void 0 === i ? [] : i,
			r = t.defaultOptions,
			o = void 0 === r ? tt : r;
		return function(e, t, i) {
			void 0 === i && (i = o);
			var r, s, a = {
					placement: "bottom",
					orderedModifiers: [],
					options: Object.assign(Object.assign({}, tt), o),
					modifiersData: {},
					elements: {
						reference: e,
						popper: t
					},
					attributes: {},
					styles: {}
				},
				l = [],
				c = !1,
				h = {
					state: a,
					setOptions: function(i) {
						u(), a.options = Object.assign(Object.assign(Object.assign({}, o), a.options), i), a.scrollParents = {
							reference: ue(e) ? Ue(e) : e.contextElement ? Ue(e.contextElement) : [],
							popper: Ue(t)
						};
						var r, s, c = function(e) {
							var t = function(e) {
								var t = new Map,
									i = new Set,
									n = [];
								return e.forEach((function(e) {
									t.set(e.name, e)
								})), e.forEach((function(e) {
									i.has(e.name) || function e(r) {
										i.add(r.name), [].concat(r.requires || [], r.requiresIfExists || []).forEach((function(n) {
											if (!i.has(n)) {
												var r = t.get(n);
												r && e(r)
											}
										})), n.push(r)
									}(e)
								})), n
							}(e);
							return le.reduce((function(e, i) {
								return e.concat(t.filter((function(e) {
									return e.phase === i
								})))
							}), [])
						}((r = [].concat(n, a.options.modifiers), s = r.reduce((function(e, t) {
							var i = e[t.name];
							return e[t.name] = i ? Object.assign(Object.assign(Object.assign({}, i), t), {}, {
								options: Object.assign(Object.assign({}, i.options), t.options),
								data: Object.assign(Object.assign({}, i.data), t.data)
							}) : t, e
						}), {}), Object.keys(s).map((function(e) {
							return s[e]
						}))));
						return a.orderedModifiers = c.filter((function(e) {
							return e.enabled
						})), a.orderedModifiers.forEach((function(e) {
							var t = e.name,
								i = e.options,
								n = void 0 === i ? {} : i,
								r = e.effect;
							if ("function" == typeof r) {
								var o = r({
									state: a,
									name: t,
									instance: h,
									options: n
								});
								l.push(o || function() {})
							}
						})), h.update()
					},
					forceUpdate: function() {
						if (!c) {
							var e = a.elements,
								t = e.reference,
								i = e.popper;
							if (it(t, i)) {
								a.rects = {
									reference: et(t, _e(i), "fixed" === a.options.strategy),
									popper: me(i)
								}, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function(e) {
									return a.modifiersData[e.name] = Object.assign({}, e.data)
								}));
								for (var n = 0; n < a.orderedModifiers.length; n++)
									if (!0 !== a.reset) {
										var r = a.orderedModifiers[n],
											o = r.fn,
											s = r.options,
											l = void 0 === s ? {} : s,
											u = r.name;
										"function" == typeof o && (a = o({
											state: a,
											options: l,
											name: u,
											instance: h
										}) || a)
									} else a.reset = !1, n = -1
							}
						}
					},
					update: (r = function() {
						return new Promise((function(e) {
							h.forceUpdate(), e(a)
						}))
					}, function() {
						return s || (s = new Promise((function(e) {
							Promise.resolve().then((function() {
								s = void 0, e(r())
							}))
						}))), s
					}),
					destroy: function() {
						u(), c = !0
					}
				};
			if (!it(e, t)) return h;

			function u() {
				l.forEach((function(e) {
					return e()
				})), l = []
			}
			return h.setOptions(i).then((function(e) {
				!c && i.onFirstUpdate && i.onFirstUpdate(e)
			})), h
		}
	}
	var rt = nt(),
		ot = nt({
			defaultModifiers: [Re, Ke, Pe, pe]
		}),
		st = nt({
			defaultModifiers: [Re, Ke, Pe, pe, Je, Xe, $e, Ae, Qe]
		}),
		at = Object.freeze({
			__proto__: null,
			popperGenerator: nt,
			detectOverflow: qe,
			createPopperBase: rt,
			createPopper: st,
			createPopperLite: ot,
			top: te,
			bottom: ie,
			right: ne,
			left: re,
			auto: "auto",
			basePlacements: oe,
			start: "start",
			end: "end",
			clippingParents: "clippingParents",
			viewport: "viewport",
			popper: "popper",
			reference: "reference",
			variationPlacements: se,
			placements: ae,
			beforeRead: "beforeRead",
			read: "read",
			afterRead: "afterRead",
			beforeMain: "beforeMain",
			main: "main",
			afterMain: "afterMain",
			beforeWrite: "beforeWrite",
			write: "write",
			afterWrite: "afterWrite",
			modifierPhases: le,
			applyStyles: pe,
			arrow: Ae,
			computeStyles: Pe,
			eventListeners: Re,
			flip: Xe,
			hide: Qe,
			offset: Je,
			popperOffsets: Ke,
			preventOverflow: $e
		}),
		lt = "dropdown",
		ct = new RegExp("ArrowUp|ArrowDown|Escape"),
		ht = w ? "top-end" : "top-start",
		ut = w ? "top-start" : "top-end",
		dt = w ? "bottom-end" : "bottom-start",
		pt = w ? "bottom-start" : "bottom-end",
		ft = w ? "left-start" : "right-start",
		mt = w ? "right-start" : "left-start",
		gt = {
			offset: 0,
			flip: !0,
			boundary: "clippingParents",
			reference: "toggle",
			display: "dynamic",
			popperConfig: null
		},
		vt = {
			offset: "(number|string|function)",
			flip: "boolean",
			boundary: "(string|element)",
			reference: "(string|element)",
			display: "string",
			popperConfig: "(null|object)"
		},
		yt = function(e) {
			function r(t, i) {
				var n;
				return (n = e.call(this, t) || this)._popper = null, n._config = n._getConfig(i), n._menu = n._getMenuElement(), n._inNavbar = n._detectNavbar(), n._addEventListeners(), n
			}
			n(r, e);
			var o = r.prototype;
			return o.toggle = function() {
				if (!this._element.disabled && !this._element.classList.contains("disabled")) {
					var e = this._element.classList.contains("show");
					r.clearMenus(), e || this.show()
				}
			}, o.show = function() {
				if (!(this._element.disabled || this._element.classList.contains("disabled") || this._menu.classList.contains("show"))) {
					var e = r.getParentFromElement(this._element),
						t = {
							relatedTarget: this._element
						};
					if (!N.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
						if (!this._inNavbar) {
							if (void 0 === at) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
							var i = this._element;
							"parent" === this._config.reference ? i = e : d(this._config.reference) && (i = this._config.reference, void 0 !== this._config.reference.jquery && (i = this._config.reference[0])), this._popper = st(i, this._menu, this._getPopperConfig())
						}
						var n;
						"ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && (n = []).concat.apply(n, document.body.children).forEach((function(e) {
							return N.on(e, "mouseover", null, (function() {}))
						})), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), N.trigger(e, "shown.bs.dropdown", t)
					}
				}
			}, o.hide = function() {
				if (!this._element.disabled && !this._element.classList.contains("disabled") && this._menu.classList.contains("show")) {
					var e = r.getParentFromElement(this._element),
						t = {
							relatedTarget: this._element
						};
					N.trigger(e, "hide.bs.dropdown", t).defaultPrevented || (this._popper && this._popper.destroy(), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), N.trigger(e, "hidden.bs.dropdown", t))
				}
			}, o.dispose = function() {
				e.prototype.dispose.call(this), N.off(this._element, ".bs.dropdown"), this._menu = null, this._popper && (this._popper.destroy(), this._popper = null)
			}, o.update = function() {
				this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
			}, o._addEventListeners = function() {
				var e = this;
				N.on(this._element, "click.bs.dropdown", (function(t) {
					t.preventDefault(), t.stopPropagation(), e.toggle()
				}))
			}, o._getConfig = function(e) {
				return e = i({}, this.constructor.Default, V.getDataAttributes(this._element), e), f(lt, e, this.constructor.DefaultType), e
			}, o._getMenuElement = function() {
				return W.next(this._element, ".dropdown-menu")[0]
			}, o._getPlacement = function() {
				var e = this._element.parentNode;
				if (e.classList.contains("dropend")) return ft;
				if (e.classList.contains("dropstart")) return mt;
				var t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
				return e.classList.contains("dropup") ? t ? ut : ht : t ? pt : dt
			}, o._detectNavbar = function() {
				return null !== this._element.closest(".navbar")
			}, o._getPopperConfig = function() {
				var e = {
					placement: this._getPlacement(),
					modifiers: [{
						name: "preventOverflow",
						options: {
							altBoundary: this._config.flip,
							rootBoundary: this._config.boundary
						}
					}]
				};
				return "static" === this._config.display && (e.modifiers = [{
					name: "applyStyles",
					enabled: !1
				}]), i({}, e, this._config.popperConfig)
			}, r.dropdownInterface = function(e, t) {
				var i = E(e, "bs.dropdown");
				if (i || (i = new r(e, "object" == typeof t ? t : null)), "string" == typeof t) {
					if (void 0 === i[t]) throw new TypeError('No method named "' + t + '"');
					i[t]()
				}
			}, r.jQueryInterface = function(e) {
				return this.each((function() {
					r.dropdownInterface(this, e)
				}))
			}, r.clearMenus = function(e) {
				if (!e || 2 !== e.button && ("keyup" !== e.type || "Tab" === e.key))
					for (var t = W.find('[data-bs-toggle="dropdown"]'), i = 0, n = t.length; i < n; i++) {
						var o = r.getParentFromElement(t[i]),
							s = E(t[i], "bs.dropdown"),
							a = {
								relatedTarget: t[i]
							};
						if (e && "click" === e.type && (a.clickEvent = e), s) {
							var l, c = s._menu;
							if (t[i].classList.contains("show") && !(e && ("click" === e.type && /input|textarea/i.test(e.target.tagName) || "keyup" === e.type && "Tab" === e.key) && c.contains(e.target) || N.trigger(o, "hide.bs.dropdown", a).defaultPrevented)) "ontouchstart" in document.documentElement && (l = []).concat.apply(l, document.body.children).forEach((function(e) {
								return N.off(e, "mouseover", null, (function() {}))
							})), t[i].setAttribute("aria-expanded", "false"), s._popper && s._popper.destroy(), c.classList.remove("show"), t[i].classList.remove("show"), N.trigger(o, "hidden.bs.dropdown", a)
						}
					}
			}, r.getParentFromElement = function(e) {
				return c(e) || e.parentNode
			}, r.dataApiKeydownHandler = function(e) {
				if (!(/input|textarea/i.test(e.target.tagName) ? "Space" === e.key || "Escape" !== e.key && ("ArrowDown" !== e.key && "ArrowUp" !== e.key || e.target.closest(".dropdown-menu")) : !ct.test(e.key)) && (e.preventDefault(), e.stopPropagation(), !this.disabled && !this.classList.contains("disabled"))) {
					var t = r.getParentFromElement(this),
						i = this.classList.contains("show");
					if ("Escape" === e.key) return (this.matches('[data-bs-toggle="dropdown"]') ? this : W.prev(this, '[data-bs-toggle="dropdown"]')[0]).focus(), void r.clearMenus();
					if (i && "Space" !== e.key) {
						var n = W.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", t).filter(m);
						if (n.length) {
							var o = n.indexOf(e.target);
							"ArrowUp" === e.key && o > 0 && o--, "ArrowDown" === e.key && o < n.length - 1 && o++, n[o = -1 === o ? 0 : o].focus()
						}
					} else r.clearMenus()
				}
			}, t(r, null, [{
				key: "Default",
				get: function() {
					return gt
				}
			}, {
				key: "DefaultType",
				get: function() {
					return vt
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.dropdown"
				}
			}]), r
		}(B);
	N.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', yt.dataApiKeydownHandler), N.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", yt.dataApiKeydownHandler), N.on(document, "click.bs.dropdown.data-api", yt.clearMenus), N.on(document, "keyup.bs.dropdown.data-api", yt.clearMenus), N.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', (function(e) {
		e.preventDefault(), e.stopPropagation(), yt.dropdownInterface(this, "toggle")
	})), N.on(document, "click.bs.dropdown.data-api", ".dropdown form", (function(e) {
		return e.stopPropagation()
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn[lt];
			e.fn[lt] = yt.jQueryInterface, e.fn[lt].Constructor = yt, e.fn[lt].noConflict = function() {
				return e.fn[lt] = t, yt.jQueryInterface
			}
		}
	}));
	var bt = {
			backdrop: !0,
			keyboard: !0,
			focus: !0
		},
		wt = {
			backdrop: "(boolean|string)",
			keyboard: "boolean",
			focus: "boolean"
		},
		xt = function(e) {
			function r(t, i) {
				var n;
				return (n = e.call(this, t) || this)._config = n._getConfig(i), n._dialog = W.findOne(".modal-dialog", t), n._backdrop = null, n._isShown = !1, n._isBodyOverflowing = !1, n._ignoreBackdropClick = !1, n._isTransitioning = !1, n._scrollbarWidth = 0, n
			}
			n(r, e);
			var o = r.prototype;
			return o.toggle = function(e) {
				return this._isShown ? this.hide() : this.show(e)
			}, o.show = function(e) {
				var t = this;
				if (!this._isShown && !this._isTransitioning) {
					this._element.classList.contains("fade") && (this._isTransitioning = !0);
					var i = N.trigger(this._element, "show.bs.modal", {
						relatedTarget: e
					});
					this._isShown || i.defaultPrevented || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), N.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', (function(e) {
						return t.hide(e)
					})), N.on(this._dialog, "mousedown.dismiss.bs.modal", (function() {
						N.one(t._element, "mouseup.dismiss.bs.modal", (function(e) {
							e.target === t._element && (t._ignoreBackdropClick = !0)
						}))
					})), this._showBackdrop((function() {
						return t._showElement(e)
					})))
				}
			}, o.hide = function(e) {
				var t = this;
				if (e && e.preventDefault(), this._isShown && !this._isTransitioning && !N.trigger(this._element, "hide.bs.modal").defaultPrevented) {
					this._isShown = !1;
					var i = this._element.classList.contains("fade");
					if (i && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), N.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), N.off(this._element, "click.dismiss.bs.modal"), N.off(this._dialog, "mousedown.dismiss.bs.modal"), i) {
						var n = h(this._element);
						N.one(this._element, "transitionend", (function(e) {
							return t._hideModal(e)
						})), p(this._element, n)
					} else this._hideModal()
				}
			}, o.dispose = function() {
				[window, this._element, this._dialog].forEach((function(e) {
					return N.off(e, ".bs.modal")
				})), e.prototype.dispose.call(this), N.off(document, "focusin.bs.modal"), this._config = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
			}, o.handleUpdate = function() {
				this._adjustDialog()
			}, o._getConfig = function(e) {
				return e = i({}, bt, e), f("modal", e, wt), e
			}, o._showElement = function(e) {
				var t = this,
					i = this._element.classList.contains("fade"),
					n = W.findOne(".modal-body", this._dialog);
				this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, n && (n.scrollTop = 0), i && v(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus();
				var r = function() {
					t._config.focus && t._element.focus(), t._isTransitioning = !1, N.trigger(t._element, "shown.bs.modal", {
						relatedTarget: e
					})
				};
				if (i) {
					var o = h(this._dialog);
					N.one(this._dialog, "transitionend", r), p(this._dialog, o)
				} else r()
			}, o._enforceFocus = function() {
				var e = this;
				N.off(document, "focusin.bs.modal"), N.on(document, "focusin.bs.modal", (function(t) {
					document === t.target || e._element === t.target || e._element.contains(t.target) || e._element.focus()
				}))
			}, o._setEscapeEvent = function() {
				var e = this;
				this._isShown ? N.on(this._element, "keydown.dismiss.bs.modal", (function(t) {
					e._config.keyboard && "Escape" === t.key ? (t.preventDefault(), e.hide()) : e._config.keyboard || "Escape" !== t.key || e._triggerBackdropTransition()
				})) : N.off(this._element, "keydown.dismiss.bs.modal")
			}, o._setResizeEvent = function() {
				var e = this;
				this._isShown ? N.on(window, "resize.bs.modal", (function() {
					return e._adjustDialog()
				})) : N.off(window, "resize.bs.modal")
			}, o._hideModal = function() {
				var e = this;
				this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop((function() {
					document.body.classList.remove("modal-open"), e._resetAdjustments(), e._resetScrollbar(), N.trigger(e._element, "hidden.bs.modal")
				}))
			}, o._removeBackdrop = function() {
				this._backdrop.parentNode.removeChild(this._backdrop), this._backdrop = null
			}, o._showBackdrop = function(e) {
				var t = this,
					i = this._element.classList.contains("fade") ? "fade" : "";
				if (this._isShown && this._config.backdrop) {
					if (this._backdrop = document.createElement("div"), this._backdrop.className = "modal-backdrop", i && this._backdrop.classList.add(i), document.body.appendChild(this._backdrop), N.on(this._element, "click.dismiss.bs.modal", (function(e) {
							t._ignoreBackdropClick ? t._ignoreBackdropClick = !1 : e.target === e.currentTarget && ("static" === t._config.backdrop ? t._triggerBackdropTransition() : t.hide())
						})), i && v(this._backdrop), this._backdrop.classList.add("show"), !i) return void e();
					var n = h(this._backdrop);
					N.one(this._backdrop, "transitionend", e), p(this._backdrop, n)
				} else if (!this._isShown && this._backdrop) {
					this._backdrop.classList.remove("show");
					var r = function() {
						t._removeBackdrop(), e()
					};
					if (this._element.classList.contains("fade")) {
						var o = h(this._backdrop);
						N.one(this._backdrop, "transitionend", r), p(this._backdrop, o)
					} else r()
				} else e()
			}, o._triggerBackdropTransition = function() {
				var e = this;
				if (!N.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
					var t = this._element.scrollHeight > document.documentElement.clientHeight;
					t || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static");
					var i = h(this._dialog);
					N.off(this._element, "transitionend"), N.one(this._element, "transitionend", (function() {
						e._element.classList.remove("modal-static"), t || (N.one(e._element, "transitionend", (function() {
							e._element.style.overflowY = ""
						})), p(e._element, i))
					})), p(this._element, i), this._element.focus()
				}
			}, o._adjustDialog = function() {
				var e = this._element.scrollHeight > document.documentElement.clientHeight;
				(!this._isBodyOverflowing && e && !w || this._isBodyOverflowing && !e && w) && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), (this._isBodyOverflowing && !e && !w || !this._isBodyOverflowing && e && w) && (this._element.style.paddingRight = this._scrollbarWidth + "px")
			}, o._resetAdjustments = function() {
				this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
			}, o._checkScrollbar = function() {
				var e = document.body.getBoundingClientRect();
				this._isBodyOverflowing = Math.round(e.left + e.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
			}, o._setScrollbar = function() {
				var e = this;
				if (this._isBodyOverflowing) {
					W.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(t) {
						var i = t.style.paddingRight,
							n = window.getComputedStyle(t)["padding-right"];
						V.setDataAttribute(t, "padding-right", i), t.style.paddingRight = Number.parseFloat(n) + e._scrollbarWidth + "px"
					})), W.find(".sticky-top").forEach((function(t) {
						var i = t.style.marginRight,
							n = window.getComputedStyle(t)["margin-right"];
						V.setDataAttribute(t, "margin-right", i), t.style.marginRight = Number.parseFloat(n) - e._scrollbarWidth + "px"
					}));
					var t = document.body.style.paddingRight,
						i = window.getComputedStyle(document.body)["padding-right"];
					V.setDataAttribute(document.body, "padding-right", t), document.body.style.paddingRight = Number.parseFloat(i) + this._scrollbarWidth + "px"
				}
				document.body.classList.add("modal-open")
			}, o._resetScrollbar = function() {
				W.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(e) {
					var t = V.getDataAttribute(e, "padding-right");
					void 0 !== t && (V.removeDataAttribute(e, "padding-right"), e.style.paddingRight = t)
				})), W.find(".sticky-top").forEach((function(e) {
					var t = V.getDataAttribute(e, "margin-right");
					void 0 !== t && (V.removeDataAttribute(e, "margin-right"), e.style.marginRight = t)
				}));
				var e = V.getDataAttribute(document.body, "padding-right");
				void 0 === e ? document.body.style.paddingRight = "" : (V.removeDataAttribute(document.body, "padding-right"), document.body.style.paddingRight = e)
			}, o._getScrollbarWidth = function() {
				var e = document.createElement("div");
				e.className = "modal-scrollbar-measure", document.body.appendChild(e);
				var t = e.getBoundingClientRect().width - e.clientWidth;
				return document.body.removeChild(e), t
			}, r.jQueryInterface = function(e, t) {
				return this.each((function() {
					var n = E(this, "bs.modal"),
						o = i({}, bt, V.getDataAttributes(this), "object" == typeof e && e ? e : {});
					if (n || (n = new r(this, o)), "string" == typeof e) {
						if (void 0 === n[e]) throw new TypeError('No method named "' + e + '"');
						n[e](t)
					}
				}))
			}, t(r, null, [{
				key: "Default",
				get: function() {
					return bt
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.modal"
				}
			}]), r
		}(B);
	N.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function(e) {
		var t = this,
			n = c(this);
		"A" !== this.tagName && "AREA" !== this.tagName || e.preventDefault(), N.one(n, "show.bs.modal", (function(e) {
			e.defaultPrevented || N.one(n, "hidden.bs.modal", (function() {
				m(t) && t.focus()
			}))
		}));
		var r = E(n, "bs.modal");
		if (!r) {
			var o = i({}, V.getDataAttributes(n), V.getDataAttributes(this));
			r = new xt(n, o)
		}
		r.show(this)
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn.modal;
			e.fn.modal = xt.jQueryInterface, e.fn.modal.Constructor = xt, e.fn.modal.noConflict = function() {
				return e.fn.modal = t, xt.jQueryInterface
			}
		}
	}));
	var _t = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
		Et = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
		Mt = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

	function St(e, t, i) {
		var n;
		if (!e.length) return e;
		if (i && "function" == typeof i) return i(e);
		for (var r = (new window.DOMParser).parseFromString(e, "text/html"), o = Object.keys(t), s = (n = []).concat.apply(n, r.body.querySelectorAll("*")), a = function(e, i) {
				var n, r = s[e],
					a = r.nodeName.toLowerCase();
				if (!o.includes(a)) return r.parentNode.removeChild(r), "continue";
				var l = (n = []).concat.apply(n, r.attributes),
					c = [].concat(t["*"] || [], t[a] || []);
				l.forEach((function(e) {
					(function(e, t) {
						var i = e.nodeName.toLowerCase();
						if (t.includes(i)) return !_t.has(i) || Boolean(e.nodeValue.match(Et) || e.nodeValue.match(Mt));
						for (var n = t.filter((function(e) {
								return e instanceof RegExp
							})), r = 0, o = n.length; r < o; r++)
							if (i.match(n[r])) return !0;
						return !1
					})(e, c) || r.removeAttribute(e.nodeName)
				}))
			}, l = 0, c = s.length; l < c; l++) a(l);
		return r.body.innerHTML
	}
	var Tt = "tooltip",
		At = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
		Lt = new Set(["sanitize", "allowList", "sanitizeFn"]),
		Ct = {
			animation: "boolean",
			template: "string",
			title: "(string|element|function)",
			trigger: "string",
			delay: "(number|object)",
			html: "boolean",
			selector: "(string|boolean)",
			placement: "(string|function)",
			container: "(string|element|boolean)",
			fallbackPlacements: "(null|array)",
			boundary: "(string|element)",
			customClass: "(string|function)",
			sanitize: "boolean",
			sanitizeFn: "(null|function)",
			allowList: "object",
			popperConfig: "(null|object)"
		},
		Pt = {
			AUTO: "auto",
			TOP: "top",
			RIGHT: w ? "left" : "right",
			BOTTOM: "bottom",
			LEFT: w ? "right" : "left"
		},
		It = {
			animation: !0,
			template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
			trigger: "hover focus",
			title: "",
			delay: 0,
			html: !1,
			selector: !1,
			placement: "top",
			container: !1,
			fallbackPlacements: null,
			boundary: "clippingParents",
			customClass: "",
			sanitize: !0,
			sanitizeFn: null,
			allowList: {
				"*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
				a: ["target", "href", "title", "rel"],
				area: [],
				b: [],
				br: [],
				col: [],
				code: [],
				div: [],
				em: [],
				hr: [],
				h1: [],
				h2: [],
				h3: [],
				h4: [],
				h5: [],
				h6: [],
				i: [],
				img: ["src", "srcset", "alt", "title", "width", "height"],
				li: [],
				ol: [],
				p: [],
				pre: [],
				s: [],
				small: [],
				span: [],
				sub: [],
				sup: [],
				strong: [],
				u: [],
				ul: []
			},
			popperConfig: null
		},
		Rt = {
			HIDE: "hide.bs.tooltip",
			HIDDEN: "hidden.bs.tooltip",
			SHOW: "show.bs.tooltip",
			SHOWN: "shown.bs.tooltip",
			INSERTED: "inserted.bs.tooltip",
			CLICK: "click.bs.tooltip",
			FOCUSIN: "focusin.bs.tooltip",
			FOCUSOUT: "focusout.bs.tooltip",
			MOUSEENTER: "mouseenter.bs.tooltip",
			MOUSELEAVE: "mouseleave.bs.tooltip"
		},
		Ot = function(e) {
			function r(t, i) {
				var n;
				if (void 0 === at) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
				return (n = e.call(this, t) || this)._isEnabled = !0, n._timeout = 0, n._hoverState = "", n._activeTrigger = {}, n._popper = null, n.config = n._getConfig(i), n.tip = null, n._setListeners(), n
			}
			n(r, e);
			var o = r.prototype;
			return o.enable = function() {
				this._isEnabled = !0
			}, o.disable = function() {
				this._isEnabled = !1
			}, o.toggleEnabled = function() {
				this._isEnabled = !this._isEnabled
			}, o.toggle = function(e) {
				if (this._isEnabled)
					if (e) {
						var t = this.constructor.DATA_KEY,
							i = E(e.delegateTarget, t);
						i || (i = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, t, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i)
					} else {
						if (this.getTipElement().classList.contains("show")) return void this._leave(null, this);
						this._enter(null, this)
					}
			}, o.dispose = function() {
				clearTimeout(this._timeout), N.off(this._element, this.constructor.EVENT_KEY), N.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.parentNode.removeChild(this.tip), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.config = null, this.tip = null, e.prototype.dispose.call(this)
			}, o.show = function() {
				var e = this;
				if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
				if (this.isWithContent() && this._isEnabled) {
					var t = N.trigger(this._element, this.constructor.Event.SHOW),
						i = function e(t) {
							if (!document.documentElement.attachShadow) return null;
							if ("function" == typeof t.getRootNode) {
								var i = t.getRootNode();
								return i instanceof ShadowRoot ? i : null
							}
							return t instanceof ShadowRoot ? t : t.parentNode ? e(t.parentNode) : null
						}(this._element),
						n = null === i ? this._element.ownerDocument.documentElement.contains(this._element) : i.contains(this._element);
					if (t.defaultPrevented || !n) return;
					var r = this.getTipElement(),
						o = s(this.constructor.NAME);
					r.setAttribute("id", o), this._element.setAttribute("aria-describedby", o), this.setContent(), this.config.animation && r.classList.add("fade");
					var a = "function" == typeof this.config.placement ? this.config.placement.call(this, r, this._element) : this.config.placement,
						l = this._getAttachment(a);
					this._addAttachmentClass(l);
					var c = this._getContainer();
					_(r, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || c.appendChild(r), N.trigger(this._element, this.constructor.Event.INSERTED), this._popper = st(this._element, r, this._getPopperConfig(l)), r.classList.add("show");
					var u, d, f = "function" == typeof this.config.customClass ? this.config.customClass() : this.config.customClass;
					f && (u = r.classList).add.apply(u, f.split(" ")), "ontouchstart" in document.documentElement && (d = []).concat.apply(d, document.body.children).forEach((function(e) {
						N.on(e, "mouseover", (function() {}))
					}));
					var m = function() {
						var t = e._hoverState;
						e._hoverState = null, N.trigger(e._element, e.constructor.Event.SHOWN), "out" === t && e._leave(null, e)
					};
					if (this.tip.classList.contains("fade")) {
						var g = h(this.tip);
						N.one(this.tip, "transitionend", m), p(this.tip, g)
					} else m()
				}
			}, o.hide = function() {
				var e = this;
				if (this._popper) {
					var t = this.getTipElement(),
						i = function() {
							"show" !== e._hoverState && t.parentNode && t.parentNode.removeChild(t), e._cleanTipClass(), e._element.removeAttribute("aria-describedby"), N.trigger(e._element, e.constructor.Event.HIDDEN), e._popper && (e._popper.destroy(), e._popper = null)
						};
					if (!N.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) {
						var n;
						if (t.classList.remove("show"), "ontouchstart" in document.documentElement && (n = []).concat.apply(n, document.body.children).forEach((function(e) {
								return N.off(e, "mouseover", g)
							})), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this.tip.classList.contains("fade")) {
							var r = h(t);
							N.one(t, "transitionend", i), p(t, r)
						} else i();
						this._hoverState = ""
					}
				}
			}, o.update = function() {
				null !== this._popper && this._popper.update()
			}, o.isWithContent = function() {
				return Boolean(this.getTitle())
			}, o.getTipElement = function() {
				if (this.tip) return this.tip;
				var e = document.createElement("div");
				return e.innerHTML = this.config.template, this.tip = e.children[0], this.tip
			}, o.setContent = function() {
				var e = this.getTipElement();
				this.setElementContent(W.findOne(".tooltip-inner", e), this.getTitle()), e.classList.remove("fade", "show")
			}, o.setElementContent = function(e, t) {
				if (null !== e) return "object" == typeof t && d(t) ? (t.jquery && (t = t[0]), void(this.config.html ? t.parentNode !== e && (e.innerHTML = "", e.appendChild(t)) : e.textContent = t.textContent)) : void(this.config.html ? (this.config.sanitize && (t = St(t, this.config.allowList, this.config.sanitizeFn)), e.innerHTML = t) : e.textContent = t)
			}, o.getTitle = function() {
				var e = this._element.getAttribute("data-bs-original-title");
				return e || (e = "function" == typeof this.config.title ? this.config.title.call(this._element) : this.config.title), e
			}, o.updateAttachment = function(e) {
				return "right" === e ? "end" : "left" === e ? "start" : e
			}, o._getPopperConfig = function(e) {
				var t = this,
					n = {
						name: "flip",
						options: {
							altBoundary: !0
						}
					};
				return this.config.fallbackPlacements && (n.options.fallbackPlacements = this.config.fallbackPlacements), i({}, {
					placement: e,
					modifiers: [n, {
						name: "preventOverflow",
						options: {
							rootBoundary: this.config.boundary
						}
					}, {
						name: "arrow",
						options: {
							element: "." + this.constructor.NAME + "-arrow"
						}
					}, {
						name: "onChange",
						enabled: !0,
						phase: "afterWrite",
						fn: function(e) {
							return t._handlePopperPlacementChange(e)
						}
					}],
					onFirstUpdate: function(e) {
						e.options.placement !== e.placement && t._handlePopperPlacementChange(e)
					}
				}, this.config.popperConfig)
			}, o._addAttachmentClass = function(e) {
				this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(e))
			}, o._getContainer = function() {
				return !1 === this.config.container ? document.body : d(this.config.container) ? this.config.container : W.findOne(this.config.container)
			}, o._getAttachment = function(e) {
				return Pt[e.toUpperCase()]
			}, o._setListeners = function() {
				var e = this;
				this.config.trigger.split(" ").forEach((function(t) {
					if ("click" === t) N.on(e._element, e.constructor.Event.CLICK, e.config.selector, (function(t) {
						return e.toggle(t)
					}));
					else if ("manual" !== t) {
						var i = "hover" === t ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN,
							n = "hover" === t ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT;
						N.on(e._element, i, e.config.selector, (function(t) {
							return e._enter(t)
						})), N.on(e._element, n, e.config.selector, (function(t) {
							return e._leave(t)
						}))
					}
				})), this._hideModalHandler = function() {
					e._element && e.hide()
				}, N.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = i({}, this.config, {
					trigger: "manual",
					selector: ""
				}) : this._fixTitle()
			}, o._fixTitle = function() {
				var e = this._element.getAttribute("title"),
					t = typeof this._element.getAttribute("data-bs-original-title");
				(e || "string" !== t) && (this._element.setAttribute("data-bs-original-title", e || ""), !e || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", e), this._element.setAttribute("title", ""))
			}, o._enter = function(e, t) {
				var i = this.constructor.DATA_KEY;
				(t = t || E(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusin" === e.type ? "focus" : "hover"] = !0), t.getTipElement().classList.contains("show") || "show" === t._hoverState ? t._hoverState = "show" : (clearTimeout(t._timeout), t._hoverState = "show", t.config.delay && t.config.delay.show ? t._timeout = setTimeout((function() {
					"show" === t._hoverState && t.show()
				}), t.config.delay.show) : t.show())
			}, o._leave = function(e, t) {
				var i = this.constructor.DATA_KEY;
				(t = t || E(e.delegateTarget, i)) || (t = new this.constructor(e.delegateTarget, this._getDelegateConfig()), _(e.delegateTarget, i, t)), e && (t._activeTrigger["focusout" === e.type ? "focus" : "hover"] = !1), t._isWithActiveTrigger() || (clearTimeout(t._timeout), t._hoverState = "out", t.config.delay && t.config.delay.hide ? t._timeout = setTimeout((function() {
					"out" === t._hoverState && t.hide()
				}), t.config.delay.hide) : t.hide())
			}, o._isWithActiveTrigger = function() {
				for (var e in this._activeTrigger)
					if (this._activeTrigger[e]) return !0;
				return !1
			}, o._getConfig = function(e) {
				var t = V.getDataAttributes(this._element);
				return Object.keys(t).forEach((function(e) {
					Lt.has(e) && delete t[e]
				})), e && "object" == typeof e.container && e.container.jquery && (e.container = e.container[0]), "number" == typeof(e = i({}, this.constructor.Default, t, "object" == typeof e && e ? e : {})).delay && (e.delay = {
					show: e.delay,
					hide: e.delay
				}), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), f(Tt, e, this.constructor.DefaultType), e.sanitize && (e.template = St(e.template, e.allowList, e.sanitizeFn)), e
			}, o._getDelegateConfig = function() {
				var e = {};
				if (this.config)
					for (var t in this.config) this.constructor.Default[t] !== this.config[t] && (e[t] = this.config[t]);
				return e
			}, o._cleanTipClass = function() {
				var e = this.getTipElement(),
					t = e.getAttribute("class").match(At);
				null !== t && t.length > 0 && t.map((function(e) {
					return e.trim()
				})).forEach((function(t) {
					return e.classList.remove(t)
				}))
			}, o._handlePopperPlacementChange = function(e) {
				var t = e.state;
				t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement)))
			}, r.jQueryInterface = function(e) {
				return this.each((function() {
					var t = E(this, "bs.tooltip"),
						i = "object" == typeof e && e;
					if ((t || !/dispose|hide/.test(e)) && (t || (t = new r(this, i)), "string" == typeof e)) {
						if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
						t[e]()
					}
				}))
			}, t(r, null, [{
				key: "Default",
				get: function() {
					return It
				}
			}, {
				key: "NAME",
				get: function() {
					return Tt
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.tooltip"
				}
			}, {
				key: "Event",
				get: function() {
					return Rt
				}
			}, {
				key: "EVENT_KEY",
				get: function() {
					return ".bs.tooltip"
				}
			}, {
				key: "DefaultType",
				get: function() {
					return Ct
				}
			}]), r
		}(B);
	b((function() {
		var e = y();
		if (e) {
			var t = e.fn[Tt];
			e.fn[Tt] = Ot.jQueryInterface, e.fn[Tt].Constructor = Ot, e.fn[Tt].noConflict = function() {
				return e.fn[Tt] = t, Ot.jQueryInterface
			}
		}
	}));
	var Dt = "popover",
		zt = new RegExp("(^|\\s)bs-popover\\S+", "g"),
		kt = i({}, Ot.Default, {
			placement: "right",
			trigger: "click",
			content: "",
			template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
		}),
		Nt = i({}, Ot.DefaultType, {
			content: "(string|element|function)"
		}),
		Bt = {
			HIDE: "hide.bs.popover",
			HIDDEN: "hidden.bs.popover",
			SHOW: "show.bs.popover",
			SHOWN: "shown.bs.popover",
			INSERTED: "inserted.bs.popover",
			CLICK: "click.bs.popover",
			FOCUSIN: "focusin.bs.popover",
			FOCUSOUT: "focusout.bs.popover",
			MOUSEENTER: "mouseenter.bs.popover",
			MOUSELEAVE: "mouseleave.bs.popover"
		},
		Ht = function(e) {
			function i() {
				return e.apply(this, arguments) || this
			}
			n(i, e);
			var r = i.prototype;
			return r.isWithContent = function() {
				return this.getTitle() || this._getContent()
			}, r.setContent = function() {
				var e = this.getTipElement();
				this.setElementContent(W.findOne(".popover-header", e), this.getTitle());
				var t = this._getContent();
				"function" == typeof t && (t = t.call(this._element)), this.setElementContent(W.findOne(".popover-body", e), t), e.classList.remove("fade", "show")
			}, r._addAttachmentClass = function(e) {
				this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(e))
			}, r._getContent = function() {
				return this._element.getAttribute("data-bs-content") || this.config.content
			}, r._cleanTipClass = function() {
				var e = this.getTipElement(),
					t = e.getAttribute("class").match(zt);
				null !== t && t.length > 0 && t.map((function(e) {
					return e.trim()
				})).forEach((function(t) {
					return e.classList.remove(t)
				}))
			}, i.jQueryInterface = function(e) {
				return this.each((function() {
					var t = E(this, "bs.popover"),
						n = "object" == typeof e ? e : null;
					if ((t || !/dispose|hide/.test(e)) && (t || (t = new i(this, n), _(this, "bs.popover", t)), "string" == typeof e)) {
						if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
						t[e]()
					}
				}))
			}, t(i, null, [{
				key: "Default",
				get: function() {
					return kt
				}
			}, {
				key: "NAME",
				get: function() {
					return Dt
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.popover"
				}
			}, {
				key: "Event",
				get: function() {
					return Bt
				}
			}, {
				key: "EVENT_KEY",
				get: function() {
					return ".bs.popover"
				}
			}, {
				key: "DefaultType",
				get: function() {
					return Nt
				}
			}]), i
		}(Ot);
	b((function() {
		var e = y();
		if (e) {
			var t = e.fn[Dt];
			e.fn[Dt] = Ht.jQueryInterface, e.fn[Dt].Constructor = Ht, e.fn[Dt].noConflict = function() {
				return e.fn[Dt] = t, Ht.jQueryInterface
			}
		}
	}));
	var Ft = "scrollspy",
		Ut = {
			offset: 10,
			method: "auto",
			target: ""
		},
		jt = {
			offset: "number",
			method: "string",
			target: "(string|element)"
		},
		Gt = function(e) {
			function r(t, i) {
				var n;
				return (n = e.call(this, t) || this)._scrollElement = "BODY" === t.tagName ? window : t, n._config = n._getConfig(i), n._selector = n._config.target + " .nav-link, " + n._config.target + " .list-group-item, " + n._config.target + " .dropdown-item", n._offsets = [], n._targets = [], n._activeTarget = null, n._scrollHeight = 0, N.on(n._scrollElement, "scroll.bs.scrollspy", (function(e) {
					return n._process(e)
				})), n.refresh(), n._process(), n
			}
			n(r, e);
			var o = r.prototype;
			return o.refresh = function() {
				var e = this,
					t = this._scrollElement === this._scrollElement.window ? "offset" : "position",
					i = "auto" === this._config.method ? t : this._config.method,
					n = "position" === i ? this._getScrollTop() : 0;
				this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), W.find(this._selector).map((function(e) {
					var t = l(e),
						r = t ? W.findOne(t) : null;
					if (r) {
						var o = r.getBoundingClientRect();
						if (o.width || o.height) return [V[i](r).top + n, t]
					}
					return null
				})).filter((function(e) {
					return e
				})).sort((function(e, t) {
					return e[0] - t[0]
				})).forEach((function(t) {
					e._offsets.push(t[0]), e._targets.push(t[1])
				}))
			}, o.dispose = function() {
				e.prototype.dispose.call(this), N.off(this._scrollElement, ".bs.scrollspy"), this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
			}, o._getConfig = function(e) {
				if ("string" != typeof(e = i({}, Ut, "object" == typeof e && e ? e : {})).target && d(e.target)) {
					var t = e.target.id;
					t || (t = s(Ft), e.target.id = t), e.target = "#" + t
				}
				return f(Ft, e, jt), e
			}, o._getScrollTop = function() {
				return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
			}, o._getScrollHeight = function() {
				return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
			}, o._getOffsetHeight = function() {
				return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
			}, o._process = function() {
				var e = this._getScrollTop() + this._config.offset,
					t = this._getScrollHeight(),
					i = this._config.offset + t - this._getOffsetHeight();
				if (this._scrollHeight !== t && this.refresh(), e >= i) {
					var n = this._targets[this._targets.length - 1];
					this._activeTarget !== n && this._activate(n)
				} else {
					if (this._activeTarget && e < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
					for (var r = this._offsets.length; r--;) this._activeTarget !== this._targets[r] && e >= this._offsets[r] && (void 0 === this._offsets[r + 1] || e < this._offsets[r + 1]) && this._activate(this._targets[r])
				}
			}, o._activate = function(e) {
				this._activeTarget = e, this._clear();
				var t = this._selector.split(",").map((function(t) {
						return t + '[data-bs-target="' + e + '"],' + t + '[href="' + e + '"]'
					})),
					i = W.findOne(t.join(","));
				i.classList.contains("dropdown-item") ? (W.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add("active"), i.classList.add("active")) : (i.classList.add("active"), W.parents(i, ".nav, .list-group").forEach((function(e) {
					W.prev(e, ".nav-link, .list-group-item").forEach((function(e) {
						return e.classList.add("active")
					})), W.prev(e, ".nav-item").forEach((function(e) {
						W.children(e, ".nav-link").forEach((function(e) {
							return e.classList.add("active")
						}))
					}))
				}))), N.trigger(this._scrollElement, "activate.bs.scrollspy", {
					relatedTarget: e
				})
			}, o._clear = function() {
				W.find(this._selector).filter((function(e) {
					return e.classList.contains("active")
				})).forEach((function(e) {
					return e.classList.remove("active")
				}))
			}, r.jQueryInterface = function(e) {
				return this.each((function() {
					var t = E(this, "bs.scrollspy");
					if (t || (t = new r(this, "object" == typeof e && e)), "string" == typeof e) {
						if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
						t[e]()
					}
				}))
			}, t(r, null, [{
				key: "Default",
				get: function() {
					return Ut
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.scrollspy"
				}
			}]), r
		}(B);
	N.on(window, "load.bs.scrollspy.data-api", (function() {
		W.find('[data-bs-spy="scroll"]').forEach((function(e) {
			return new Gt(e, V.getDataAttributes(e))
		}))
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn[Ft];
			e.fn[Ft] = Gt.jQueryInterface, e.fn[Ft].Constructor = Gt, e.fn[Ft].noConflict = function() {
				return e.fn[Ft] = t, Gt.jQueryInterface
			}
		}
	}));
	var Vt = function(e) {
		function i() {
			return e.apply(this, arguments) || this
		}
		n(i, e);
		var r = i.prototype;
		return r.show = function() {
			var e = this;
			if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains("active") || this._element.classList.contains("disabled"))) {
				var t, i = c(this._element),
					n = this._element.closest(".nav, .list-group");
				if (n) {
					var r = "UL" === n.nodeName || "OL" === n.nodeName ? ":scope > li > .active" : ".active";
					t = (t = W.find(r, n))[t.length - 1]
				}
				var o = null;
				if (t && (o = N.trigger(t, "hide.bs.tab", {
						relatedTarget: this._element
					})), !(N.trigger(this._element, "show.bs.tab", {
						relatedTarget: t
					}).defaultPrevented || null !== o && o.defaultPrevented)) {
					this._activate(this._element, n);
					var s = function() {
						N.trigger(t, "hidden.bs.tab", {
							relatedTarget: e._element
						}), N.trigger(e._element, "shown.bs.tab", {
							relatedTarget: t
						})
					};
					i ? this._activate(i, i.parentNode, s) : s()
				}
			}
		}, r._activate = function(e, t, i) {
			var n = this,
				r = (!t || "UL" !== t.nodeName && "OL" !== t.nodeName ? W.children(t, ".active") : W.find(":scope > li > .active", t))[0],
				o = i && r && r.classList.contains("fade"),
				s = function() {
					return n._transitionComplete(e, r, i)
				};
			if (r && o) {
				var a = h(r);
				r.classList.remove("show"), N.one(r, "transitionend", s), p(r, a)
			} else s()
		}, r._transitionComplete = function(e, t, i) {
			if (t) {
				t.classList.remove("active");
				var n = W.findOne(":scope > .dropdown-menu .active", t.parentNode);
				n && n.classList.remove("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !1)
			}
			e.classList.add("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !0), v(e), e.classList.contains("fade") && e.classList.add("show"), e.parentNode && e.parentNode.classList.contains("dropdown-menu") && (e.closest(".dropdown") && W.find(".dropdown-toggle").forEach((function(e) {
				return e.classList.add("active")
			})), e.setAttribute("aria-expanded", !0)), i && i()
		}, i.jQueryInterface = function(e) {
			return this.each((function() {
				var t = E(this, "bs.tab") || new i(this);
				if ("string" == typeof e) {
					if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
					t[e]()
				}
			}))
		}, t(i, null, [{
			key: "DATA_KEY",
			get: function() {
				return "bs.tab"
			}
		}]), i
	}(B);
	N.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', (function(e) {
		e.preventDefault(), (E(this, "bs.tab") || new Vt(this)).show()
	})), b((function() {
		var e = y();
		if (e) {
			var t = e.fn.tab;
			e.fn.tab = Vt.jQueryInterface, e.fn.tab.Constructor = Vt, e.fn.tab.noConflict = function() {
				return e.fn.tab = t, Vt.jQueryInterface
			}
		}
	}));
	var Wt = {
			animation: "boolean",
			autohide: "boolean",
			delay: "number"
		},
		qt = {
			animation: !0,
			autohide: !0,
			delay: 5e3
		},
		Xt = function(e) {
			function r(t, i) {
				var n;
				return (n = e.call(this, t) || this)._config = n._getConfig(i), n._timeout = null, n._setListeners(), n
			}
			n(r, e);
			var o = r.prototype;
			return o.show = function() {
				var e = this;
				if (!N.trigger(this._element, "show.bs.toast").defaultPrevented) {
					this._clearTimeout(), this._config.animation && this._element.classList.add("fade");
					var t = function() {
						e._element.classList.remove("showing"), e._element.classList.add("show"), N.trigger(e._element, "shown.bs.toast"), e._config.autohide && (e._timeout = setTimeout((function() {
							e.hide()
						}), e._config.delay))
					};
					if (this._element.classList.remove("hide"), v(this._element), this._element.classList.add("showing"), this._config.animation) {
						var i = h(this._element);
						N.one(this._element, "transitionend", t), p(this._element, i)
					} else t()
				}
			}, o.hide = function() {
				var e = this;
				if (this._element.classList.contains("show") && !N.trigger(this._element, "hide.bs.toast").defaultPrevented) {
					var t = function() {
						e._element.classList.add("hide"), N.trigger(e._element, "hidden.bs.toast")
					};
					if (this._element.classList.remove("show"), this._config.animation) {
						var i = h(this._element);
						N.one(this._element, "transitionend", t), p(this._element, i)
					} else t()
				}
			}, o.dispose = function() {
				this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), N.off(this._element, "click.dismiss.bs.toast"), e.prototype.dispose.call(this), this._config = null
			}, o._getConfig = function(e) {
				return e = i({}, qt, V.getDataAttributes(this._element), "object" == typeof e && e ? e : {}), f("toast", e, this.constructor.DefaultType), e
			}, o._setListeners = function() {
				var e = this;
				N.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', (function() {
					return e.hide()
				}))
			}, o._clearTimeout = function() {
				clearTimeout(this._timeout), this._timeout = null
			}, r.jQueryInterface = function(e) {
				return this.each((function() {
					var t = E(this, "bs.toast");
					if (t || (t = new r(this, "object" == typeof e && e)), "string" == typeof e) {
						if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
						t[e](this)
					}
				}))
			}, t(r, null, [{
				key: "DefaultType",
				get: function() {
					return Wt
				}
			}, {
				key: "Default",
				get: function() {
					return qt
				}
			}, {
				key: "DATA_KEY",
				get: function() {
					return "bs.toast"
				}
			}]), r
		}(B);
	return b((function() {
		var e = y();
		if (e) {
			var t = e.fn.toast;
			e.fn.toast = Xt.jQueryInterface, e.fn.toast.Constructor = Xt, e.fn.toast.noConflict = function() {
				return e.fn.toast = t, Xt.jQueryInterface
			}
		}
	})), {
		Alert: F,
		Button: U,
		Carousel: Q,
		Collapse: ee,
		Dropdown: yt,
		Modal: xt,
		Popover: Ht,
		ScrollSpy: Gt,
		Tab: Vt,
		Toast: Xt,
		Tooltip: Ot
	}
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
}("undefined" != typeof window ? window : this, (function() {
	function e() {}
	var t = e.prototype;
	return t.on = function(e, t) {
		if (e && t) {
			var i = this._events = this._events || {},
				n = i[e] = i[e] || [];
			return -1 == n.indexOf(t) && n.push(t), this
		}
	}, t.once = function(e, t) {
		if (e && t) {
			this.on(e, t);
			var i = this._onceEvents = this._onceEvents || {};
			return (i[e] = i[e] || {})[t] = !0, this
		}
	}, t.off = function(e, t) {
		var i = this._events && this._events[e];
		if (i && i.length) {
			var n = i.indexOf(t);
			return -1 != n && i.splice(n, 1), this
		}
	}, t.emitEvent = function(e, t) {
		var i = this._events && this._events[e];
		if (i && i.length) {
			i = i.slice(0), t = t || [];
			for (var n = this._onceEvents && this._onceEvents[e], r = 0; r < i.length; r++) {
				var o = i[r];
				n && n[o] && (this.off(e, o), delete n[o]), o.apply(this, t)
			}
			return this
		}
	}, t.allOff = function() {
		delete this._events, delete this._onceEvents
	}, e
})),
function(e, t) {
	"use strict";
	"function" == typeof define && define.amd ? define(["ev-emitter/ev-emitter"], (function(i) {
		return t(e, i)
	})) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter")) : e.imagesLoaded = t(e, e.EvEmitter)
}("undefined" != typeof window ? window : this, (function(e, t) {
	function i(e, t) {
		for (var i in t) e[i] = t[i];
		return e
	}

	function n(e, t, r) {
		if (!(this instanceof n)) return new n(e, t, r);
		var o, c = e;
		return "string" == typeof e && (c = document.querySelectorAll(e)), c ? (this.elements = (o = c, Array.isArray(o) ? o : "object" == typeof o && "number" == typeof o.length ? l.call(o) : [o]), this.options = i({}, this.options), "function" == typeof t ? r = t : i(this.options, t), r && this.on("always", r), this.getImages(), s && (this.jqDeferred = new s.Deferred), void setTimeout(this.check.bind(this))) : void a.error("Bad element for imagesLoaded " + (c || e))
	}

	function r(e) {
		this.img = e
	}

	function o(e, t) {
		this.url = e, this.element = t, this.img = new Image
	}
	var s = e.jQuery,
		a = e.console,
		l = Array.prototype.slice;
	(n.prototype = Object.create(t.prototype)).options = {}, n.prototype.getImages = function() {
		this.images = [], this.elements.forEach(this.addElementImages, this)
	}, n.prototype.addElementImages = function(e) {
		"IMG" == e.nodeName && this.addImage(e), !0 === this.options.background && this.addElementBackgroundImages(e);
		var t = e.nodeType;
		if (t && c[t]) {
			for (var i = e.querySelectorAll("img"), n = 0; n < i.length; n++) {
				var r = i[n];
				this.addImage(r)
			}
			if ("string" == typeof this.options.background) {
				var o = e.querySelectorAll(this.options.background);
				for (n = 0; n < o.length; n++) {
					var s = o[n];
					this.addElementBackgroundImages(s)
				}
			}
		}
	};
	var c = {
		1: !0,
		9: !0,
		11: !0
	};
	return n.prototype.addElementBackgroundImages = function(e) {
		var t = getComputedStyle(e);
		if (t)
			for (var i = /url\((['"])?(.*?)\1\)/gi, n = i.exec(t.backgroundImage); null !== n;) {
				var r = n && n[2];
				r && this.addBackground(r, e), n = i.exec(t.backgroundImage)
			}
	}, n.prototype.addImage = function(e) {
		var t = new r(e);
		this.images.push(t)
	}, n.prototype.addBackground = function(e, t) {
		var i = new o(e, t);
		this.images.push(i)
	}, n.prototype.check = function() {
		function e(e, i, n) {
			setTimeout((function() {
				t.progress(e, i, n)
			}))
		}
		var t = this;
		return this.progressedCount = 0, this.hasAnyBroken = !1, this.images.length ? void this.images.forEach((function(t) {
			t.once("progress", e), t.check()
		})) : void this.complete()
	}, n.prototype.progress = function(e, t, i) {
		this.progressedCount++, this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded, this.emitEvent("progress", [this, e, t]), this.jqDeferred && this.jqDeferred.notify && this.jqDeferred.notify(this, e), this.progressedCount == this.images.length && this.complete(), this.options.debug && a && a.log("progress: " + i, e, t)
	}, n.prototype.complete = function() {
		var e = this.hasAnyBroken ? "fail" : "done";
		if (this.isComplete = !0, this.emitEvent(e, [this]), this.emitEvent("always", [this]), this.jqDeferred) {
			var t = this.hasAnyBroken ? "reject" : "resolve";
			this.jqDeferred[t](this)
		}
	}, (r.prototype = Object.create(t.prototype)).check = function() {
		return this.getIsImageComplete() ? void this.confirm(0 !== this.img.naturalWidth, "naturalWidth") : (this.proxyImage = new Image, this.proxyImage.addEventListener("load", this), this.proxyImage.addEventListener("error", this), this.img.addEventListener("load", this), this.img.addEventListener("error", this), void(this.proxyImage.src = this.img.src))
	}, r.prototype.getIsImageComplete = function() {
		return this.img.complete && this.img.naturalWidth
	}, r.prototype.confirm = function(e, t) {
		this.isLoaded = e, this.emitEvent("progress", [this, this.img, t])
	}, r.prototype.handleEvent = function(e) {
		var t = "on" + e.type;
		this[t] && this[t](e)
	}, r.prototype.onload = function() {
		this.confirm(!0, "onload"), this.unbindEvents()
	}, r.prototype.onerror = function() {
		this.confirm(!1, "onerror"), this.unbindEvents()
	}, r.prototype.unbindEvents = function() {
		this.proxyImage.removeEventListener("load", this), this.proxyImage.removeEventListener("error", this), this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
	}, (o.prototype = Object.create(r.prototype)).check = function() {
		this.img.addEventListener("load", this), this.img.addEventListener("error", this), this.img.src = this.url, this.getIsImageComplete() && (this.confirm(0 !== this.img.naturalWidth, "naturalWidth"), this.unbindEvents())
	}, o.prototype.unbindEvents = function() {
		this.img.removeEventListener("load", this), this.img.removeEventListener("error", this)
	}, o.prototype.confirm = function(e, t) {
		this.isLoaded = e, this.emitEvent("progress", [this, this.element, t])
	}, n.makeJQueryPlugin = function(t) {
		(t = t || e.jQuery) && ((s = t).fn.imagesLoaded = function(e, t) {
			return new n(this, e, t).jqDeferred.promise(s(this))
		})
	}, n.makeJQueryPlugin(), n
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("jquery-bridget/jquery-bridget", ["jquery"], (function(i) {
		return t(e, i)
	})) : "object" == typeof module && module.exports ? module.exports = t(e, require("jquery")) : e.jQueryBridget = t(e, e.jQuery)
}(window, (function(e, t) {
	"use strict";

	function i(i, o, a) {
		(a = a || t || e.jQuery) && (o.prototype.option || (o.prototype.option = function(e) {
			a.isPlainObject(e) && (this.options = a.extend(!0, this.options, e))
		}), a.fn[i] = function(e) {
			if ("string" != typeof e) return u = e, this.each((function(e, t) {
				var n = a.data(t, i);
				n ? (n.option(u), n._init()) : (n = new o(t, u), a.data(t, i, n))
			})), this;
			var t, n, l, c, h, u, d = r.call(arguments, 1);
			return l = d, h = "$()." + i + '("' + (n = e) + '")', (t = this).each((function(e, t) {
				var r = a.data(t, i);
				if (r) {
					var o = r[n];
					if (o && "_" != n.charAt(0)) {
						var u = o.apply(r, l);
						c = void 0 === c ? u : c
					} else s(h + " is not a valid method")
				} else s(i + " not initialized. Cannot call methods, i.e. " + h)
			})), void 0 !== c ? c : t
		}, n(a))
	}

	function n(e) {
		!e || e && e.bridget || (e.bridget = i)
	}
	var r = Array.prototype.slice,
		o = e.console,
		s = void 0 === o ? function() {} : function(e) {
			o.error(e)
		};
	return n(t || e.jQuery), i
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("ev-emitter/ev-emitter", t) : "object" == typeof module && module.exports ? module.exports = t() : e.EvEmitter = t()
}("undefined" != typeof window ? window : this, (function() {
	function e() {}
	var t = e.prototype;
	return t.on = function(e, t) {
		if (e && t) {
			var i = this._events = this._events || {},
				n = i[e] = i[e] || [];
			return -1 == n.indexOf(t) && n.push(t), this
		}
	}, t.once = function(e, t) {
		if (e && t) {
			this.on(e, t);
			var i = this._onceEvents = this._onceEvents || {};
			return (i[e] = i[e] || {})[t] = !0, this
		}
	}, t.off = function(e, t) {
		var i = this._events && this._events[e];
		if (i && i.length) {
			var n = i.indexOf(t);
			return -1 != n && i.splice(n, 1), this
		}
	}, t.emitEvent = function(e, t) {
		var i = this._events && this._events[e];
		if (i && i.length) {
			i = i.slice(0), t = t || [];
			for (var n = this._onceEvents && this._onceEvents[e], r = 0; r < i.length; r++) {
				var o = i[r];
				n && n[o] && (this.off(e, o), delete n[o]), o.apply(this, t)
			}
			return this
		}
	}, t.allOff = function() {
		delete this._events, delete this._onceEvents
	}, e
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("get-size/get-size", t) : "object" == typeof module && module.exports ? module.exports = t() : e.getSize = t()
}(window, (function() {
	"use strict";

	function e(e) {
		var t = parseFloat(e);
		return -1 == e.indexOf("%") && !isNaN(t) && t
	}

	function t(e) {
		var t = getComputedStyle(e);
		return t || n("Style returned " + t + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), t
	}
	var i, n = "undefined" == typeof console ? function() {} : function(e) {
			console.error(e)
		},
		r = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"],
		o = r.length,
		s = !1;
	return function n(a) {
		if (function() {
				if (!s) {
					s = !0;
					var r = document.createElement("div");
					r.style.width = "200px", r.style.padding = "1px 2px 3px 4px", r.style.borderStyle = "solid", r.style.borderWidth = "1px 2px 3px 4px", r.style.boxSizing = "border-box";
					var o = document.body || document.documentElement;
					o.appendChild(r);
					var a = t(r);
					i = 200 == Math.round(e(a.width)), n.isBoxSizeOuter = i, o.removeChild(r)
				}
			}(), "string" == typeof a && (a = document.querySelector(a)), a && "object" == typeof a && a.nodeType) {
			var l = t(a);
			if ("none" == l.display) return function() {
				for (var e = {
						width: 0,
						height: 0,
						innerWidth: 0,
						innerHeight: 0,
						outerWidth: 0,
						outerHeight: 0
					}, t = 0; t < o; t++) e[r[t]] = 0;
				return e
			}();
			var c = {};
			c.width = a.offsetWidth, c.height = a.offsetHeight;
			for (var h = c.isBorderBox = "border-box" == l.boxSizing, u = 0; u < o; u++) {
				var d = r[u],
					p = l[d],
					f = parseFloat(p);
				c[d] = isNaN(f) ? 0 : f
			}
			var m = c.paddingLeft + c.paddingRight,
				g = c.paddingTop + c.paddingBottom,
				v = c.marginLeft + c.marginRight,
				y = c.marginTop + c.marginBottom,
				b = c.borderLeftWidth + c.borderRightWidth,
				w = c.borderTopWidth + c.borderBottomWidth,
				x = h && i,
				_ = e(l.width);
			!1 !== _ && (c.width = _ + (x ? 0 : m + b));
			var E = e(l.height);
			return !1 !== E && (c.height = E + (x ? 0 : g + w)), c.innerWidth = c.width - (m + b), c.innerHeight = c.height - (g + w), c.outerWidth = c.width + v, c.outerHeight = c.height + y, c
		}
	}
})),
function(e, t) {
	"use strict";
	"function" == typeof define && define.amd ? define("desandro-matches-selector/matches-selector", t) : "object" == typeof module && module.exports ? module.exports = t() : e.matchesSelector = t()
}(window, (function() {
	"use strict";
	var e = function() {
		var e = window.Element.prototype;
		if (e.matches) return "matches";
		if (e.matchesSelector) return "matchesSelector";
		for (var t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) {
			var n = t[i] + "MatchesSelector";
			if (e[n]) return n
		}
	}();
	return function(t, i) {
		return t[e](i)
	}
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("fizzy-ui-utils/utils", ["desandro-matches-selector/matches-selector"], (function(i) {
		return t(e, i)
	})) : "object" == typeof module && module.exports ? module.exports = t(e, require("desandro-matches-selector")) : e.fizzyUIUtils = t(e, e.matchesSelector)
}(window, (function(e, t) {
	var i = {
			extend: function(e, t) {
				for (var i in t) e[i] = t[i];
				return e
			},
			modulo: function(e, t) {
				return (e % t + t) % t
			}
		},
		n = Array.prototype.slice;
	i.makeArray = function(e) {
		return Array.isArray(e) ? e : null == e ? [] : "object" == typeof e && "number" == typeof e.length ? n.call(e) : [e]
	}, i.removeFrom = function(e, t) {
		var i = e.indexOf(t); - 1 != i && e.splice(i, 1)
	}, i.getParent = function(e, i) {
		for (; e.parentNode && e != document.body;)
			if (e = e.parentNode, t(e, i)) return e
	}, i.getQueryElement = function(e) {
		return "string" == typeof e ? document.querySelector(e) : e
	}, i.handleEvent = function(e) {
		var t = "on" + e.type;
		this[t] && this[t](e)
	}, i.filterFindElements = function(e, n) {
		e = i.makeArray(e);
		var r = [];
		return e.forEach((function(e) {
			if (e instanceof HTMLElement) {
				if (!n) return void r.push(e);
				t(e, n) && r.push(e);
				for (var i = e.querySelectorAll(n), o = 0; o < i.length; o++) r.push(i[o])
			}
		})), r
	}, i.debounceMethod = function(e, t, i) {
		i = i || 100;
		var n = e.prototype[t],
			r = t + "Timeout";
		e.prototype[t] = function() {
			var e = this[r];
			clearTimeout(e);
			var t = arguments,
				o = this;
			this[r] = setTimeout((function() {
				n.apply(o, t), delete o[r]
			}), i)
		}
	}, i.docReady = function(e) {
		var t = document.readyState;
		"complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener("DOMContentLoaded", e)
	}, i.toDashed = function(e) {
		return e.replace(/(.)([A-Z])/g, (function(e, t, i) {
			return t + "-" + i
		})).toLowerCase()
	};
	var r = e.console;
	return i.htmlInit = function(t, n) {
		i.docReady((function() {
			var o = i.toDashed(n),
				s = "data-" + o,
				a = document.querySelectorAll("[" + s + "]"),
				l = document.querySelectorAll(".js-" + o),
				c = i.makeArray(a).concat(i.makeArray(l)),
				h = s + "-options",
				u = e.jQuery;
			c.forEach((function(e) {
				var i, o = e.getAttribute(s) || e.getAttribute(h);
				try {
					i = o && JSON.parse(o)
				} catch (i) {
					return void(r && r.error("Error parsing " + s + " on " + e.className + ": " + i))
				}
				var a = new t(e, i);
				u && u.data(e, n, a)
			}))
		}))
	}, i
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("outlayer/item", ["ev-emitter/ev-emitter", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("ev-emitter"), require("get-size")) : (e.Outlayer = {}, e.Outlayer.Item = t(e.EvEmitter, e.getSize))
}(window, (function(e, t) {
	"use strict";

	function i(e, t) {
		e && (this.element = e, this.layout = t, this.position = {
			x: 0,
			y: 0
		}, this._create())
	}
	var n = document.documentElement.style,
		r = "string" == typeof n.transition ? "transition" : "WebkitTransition",
		o = "string" == typeof n.transform ? "transform" : "WebkitTransform",
		s = {
			WebkitTransition: "webkitTransitionEnd",
			transition: "transitionend"
		} [r],
		a = {
			transform: o,
			transition: r,
			transitionDuration: r + "Duration",
			transitionProperty: r + "Property",
			transitionDelay: r + "Delay"
		},
		l = i.prototype = Object.create(e.prototype);
	l.constructor = i, l._create = function() {
		this._transn = {
			ingProperties: {},
			clean: {},
			onEnd: {}
		}, this.css({
			position: "absolute"
		})
	}, l.handleEvent = function(e) {
		var t = "on" + e.type;
		this[t] && this[t](e)
	}, l.getSize = function() {
		this.size = t(this.element)
	}, l.css = function(e) {
		var t = this.element.style;
		for (var i in e) t[a[i] || i] = e[i]
	}, l.getPosition = function() {
		var e = getComputedStyle(this.element),
			t = this.layout._getOption("originLeft"),
			i = this.layout._getOption("originTop"),
			n = e[t ? "left" : "right"],
			r = e[i ? "top" : "bottom"],
			o = parseFloat(n),
			s = parseFloat(r),
			a = this.layout.size; - 1 != n.indexOf("%") && (o = o / 100 * a.width), -1 != r.indexOf("%") && (s = s / 100 * a.height), o = isNaN(o) ? 0 : o, s = isNaN(s) ? 0 : s, o -= t ? a.paddingLeft : a.paddingRight, s -= i ? a.paddingTop : a.paddingBottom, this.position.x = o, this.position.y = s
	}, l.layoutPosition = function() {
		var e = this.layout.size,
			t = {},
			i = this.layout._getOption("originLeft"),
			n = this.layout._getOption("originTop"),
			r = i ? "paddingLeft" : "paddingRight",
			o = i ? "left" : "right",
			s = i ? "right" : "left",
			a = this.position.x + e[r];
		t[o] = this.getXValue(a), t[s] = "";
		var l = n ? "paddingTop" : "paddingBottom",
			c = n ? "top" : "bottom",
			h = n ? "bottom" : "top",
			u = this.position.y + e[l];
		t[c] = this.getYValue(u), t[h] = "", this.css(t), this.emitEvent("layout", [this])
	}, l.getXValue = function(e) {
		var t = this.layout._getOption("horizontal");
		return this.layout.options.percentPosition && !t ? e / this.layout.size.width * 100 + "%" : e + "px"
	}, l.getYValue = function(e) {
		var t = this.layout._getOption("horizontal");
		return this.layout.options.percentPosition && t ? e / this.layout.size.height * 100 + "%" : e + "px"
	}, l._transitionTo = function(e, t) {
		this.getPosition();
		var i = this.position.x,
			n = this.position.y,
			r = e == this.position.x && t == this.position.y;
		if (this.setPosition(e, t), !r || this.isTransitioning) {
			var o = e - i,
				s = t - n,
				a = {};
			a.transform = this.getTranslate(o, s), this.transition({
				to: a,
				onTransitionEnd: {
					transform: this.layoutPosition
				},
				isCleaning: !0
			})
		} else this.layoutPosition()
	}, l.getTranslate = function(e, t) {
		return "translate3d(" + (e = this.layout._getOption("originLeft") ? e : -e) + "px, " + (t = this.layout._getOption("originTop") ? t : -t) + "px, 0)"
	}, l.goTo = function(e, t) {
		this.setPosition(e, t), this.layoutPosition()
	}, l.moveTo = l._transitionTo, l.setPosition = function(e, t) {
		this.position.x = parseFloat(e), this.position.y = parseFloat(t)
	}, l._nonTransition = function(e) {
		for (var t in this.css(e.to), e.isCleaning && this._removeStyles(e.to), e.onTransitionEnd) e.onTransitionEnd[t].call(this)
	}, l.transition = function(e) {
		if (parseFloat(this.layout.options.transitionDuration)) {
			var t = this._transn;
			for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i];
			for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0);
			e.from && (this.css(e.from), this.element.offsetHeight), this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0
		} else this._nonTransition(e)
	};
	var c = "opacity," + o.replace(/([A-Z])/g, (function(e) {
		return "-" + e.toLowerCase()
	}));
	l.enableTransition = function() {
		if (!this.isTransitioning) {
			var e = this.layout.options.transitionDuration;
			e = "number" == typeof e ? e + "ms" : e, this.css({
				transitionProperty: c,
				transitionDuration: e,
				transitionDelay: this.staggerDelay || 0
			}), this.element.addEventListener(s, this, !1)
		}
	}, l.onwebkitTransitionEnd = function(e) {
		this.ontransitionend(e)
	}, l.onotransitionend = function(e) {
		this.ontransitionend(e)
	};
	var h = {
		"-webkit-transform": "transform"
	};
	l.ontransitionend = function(e) {
		if (e.target === this.element) {
			var t = this._transn,
				i = h[e.propertyName] || e.propertyName;
			delete t.ingProperties[i],
				function(e) {
					for (var t in e) return !1;
					return !0
				}(t.ingProperties) && this.disableTransition(), i in t.clean && (this.element.style[e.propertyName] = "", delete t.clean[i]), i in t.onEnd && (t.onEnd[i].call(this), delete t.onEnd[i]), this.emitEvent("transitionEnd", [this])
		}
	}, l.disableTransition = function() {
		this.removeTransitionStyles(), this.element.removeEventListener(s, this, !1), this.isTransitioning = !1
	}, l._removeStyles = function(e) {
		var t = {};
		for (var i in e) t[i] = "";
		this.css(t)
	};
	var u = {
		transitionProperty: "",
		transitionDuration: "",
		transitionDelay: ""
	};
	return l.removeTransitionStyles = function() {
		this.css(u)
	}, l.stagger = function(e) {
		e = isNaN(e) ? 0 : e, this.staggerDelay = e + "ms"
	}, l.removeElem = function() {
		this.element.parentNode.removeChild(this.element), this.css({
			display: ""
		}), this.emitEvent("remove", [this])
	}, l.remove = function() {
		return r && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", (function() {
			this.removeElem()
		})), void this.hide()) : void this.removeElem()
	}, l.reveal = function() {
		delete this.isHidden, this.css({
			display: ""
		});
		var e = this.layout.options,
			t = {};
		t[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({
			from: e.hiddenStyle,
			to: e.visibleStyle,
			isCleaning: !0,
			onTransitionEnd: t
		})
	}, l.onRevealTransitionEnd = function() {
		this.isHidden || this.emitEvent("reveal")
	}, l.getHideRevealTransitionEndProperty = function(e) {
		var t = this.layout.options[e];
		if (t.opacity) return "opacity";
		for (var i in t) return i
	}, l.hide = function() {
		this.isHidden = !0, this.css({
			display: ""
		});
		var e = this.layout.options,
			t = {};
		t[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({
			from: e.visibleStyle,
			to: e.hiddenStyle,
			isCleaning: !0,
			onTransitionEnd: t
		})
	}, l.onHideTransitionEnd = function() {
		this.isHidden && (this.css({
			display: "none"
		}), this.emitEvent("hide"))
	}, l.destroy = function() {
		this.css({
			position: "",
			left: "",
			right: "",
			top: "",
			bottom: "",
			transition: "",
			transform: ""
		})
	}, i
})),
function(e, t) {
	"use strict";
	"function" == typeof define && define.amd ? define("outlayer/outlayer", ["ev-emitter/ev-emitter", "get-size/get-size", "fizzy-ui-utils/utils", "./item"], (function(i, n, r, o) {
		return t(e, i, n, r, o)
	})) : "object" == typeof module && module.exports ? module.exports = t(e, require("ev-emitter"), require("get-size"), require("fizzy-ui-utils"), require("./item")) : e.Outlayer = t(e, e.EvEmitter, e.getSize, e.fizzyUIUtils, e.Outlayer.Item)
}(window, (function(e, t, i, n, r) {
	"use strict";

	function o(e, t) {
		var i = n.getQueryElement(e);
		if (i) {
			this.element = i, l && (this.$element = l(this.element)), this.options = n.extend({}, this.constructor.defaults), this.option(t);
			var r = ++h;
			this.element.outlayerGUID = r, (u[r] = this)._create(), this._getOption("initLayout") && this.layout()
		} else a && a.error("Bad element for " + this.constructor.namespace + ": " + (i || e))
	}

	function s(e) {
		function t() {
			e.apply(this, arguments)
		}
		return (t.prototype = Object.create(e.prototype)).constructor = t
	}
	var a = e.console,
		l = e.jQuery,
		c = function() {},
		h = 0,
		u = {};
	o.namespace = "outlayer", o.Item = r, o.defaults = {
		containerStyle: {
			position: "relative"
		},
		initLayout: !0,
		originLeft: !0,
		originTop: !0,
		resize: !0,
		resizeContainer: !0,
		transitionDuration: "0.4s",
		hiddenStyle: {
			opacity: 0,
			transform: "scale(0.001)"
		},
		visibleStyle: {
			opacity: 1,
			transform: "scale(1)"
		}
	};
	var d = o.prototype;
	n.extend(d, t.prototype), d.option = function(e) {
		n.extend(this.options, e)
	}, d._getOption = function(e) {
		var t = this.constructor.compatOptions[e];
		return t && void 0 !== this.options[t] ? this.options[t] : this.options[e]
	}, o.compatOptions = {
		initLayout: "isInitLayout",
		horizontal: "isHorizontal",
		layoutInstant: "isLayoutInstant",
		originLeft: "isOriginLeft",
		originTop: "isOriginTop",
		resize: "isResizeBound",
		resizeContainer: "isResizingContainer"
	}, d._create = function() {
		this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), n.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize()
	}, d.reloadItems = function() {
		this.items = this._itemize(this.element.children)
	}, d._itemize = function(e) {
		for (var t = this._filterFindItemElements(e), i = this.constructor.Item, n = [], r = 0; r < t.length; r++) {
			var o = new i(t[r], this);
			n.push(o)
		}
		return n
	}, d._filterFindItemElements = function(e) {
		return n.filterFindElements(e, this.options.itemSelector)
	}, d.getItemElements = function() {
		return this.items.map((function(e) {
			return e.element
		}))
	}, d.layout = function() {
		this._resetLayout(), this._manageStamps();
		var e = this._getOption("layoutInstant"),
			t = void 0 !== e ? e : !this._isLayoutInited;
		this.layoutItems(this.items, t), this._isLayoutInited = !0
	}, d._init = d.layout, d._resetLayout = function() {
		this.getSize()
	}, d.getSize = function() {
		this.size = i(this.element)
	}, d._getMeasurement = function(e, t) {
		var n, r = this.options[e];
		r ? ("string" == typeof r ? n = this.element.querySelector(r) : r instanceof HTMLElement && (n = r), this[e] = n ? i(n)[t] : r) : this[e] = 0
	}, d.layoutItems = function(e, t) {
		e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout()
	}, d._getItemsForLayout = function(e) {
		return e.filter((function(e) {
			return !e.isIgnored
		}))
	}, d._layoutItems = function(e, t) {
		if (this._emitCompleteOnItems("layout", e), e && e.length) {
			var i = [];
			e.forEach((function(e) {
				var n = this._getItemLayoutPosition(e);
				n.item = e, n.isInstant = t || e.isLayoutInstant, i.push(n)
			}), this), this._processLayoutQueue(i)
		}
	}, d._getItemLayoutPosition = function() {
		return {
			x: 0,
			y: 0
		}
	}, d._processLayoutQueue = function(e) {
		this.updateStagger(), e.forEach((function(e, t) {
			this._positionItem(e.item, e.x, e.y, e.isInstant, t)
		}), this)
	}, d.updateStagger = function() {
		var e = this.options.stagger;
		return null == e ? void(this.stagger = 0) : (this.stagger = function(e) {
			if ("number" == typeof e) return e;
			var t = e.match(/(^\d*\.?\d*)(\w*)/),
				i = t && t[1],
				n = t && t[2];
			return i.length ? (i = parseFloat(i)) * (p[n] || 1) : 0
		}(e), this.stagger)
	}, d._positionItem = function(e, t, i, n, r) {
		n ? e.goTo(t, i) : (e.stagger(r * this.stagger), e.moveTo(t, i))
	}, d._postLayout = function() {
		this.resizeContainer()
	}, d.resizeContainer = function() {
		if (this._getOption("resizeContainer")) {
			var e = this._getContainerSize();
			e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1))
		}
	}, d._getContainerSize = c, d._setContainerMeasure = function(e, t) {
		if (void 0 !== e) {
			var i = this.size;
			i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" : "height"] = e + "px"
		}
	}, d._emitCompleteOnItems = function(e, t) {
		function i() {
			r.dispatchEvent(e + "Complete", null, [t])
		}

		function n() {
			++s == o && i()
		}
		var r = this,
			o = t.length;
		if (t && o) {
			var s = 0;
			t.forEach((function(t) {
				t.once(e, n)
			}))
		} else i()
	}, d.dispatchEvent = function(e, t, i) {
		var n = t ? [t].concat(i) : i;
		if (this.emitEvent(e, n), l)
			if (this.$element = this.$element || l(this.element), t) {
				var r = l.Event(t);
				r.type = e, this.$element.trigger(r, i)
			} else this.$element.trigger(e, i)
	}, d.ignore = function(e) {
		var t = this.getItem(e);
		t && (t.isIgnored = !0)
	}, d.unignore = function(e) {
		var t = this.getItem(e);
		t && delete t.isIgnored
	}, d.stamp = function(e) {
		(e = this._find(e)) && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore, this))
	}, d.unstamp = function(e) {
		(e = this._find(e)) && e.forEach((function(e) {
			n.removeFrom(this.stamps, e), this.unignore(e)
		}), this)
	}, d._find = function(e) {
		if (e) return "string" == typeof e && (e = this.element.querySelectorAll(e)), n.makeArray(e)
	}, d._manageStamps = function() {
		this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this))
	}, d._getBoundingRect = function() {
		var e = this.element.getBoundingClientRect(),
			t = this.size;
		this._boundingRect = {
			left: e.left + t.paddingLeft + t.borderLeftWidth,
			top: e.top + t.paddingTop + t.borderTopWidth,
			right: e.right - (t.paddingRight + t.borderRightWidth),
			bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth)
		}
	}, d._manageStamp = c, d._getElementOffset = function(e) {
		var t = e.getBoundingClientRect(),
			n = this._boundingRect,
			r = i(e);
		return {
			left: t.left - n.left - r.marginLeft,
			top: t.top - n.top - r.marginTop,
			right: n.right - t.right - r.marginRight,
			bottom: n.bottom - t.bottom - r.marginBottom
		}
	}, d.handleEvent = n.handleEvent, d.bindResize = function() {
		e.addEventListener("resize", this), this.isResizeBound = !0
	}, d.unbindResize = function() {
		e.removeEventListener("resize", this), this.isResizeBound = !1
	}, d.onresize = function() {
		this.resize()
	}, n.debounceMethod(o, "onresize", 100), d.resize = function() {
		this.isResizeBound && this.needsResizeLayout() && this.layout()
	}, d.needsResizeLayout = function() {
		var e = i(this.element);
		return this.size && e && e.innerWidth !== this.size.innerWidth
	}, d.addItems = function(e) {
		var t = this._itemize(e);
		return t.length && (this.items = this.items.concat(t)), t
	}, d.appended = function(e) {
		var t = this.addItems(e);
		t.length && (this.layoutItems(t, !0), this.reveal(t))
	}, d.prepended = function(e) {
		var t = this._itemize(e);
		if (t.length) {
			var i = this.items.slice(0);
			this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(t, !0), this.reveal(t), this.layoutItems(i)
		}
	}, d.reveal = function(e) {
		if (this._emitCompleteOnItems("reveal", e), e && e.length) {
			var t = this.updateStagger();
			e.forEach((function(e, i) {
				e.stagger(i * t), e.reveal()
			}))
		}
	}, d.hide = function(e) {
		if (this._emitCompleteOnItems("hide", e), e && e.length) {
			var t = this.updateStagger();
			e.forEach((function(e, i) {
				e.stagger(i * t), e.hide()
			}))
		}
	}, d.revealItemElements = function(e) {
		var t = this.getItems(e);
		this.reveal(t)
	}, d.hideItemElements = function(e) {
		var t = this.getItems(e);
		this.hide(t)
	}, d.getItem = function(e) {
		for (var t = 0; t < this.items.length; t++) {
			var i = this.items[t];
			if (i.element == e) return i
		}
	}, d.getItems = function(e) {
		e = n.makeArray(e);
		var t = [];
		return e.forEach((function(e) {
			var i = this.getItem(e);
			i && t.push(i)
		}), this), t
	}, d.remove = function(e) {
		var t = this.getItems(e);
		this._emitCompleteOnItems("remove", t), t && t.length && t.forEach((function(e) {
			e.remove(), n.removeFrom(this.items, e)
		}), this)
	}, d.destroy = function() {
		var e = this.element.style;
		e.height = "", e.position = "", e.width = "", this.items.forEach((function(e) {
			e.destroy()
		})), this.unbindResize();
		var t = this.element.outlayerGUID;
		delete u[t], delete this.element.outlayerGUID, l && l.removeData(this.element, this.constructor.namespace)
	}, o.data = function(e) {
		var t = (e = n.getQueryElement(e)) && e.outlayerGUID;
		return t && u[t]
	}, o.create = function(e, t) {
		var i = s(o);
		return i.defaults = n.extend({}, o.defaults), n.extend(i.defaults, t), i.compatOptions = n.extend({}, o.compatOptions), i.namespace = e, i.data = o.data, i.Item = s(r), n.htmlInit(i, e), l && l.bridget && l.bridget(e, i), i
	};
	var p = {
		ms: 1,
		s: 1e3
	};
	return o.Item = r, o
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("isotope-layout/js/item", ["outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.Item = t(e.Outlayer))
}(window, (function(e) {
	"use strict";

	function t() {
		e.Item.apply(this, arguments)
	}
	var i = t.prototype = Object.create(e.Item.prototype),
		n = i._create;
	i._create = function() {
		this.id = this.layout.itemGUID++, n.call(this), this.sortData = {}
	}, i.updateSortData = function() {
		if (!this.isIgnored) {
			this.sortData.id = this.id, this.sortData["original-order"] = this.id, this.sortData.random = Math.random();
			var e = this.layout.options.getSortData,
				t = this.layout._sorters;
			for (var i in e) {
				var n = t[i];
				this.sortData[i] = n(this.element, this)
			}
		}
	};
	var r = i.destroy;
	return i.destroy = function() {
		r.apply(this, arguments), this.css({
			display: ""
		})
	}, t
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("isotope-layout/js/layout-mode", ["get-size/get-size", "outlayer/outlayer"], t) : "object" == typeof module && module.exports ? module.exports = t(require("get-size"), require("outlayer")) : (e.Isotope = e.Isotope || {}, e.Isotope.LayoutMode = t(e.getSize, e.Outlayer))
}(window, (function(e, t) {
	"use strict";

	function i(e) {
		(this.isotope = e) && (this.options = e.options[this.namespace], this.element = e.element, this.items = e.filteredItems, this.size = e.size)
	}
	var n = i.prototype;
	return ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"].forEach((function(e) {
		n[e] = function() {
			return t.prototype[e].apply(this.isotope, arguments)
		}
	})), n.needsVerticalResizeLayout = function() {
		var t = e(this.isotope.element);
		return this.isotope.size && t && t.innerHeight != this.isotope.size.innerHeight
	}, n._getMeasurement = function() {
		this.isotope._getMeasurement.apply(this, arguments)
	}, n.getColumnWidth = function() {
		this.getSegmentSize("column", "Width")
	}, n.getRowHeight = function() {
		this.getSegmentSize("row", "Height")
	}, n.getSegmentSize = function(e, t) {
		var i = e + t,
			n = "outer" + t;
		if (this._getMeasurement(i, n), !this[i]) {
			var r = this.getFirstItemSize();
			this[i] = r && r[n] || this.isotope.size["inner" + t]
		}
	}, n.getFirstItemSize = function() {
		var t = this.isotope.filteredItems[0];
		return t && t.element && e(t.element)
	}, n.layout = function() {
		this.isotope.layout.apply(this.isotope, arguments)
	}, n.getSize = function() {
		this.isotope.getSize(), this.size = this.isotope.size
	}, i.modes = {}, i.create = function(e, t) {
		function r() {
			i.apply(this, arguments)
		}
		return (r.prototype = Object.create(n)).constructor = r, t && (r.options = t), i.modes[r.prototype.namespace = e] = r
	}, i
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("masonry-layout/masonry", ["outlayer/outlayer", "get-size/get-size"], t) : "object" == typeof module && module.exports ? module.exports = t(require("outlayer"), require("get-size")) : e.Masonry = t(e.Outlayer, e.getSize)
}(window, (function(e, t) {
	var i = e.create("masonry");
	i.compatOptions.fitWidth = "isFitWidth";
	var n = i.prototype;
	return n._resetLayout = function() {
		this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = [];
		for (var e = 0; e < this.cols; e++) this.colYs.push(0);
		this.maxY = 0, this.horizontalColIndex = 0
	}, n.measureColumns = function() {
		if (this.getContainerWidth(), !this.columnWidth) {
			var e = this.items[0],
				i = e && e.element;
			this.columnWidth = i && t(i).outerWidth || this.containerWidth
		}
		var n = this.columnWidth += this.gutter,
			r = this.containerWidth + this.gutter,
			o = r / n,
			s = n - r % n;
		o = Math[s && s < 1 ? "round" : "floor"](o), this.cols = Math.max(o, 1)
	}, n.getContainerWidth = function() {
		var e = this._getOption("fitWidth") ? this.element.parentNode : this.element,
			i = t(e);
		this.containerWidth = i && i.innerWidth
	}, n._getItemLayoutPosition = function(e) {
		e.getSize();
		var t = e.size.outerWidth % this.columnWidth,
			i = Math[t && t < 1 ? "round" : "ceil"](e.size.outerWidth / this.columnWidth);
		i = Math.min(i, this.cols);
		for (var n = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](i, e), r = {
				x: this.columnWidth * n.col,
				y: n.y
			}, o = n.y + e.size.outerHeight, s = i + n.col, a = n.col; a < s; a++) this.colYs[a] = o;
		return r
	}, n._getTopColPosition = function(e) {
		var t = this._getTopColGroup(e),
			i = Math.min.apply(Math, t);
		return {
			col: t.indexOf(i),
			y: i
		}
	}, n._getTopColGroup = function(e) {
		if (e < 2) return this.colYs;
		for (var t = [], i = this.cols + 1 - e, n = 0; n < i; n++) t[n] = this._getColGroupY(n, e);
		return t
	}, n._getColGroupY = function(e, t) {
		if (t < 2) return this.colYs[e];
		var i = this.colYs.slice(e, e + t);
		return Math.max.apply(Math, i)
	}, n._getHorizontalColPosition = function(e, t) {
		var i = this.horizontalColIndex % this.cols;
		i = 1 < e && i + e > this.cols ? 0 : i;
		var n = t.size.outerWidth && t.size.outerHeight;
		return this.horizontalColIndex = n ? i + e : this.horizontalColIndex, {
			col: i,
			y: this._getColGroupY(i, e)
		}
	}, n._manageStamp = function(e) {
		var i = t(e),
			n = this._getElementOffset(e),
			r = this._getOption("originLeft") ? n.left : n.right,
			o = r + i.outerWidth,
			s = Math.floor(r / this.columnWidth);
		s = Math.max(0, s);
		var a = Math.floor(o / this.columnWidth);
		a -= o % this.columnWidth ? 0 : 1, a = Math.min(this.cols - 1, a);
		for (var l = (this._getOption("originTop") ? n.top : n.bottom) + i.outerHeight, c = s; c <= a; c++) this.colYs[c] = Math.max(l, this.colYs[c])
	}, n._getContainerSize = function() {
		this.maxY = Math.max.apply(Math, this.colYs);
		var e = {
			height: this.maxY
		};
		return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e
	}, n._getContainerFitWidth = function() {
		for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];) e++;
		return (this.cols - e) * this.columnWidth - this.gutter
	}, n.needsResizeLayout = function() {
		var e = this.containerWidth;
		return this.getContainerWidth(), e != this.containerWidth
	}, i
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/masonry", ["../layout-mode", "masonry-layout/masonry"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode"), require("masonry-layout")) : t(e.Isotope.LayoutMode, e.Masonry)
}(window, (function(e, t) {
	"use strict";
	var i = e.create("masonry"),
		n = i.prototype,
		r = {
			_getElementOffset: !0,
			layout: !0,
			_getMeasurement: !0
		};
	for (var o in t.prototype) r[o] || (n[o] = t.prototype[o]);
	var s = n.measureColumns;
	n.measureColumns = function() {
		this.items = this.isotope.filteredItems, s.call(this)
	};
	var a = n._getOption;
	return n._getOption = function(e) {
		return "fitWidth" == e ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : a.apply(this.isotope, arguments)
	}, i
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/fit-rows", ["../layout-mode"], t) : "object" == typeof exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode)
}(window, (function(e) {
	"use strict";
	var t = e.create("fitRows"),
		i = t.prototype;
	return i._resetLayout = function() {
		this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement("gutter", "outerWidth")
	}, i._getItemLayoutPosition = function(e) {
		e.getSize();
		var t = e.size.outerWidth + this.gutter,
			i = this.isotope.size.innerWidth + this.gutter;
		0 !== this.x && t + this.x > i && (this.x = 0, this.y = this.maxY);
		var n = {
			x: this.x,
			y: this.y
		};
		return this.maxY = Math.max(this.maxY, this.y + e.size.outerHeight), this.x += t, n
	}, i._getContainerSize = function() {
		return {
			height: this.maxY
		}
	}, t
})),
function(e, t) {
	"function" == typeof define && define.amd ? define("isotope-layout/js/layout-modes/vertical", ["../layout-mode"], t) : "object" == typeof module && module.exports ? module.exports = t(require("../layout-mode")) : t(e.Isotope.LayoutMode)
}(window, (function(e) {
	"use strict";
	var t = e.create("vertical", {
			horizontalAlignment: 0
		}),
		i = t.prototype;
	return i._resetLayout = function() {
		this.y = 0
	}, i._getItemLayoutPosition = function(e) {
		e.getSize();
		var t = (this.isotope.size.innerWidth - e.size.outerWidth) * this.options.horizontalAlignment,
			i = this.y;
		return this.y += e.size.outerHeight, {
			x: t,
			y: i
		}
	}, i._getContainerSize = function() {
		return {
			height: this.y
		}
	}, t
})),
function(e, t) {
	"function" == typeof define && define.amd ? define(["outlayer/outlayer", "get-size/get-size", "desandro-matches-selector/matches-selector", "fizzy-ui-utils/utils", "isotope-layout/js/item", "isotope-layout/js/layout-mode", "isotope-layout/js/layout-modes/masonry", "isotope-layout/js/layout-modes/fit-rows", "isotope-layout/js/layout-modes/vertical"], (function(i, n, r, o, s, a) {
		return t(e, i, n, r, o, s, a)
	})) : "object" == typeof module && module.exports ? module.exports = t(e, require("outlayer"), require("get-size"), require("desandro-matches-selector"), require("fizzy-ui-utils"), require("isotope-layout/js/item"), require("isotope-layout/js/layout-mode"), require("isotope-layout/js/layout-modes/masonry"), require("isotope-layout/js/layout-modes/fit-rows"), require("isotope-layout/js/layout-modes/vertical")) : e.Isotope = t(e, e.Outlayer, e.getSize, e.matchesSelector, e.fizzyUIUtils, e.Isotope.Item, e.Isotope.LayoutMode)
}(window, (function(e, t, i, n, r, o, s) {
	var a = e.jQuery,
		l = String.prototype.trim ? function(e) {
			return e.trim()
		} : function(e) {
			return e.replace(/^\s+|\s+$/g, "")
		},
		c = t.create("isotope", {
			layoutMode: "masonry",
			isJQueryFiltering: !0,
			sortAscending: !0
		});
	c.Item = o, c.LayoutMode = s;
	var h = c.prototype;
	h._create = function() {
		for (var e in this.itemGUID = 0, this._sorters = {}, this._getSorters(), t.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ["original-order"], s.modes) this._initLayoutMode(e)
	}, h.reloadItems = function() {
		this.itemGUID = 0, t.prototype.reloadItems.call(this)
	}, h._itemize = function() {
		for (var e = t.prototype._itemize.apply(this, arguments), i = 0; i < e.length; i++) e[i].id = this.itemGUID++;
		return this._updateItemsSortData(e), e
	}, h._initLayoutMode = function(e) {
		var t = s.modes[e],
			i = this.options[e] || {};
		this.options[e] = t.options ? r.extend(t.options, i) : i, this.modes[e] = new t(this)
	}, h.layout = function() {
		return !this._isLayoutInited && this._getOption("initLayout") ? void this.arrange() : void this._layout()
	}, h._layout = function() {
		var e = this._getIsInstant();
		this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, e), this._isLayoutInited = !0
	}, h.arrange = function(e) {
		this.option(e), this._getIsInstant();
		var t = this._filter(this.items);
		this.filteredItems = t.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [t]) : this._hideReveal(t), this._sort(), this._layout()
	}, h._init = h.arrange, h._hideReveal = function(e) {
		this.reveal(e.needReveal), this.hide(e.needHide)
	}, h._getIsInstant = function() {
		var e = this._getOption("layoutInstant"),
			t = void 0 !== e ? e : !this._isLayoutInited;
		return this._isInstant = t
	}, h._bindArrangeComplete = function() {
		function e() {
			t && i && n && r.dispatchEvent("arrangeComplete", null, [r.filteredItems])
		}
		var t, i, n, r = this;
		this.once("layoutComplete", (function() {
			t = !0, e()
		})), this.once("hideComplete", (function() {
			i = !0, e()
		})), this.once("revealComplete", (function() {
			n = !0, e()
		}))
	}, h._filter = function(e) {
		var t = this.options.filter;
		t = t || "*";
		for (var i = [], n = [], r = [], o = this._getFilterTest(t), s = 0; s < e.length; s++) {
			var a = e[s];
			if (!a.isIgnored) {
				var l = o(a);
				l && i.push(a), l && a.isHidden ? n.push(a) : l || a.isHidden || r.push(a)
			}
		}
		return {
			matches: i,
			needReveal: n,
			needHide: r
		}
	}, h._getFilterTest = function(e) {
		return a && this.options.isJQueryFiltering ? function(t) {
			return a(t.element).is(e)
		} : "function" == typeof e ? function(t) {
			return e(t.element)
		} : function(t) {
			return n(t.element, e)
		}
	}, h.updateSortData = function(e) {
		var t;
		t = e ? (e = r.makeArray(e), this.getItems(e)) : this.items, this._getSorters(), this._updateItemsSortData(t)
	}, h._getSorters = function() {
		var e = this.options.getSortData;
		for (var t in e) {
			var i = e[t];
			this._sorters[t] = u(i)
		}
	}, h._updateItemsSortData = function(e) {
		for (var t = e && e.length, i = 0; t && i < t; i++) e[i].updateSortData()
	};
	var u = function(e) {
		if ("string" != typeof e) return e;
		var t, i, n = l(e).split(" "),
			r = n[0],
			o = r.match(/^\[(.+)\]$/),
			s = o && o[1],
			a = (i = r, (t = s) ? function(e) {
				return e.getAttribute(t)
			} : function(e) {
				var t = e.querySelector(i);
				return t && t.textContent
			}),
			h = c.sortDataParsers[n[1]];
		return h ? function(e) {
			return e && h(a(e))
		} : function(e) {
			return e && a(e)
		}
	};
	c.sortDataParsers = {
		parseInt: function(e) {
			return parseInt(e, 10)
		},
		parseFloat: function(e) {
			return parseFloat(e)
		}
	}, h._sort = function() {
		if (this.options.sortBy) {
			var e = r.makeArray(this.options.sortBy);
			this._getIsSameSortBy(e) || (this.sortHistory = e.concat(this.sortHistory));
			var t = (i = this.sortHistory, n = this.options.sortAscending, function(e, t) {
				for (var r = 0; r < i.length; r++) {
					var o = i[r],
						s = e.sortData[o],
						a = t.sortData[o];
					if (a < s || s < a) return (a < s ? 1 : -1) * ((void 0 !== n[o] ? n[o] : n) ? 1 : -1)
				}
				return 0
			});
			this.filteredItems.sort(t)
		}
		var i, n
	}, h._getIsSameSortBy = function(e) {
		for (var t = 0; t < e.length; t++)
			if (e[t] != this.sortHistory[t]) return !1;
		return !0
	}, h._mode = function() {
		var e = this.options.layoutMode,
			t = this.modes[e];
		if (!t) throw new Error("No layout mode: " + e);
		return t.options = this.options[e], t
	}, h._resetLayout = function() {
		t.prototype._resetLayout.call(this), this._mode()._resetLayout()
	}, h._getItemLayoutPosition = function(e) {
		return this._mode()._getItemLayoutPosition(e)
	}, h._manageStamp = function(e) {
		this._mode()._manageStamp(e)
	}, h._getContainerSize = function() {
		return this._mode()._getContainerSize()
	}, h.needsResizeLayout = function() {
		return this._mode().needsResizeLayout()
	}, h.appended = function(e) {
		var t = this.addItems(e);
		if (t.length) {
			var i = this._filterRevealAdded(t);
			this.filteredItems = this.filteredItems.concat(i)
		}
	}, h.prepended = function(e) {
		var t = this._itemize(e);
		if (t.length) {
			this._resetLayout(), this._manageStamps();
			var i = this._filterRevealAdded(t);
			this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = t.concat(this.items)
		}
	}, h._filterRevealAdded = function(e) {
		var t = this._filter(e);
		return this.hide(t.needHide), this.reveal(t.matches), this.layoutItems(t.matches, !0), t.matches
	}, h.insert = function(e) {
		var t = this.addItems(e);
		if (t.length) {
			var i, n, r = t.length;
			for (i = 0; i < r; i++) n = t[i], this.element.appendChild(n.element);
			var o = this._filter(t).matches;
			for (i = 0; i < r; i++) t[i].isLayoutInstant = !0;
			for (this.arrange(), i = 0; i < r; i++) delete t[i].isLayoutInstant;
			this.reveal(o)
		}
	};
	var d = h.remove;
	return h.remove = function(e) {
		e = r.makeArray(e);
		var t = this.getItems(e);
		d.call(this, e);
		for (var i = t && t.length, n = 0; i && n < i; n++) {
			var o = t[n];
			r.removeFrom(this.filteredItems, o)
		}
	}, h.shuffle = function() {
		for (var e = 0; e < this.items.length; e++) this.items[e].sortData.random = Math.random();
		this.options.sortBy = "random", this._sort(), this._layout()
	}, h._noTransition = function(e, t) {
		var i = this.options.transitionDuration;
		this.options.transitionDuration = 0;
		var n = e.apply(this, t);
		return this.options.transitionDuration = i, n
	}, h.getFilteredItemElements = function() {
		return this.filteredItems.map((function(e) {
			return e.element
		}))
	}, c
})),
function(e) {
	"function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery)
}((function(e) {
	e.ui = e.ui || {}, e.ui.version = "1.12.1";
	var t, i = 0,
		n = Array.prototype.slice;
	e.cleanData = (t = e.cleanData, function(i) {
		for (var n, r, o = 0; null != (r = i[o]); o++) try {
			(n = e._data(r, "events")) && n.remove && e(r).triggerHandler("remove")
		} catch (i) {}
		t(i)
	}), e.widget = function(t, i, n) {
		var r, o, s, a = {},
			l = t.split(".")[0],
			c = l + "-" + (t = t.split(".")[1]);
		return n || (n = i, i = e.Widget), e.isArray(n) && (n = e.extend.apply(null, [{}].concat(n))), e.expr[":"][c.toLowerCase()] = function(t) {
			return !!e.data(t, c)
		}, e[l] = e[l] || {}, r = e[l][t], o = e[l][t] = function(e, t) {
			if (!this._createWidget) return new o(e, t);
			arguments.length && this._createWidget(e, t)
		}, e.extend(o, r, {
			version: n.version,
			_proto: e.extend({}, n),
			_childConstructors: []
		}), (s = new i).options = e.widget.extend({}, s.options), e.each(n, (function(t, n) {
			function r() {
				return i.prototype[t].apply(this, arguments)
			}

			function o(e) {
				return i.prototype[t].apply(this, e)
			}
			e.isFunction(n) ? a[t] = function() {
				var e, t = this._super,
					i = this._superApply;
				return this._super = r, this._superApply = o, e = n.apply(this, arguments), this._super = t, this._superApply = i, e
			} : a[t] = n
		})), o.prototype = e.widget.extend(s, {
			widgetEventPrefix: r && s.widgetEventPrefix || t
		}, a, {
			constructor: o,
			namespace: l,
			widgetName: t,
			widgetFullName: c
		}), r ? (e.each(r._childConstructors, (function(t, i) {
			var n = i.prototype;
			e.widget(n.namespace + "." + n.widgetName, o, i._proto)
		})), delete r._childConstructors) : i._childConstructors.push(o), e.widget.bridge(t, o), o
	}, e.widget.extend = function(t) {
		for (var i, r, o = n.call(arguments, 1), s = 0, a = o.length; s < a; s++)
			for (i in o[s]) r = o[s][i], o[s].hasOwnProperty(i) && void 0 !== r && (e.isPlainObject(r) ? t[i] = e.isPlainObject(t[i]) ? e.widget.extend({}, t[i], r) : e.widget.extend({}, r) : t[i] = r);
		return t
	}, e.widget.bridge = function(t, i) {
		var r = i.prototype.widgetFullName || t;
		e.fn[t] = function(o) {
			var s = "string" == typeof o,
				a = n.call(arguments, 1),
				l = this;
			return s ? this.length || "instance" !== o ? this.each((function() {
				var i, n = e.data(this, r);
				return "instance" === o ? (l = n, !1) : n ? e.isFunction(n[o]) && "_" !== o.charAt(0) ? (i = n[o].apply(n, a)) !== n && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0 : e.error("no such method '" + o + "' for " + t + " widget instance") : e.error("cannot call methods on " + t + " prior to initialization; attempted to call method '" + o + "'")
			})) : l = void 0 : (a.length && (o = e.widget.extend.apply(null, [o].concat(a))), this.each((function() {
				var t = e.data(this, r);
				t ? (t.option(o || {}), t._init && t._init()) : e.data(this, r, new i(o, this))
			}))), l
		}
	}, e.Widget = function() {}, e.Widget._childConstructors = [], e.Widget.prototype = {
		widgetName: "widget",
		widgetEventPrefix: "",
		defaultElement: "<div>",
		options: {
			classes: {},
			disabled: !1,
			create: null
		},
		_createWidget: function(t, n) {
			n = e(n || this.defaultElement || this)[0], this.element = e(n), this.uuid = i++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = e(), this.hoverable = e(), this.focusable = e(), this.classesElementLookup = {}, n !== this && (e.data(n, this.widgetFullName, this), this._on(!0, this.element, {
				remove: function(e) {
					e.target === n && this.destroy()
				}
			}), this.document = e(n.style ? n.ownerDocument : n.document || n), this.window = e(this.document[0].defaultView || this.document[0].parentWindow)), this.options = e.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init()
		},
		_getCreateOptions: function() {
			return {}
		},
		_getCreateEventData: e.noop,
		_create: e.noop,
		_init: e.noop,
		destroy: function() {
			var t = this;
			this._destroy(), e.each(this.classesElementLookup, (function(e, i) {
				t._removeClass(i, e)
			})), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace)
		},
		_destroy: e.noop,
		widget: function() {
			return this.element
		},
		option: function(t, i) {
			var n, r, o, s = t;
			if (0 === arguments.length) return e.widget.extend({}, this.options);
			if ("string" == typeof t)
				if (s = {}, t = (n = t.split(".")).shift(), n.length) {
					for (r = s[t] = e.widget.extend({}, this.options[t]), o = 0; o < n.length - 1; o++) r[n[o]] = r[n[o]] || {}, r = r[n[o]];
					if (t = n.pop(), 1 === arguments.length) return void 0 === r[t] ? null : r[t];
					r[t] = i
				} else {
					if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
					s[t] = i
				} return this._setOptions(s), this
		},
		_setOptions: function(e) {
			for (var t in e) this._setOption(t, e[t]);
			return this
		},
		_setOption: function(e, t) {
			return "classes" === e && this._setOptionClasses(t), this.options[e] = t, "disabled" === e && this._setOptionDisabled(t), this
		},
		_setOptionClasses: function(t) {
			var i, n, r;
			for (i in t) r = this.classesElementLookup[i], t[i] !== this.options.classes[i] && r && r.length && (n = e(r.get()), this._removeClass(r, i), n.addClass(this._classes({
				element: n,
				keys: i,
				classes: t,
				add: !0
			})))
		},
		_setOptionDisabled: function(e) {
			this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!e), e && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"))
		},
		enable: function() {
			return this._setOptions({
				disabled: !1
			})
		},
		disable: function() {
			return this._setOptions({
				disabled: !0
			})
		},
		_classes: function(t) {
			var i = [],
				n = this;

			function r(r, o) {
				for (var s, a = 0; a < r.length; a++) s = n.classesElementLookup[r[a]] || e(), s = t.add ? e(e.unique(s.get().concat(t.element.get()))) : e(s.not(t.element).get()), n.classesElementLookup[r[a]] = s, i.push(r[a]), o && t.classes[r[a]] && i.push(t.classes[r[a]])
			}
			return t = e.extend({
				element: this.element,
				classes: this.options.classes || {}
			}, t), this._on(t.element, {
				remove: "_untrackClassesElement"
			}), t.keys && r(t.keys.match(/\S+/g) || [], !0), t.extra && r(t.extra.match(/\S+/g) || []), i.join(" ")
		},
		_untrackClassesElement: function(t) {
			var i = this;
			e.each(i.classesElementLookup, (function(n, r) {
				-1 !== e.inArray(t.target, r) && (i.classesElementLookup[n] = e(r.not(t.target).get()))
			}))
		},
		_removeClass: function(e, t, i) {
			return this._toggleClass(e, t, i, !1)
		},
		_addClass: function(e, t, i) {
			return this._toggleClass(e, t, i, !0)
		},
		_toggleClass: function(e, t, i, n) {
			n = "boolean" == typeof n ? n : i;
			var r = "string" == typeof e || null === e;
			return (e = {
				extra: r ? t : i,
				keys: r ? e : t,
				element: r ? this.element : e,
				add: n
			}).element.toggleClass(this._classes(e), n), this
		},
		_on: function(t, i, n) {
			var r, o = this;
			"boolean" != typeof t && (n = i, i = t, t = !1), n ? (i = r = e(i), this.bindings = this.bindings.add(i)) : (n = i, i = this.element, r = this.widget()), e.each(n, (function(n, s) {
				function a() {
					if (t || !0 !== o.options.disabled && !e(this).hasClass("ui-state-disabled")) return ("string" == typeof s ? o[s] : s).apply(o, arguments)
				}
				var l;
				"string" != typeof s && (a.guid = s.guid = s.guid || a.guid || e.guid++), n = (l = n.match(/^([\w:-]*)\s*(.*)$/))[1] + o.eventNamespace, (l = l[2]) ? r.on(n, l, a) : i.on(n, a)
			}))
		},
		_off: function(t, i) {
			i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(i).off(i), this.bindings = e(this.bindings.not(t).get()), this.focusable = e(this.focusable.not(t).get()), this.hoverable = e(this.hoverable.not(t).get())
		},
		_delay: function(e, t) {
			var i = this;
			return setTimeout((function() {
				return ("string" == typeof e ? i[e] : e).apply(i, arguments)
			}), t || 0)
		},
		_hoverable: function(t) {
			this.hoverable = this.hoverable.add(t), this._on(t, {
				mouseenter: function(t) {
					this._addClass(e(t.currentTarget), null, "ui-state-hover")
				},
				mouseleave: function(t) {
					this._removeClass(e(t.currentTarget), null, "ui-state-hover")
				}
			})
		},
		_focusable: function(t) {
			this.focusable = this.focusable.add(t), this._on(t, {
				focusin: function(t) {
					this._addClass(e(t.currentTarget), null, "ui-state-focus")
				},
				focusout: function(t) {
					this._removeClass(e(t.currentTarget), null, "ui-state-focus")
				}
			})
		},
		_trigger: function(t, i, n) {
			var r, o, s = this.options[t];
			if (n = n || {}, (i = e.Event(i)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), i.target = this.element[0], o = i.originalEvent)
				for (r in o) r in i || (i[r] = o[r]);
			return this.element.trigger(i, n), !(e.isFunction(s) && !1 === s.apply(this.element[0], [i].concat(n)) || i.isDefaultPrevented())
		}
	}, e.each({
		show: "fadeIn",
		hide: "fadeOut"
	}, (function(t, i) {
		e.Widget.prototype["_" + t] = function(n, r, o) {
			var s;
			"string" == typeof r && (r = {
				effect: r
			});
			var a = r ? !0 !== r && "number" != typeof r && r.effect || i : t;
			"number" == typeof(r = r || {}) && (r = {
				duration: r
			}), s = !e.isEmptyObject(r), r.complete = o, r.delay && n.delay(r.delay), s && e.effects && e.effects.effect[a] ? n[t](r) : a !== t && n[a] ? n[a](r.duration, r.easing, o) : n.queue((function(i) {
				e(this)[t](), o && o.call(n[0]), i()
			}))
		}
	})), e.widget, e.ui.keyCode = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}, e.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
	var r = !1;
	e(document).on("mouseup", (function() {
		r = !1
	})), e.widget("ui.mouse", {
		version: "1.12.1",
		options: {
			cancel: "input, textarea, button, select, option",
			distance: 1,
			delay: 0
		},
		_mouseInit: function() {
			var t = this;
			this.element.on("mousedown." + this.widgetName, (function(e) {
				return t._mouseDown(e)
			})).on("click." + this.widgetName, (function(i) {
				if (!0 === e.data(i.target, t.widgetName + ".preventClickEvent")) return e.removeData(i.target, t.widgetName + ".preventClickEvent"), i.stopImmediatePropagation(), !1
			})), this.started = !1
		},
		_mouseDestroy: function() {
			this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate)
		},
		_mouseDown: function(t) {
			if (!r) {
				this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
				var i = this,
					n = 1 === t.which,
					o = !("string" != typeof this.options.cancel || !t.target.nodeName) && e(t.target).closest(this.options.cancel).length;
				return !(n && !o && this._mouseCapture(t)) || (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout((function() {
					i.mouseDelayMet = !0
				}), this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), !this._mouseStarted) ? (t.preventDefault(), !0) : (!0 === e.data(t.target, this.widgetName + ".preventClickEvent") && e.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function(e) {
					return i._mouseMove(e)
				}, this._mouseUpDelegate = function(e) {
					return i._mouseUp(e)
				}, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), r = !0))
			}
		},
		_mouseMove: function(t) {
			if (this._mouseMoved) {
				if (e.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
				if (!t.which)
					if (t.originalEvent.altKey || t.originalEvent.ctrlKey || t.originalEvent.metaKey || t.originalEvent.shiftKey) this.ignoreMissingWhich = !0;
					else if (!this.ignoreMissingWhich) return this._mouseUp(t)
			}
			return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
		},
		_mouseUp: function(t) {
			this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && e.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, r = !1, t.preventDefault()
		},
		_mouseDistanceMet: function(e) {
			return Math.max(Math.abs(this._mouseDownEvent.pageX - e.pageX), Math.abs(this._mouseDownEvent.pageY - e.pageY)) >= this.options.distance
		},
		_mouseDelayMet: function() {
			return this.mouseDelayMet
		},
		_mouseStart: function() {},
		_mouseDrag: function() {},
		_mouseStop: function() {},
		_mouseCapture: function() {
			return !0
		}
	}), e.widget("ui.slider", e.ui.mouse, {
		version: "1.12.1",
		widgetEventPrefix: "slide",
		options: {
			animate: !1,
			classes: {
				"ui-slider": "ui-corner-all",
				"ui-slider-handle": "ui-corner-all",
				"ui-slider-range": "ui-corner-all ui-widget-header"
			},
			distance: 0,
			max: 100,
			min: 0,
			orientation: "horizontal",
			range: !1,
			step: 1,
			value: 0,
			values: null,
			change: null,
			slide: null,
			start: null,
			stop: null
		},
		numPages: 5,
		_create: function() {
			this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1
		},
		_refresh: function() {
			this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
		},
		_createHandles: function() {
			var t, i = this.options,
				n = this.element.find(".ui-slider-handle"),
				r = [],
				o = i.values && i.values.length || 1;
			for (n.length > o && (n.slice(o).remove(), n = n.slice(0, o)), t = n.length; t < o; t++) r.push("<span tabindex='0'></span>");
			this.handles = n.add(e(r.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each((function(t) {
				e(this).data("ui-slider-handle-index", t).attr("tabIndex", 0)
			}))
		},
		_createRange: function() {
			var t = this.options;
			t.range ? (!0 === t.range && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : e.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
				left: "",
				bottom: ""
			})) : (this.range = e("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t.range && "max" !== t.range || this._addClass(this.range, "ui-slider-range-" + t.range)) : (this.range && this.range.remove(), this.range = null)
		},
		_setupEvents: function() {
			this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
		},
		_destroy: function() {
			this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy()
		},
		_mouseCapture: function(t) {
			var i, n, r, o, s, a, l = this,
				c = this.options;
			return !c.disabled && (this.elementSize = {
				width: this.element.outerWidth(),
				height: this.element.outerHeight()
			}, this.elementOffset = this.element.offset(), a = {
				x: t.pageX,
				y: t.pageY
			}, i = this._normValueFromMouse(a), n = this._valueMax() - this._valueMin() + 1, this.handles.each((function(t) {
				var s = Math.abs(i - l.values(t));
				(s < n || n === s && (t === l._lastChangedValue || l.values(t) === c.min)) && (n = s, r = e(this), o = t)
			})), !1 !== this._start(t, o) && (this._mouseSliding = !0, this._handleIndex = o, this._addClass(r, null, "ui-state-active"), r.trigger("focus"), s = r.offset(), a = !e(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = a ? {
				left: 0,
				top: 0
			} : {
				left: t.pageX - s.left - r.width() / 2,
				top: t.pageY - s.top - r.height() / 2 - (parseInt(r.css("borderTopWidth"), 10) || 0) - (parseInt(r.css("borderBottomWidth"), 10) || 0) + (parseInt(r.css("marginTop"), 10) || 0)
			}, this.handles.hasClass("ui-state-hover") || this._slide(t, o, i), this._animateOff = !0))
		},
		_mouseStart: function() {
			return !0
		},
		_mouseDrag: function(e) {
			var t = {
				x: e.pageX,
				y: e.pageY
			};
			return t = this._normValueFromMouse(t), this._slide(e, this._handleIndex, t), !1
		},
		_mouseStop: function(e) {
			return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(e, this._handleIndex), this._change(e, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1
		},
		_detectOrientation: function() {
			this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
		},
		_normValueFromMouse: function(e) {
			var t;
			return 1 < (e = (e = "horizontal" === this.orientation ? (t = this.elementSize.width, e.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (t = this.elementSize.height, e.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0))) / t) && (e = 1), e < 0 && (e = 0), "vertical" === this.orientation && (e = 1 - e), t = this._valueMax() - this._valueMin(), t = this._valueMin() + e * t, this._trimAlignValue(t)
		},
		_uiHash: function(e, t, i) {
			var n = {
				handle: this.handles[e],
				handleIndex: e,
				value: void 0 !== t ? t : this.value()
			};
			return this._hasMultipleValues() && (n.value = void 0 !== t ? t : this.values(e), n.values = i || this.values()), n
		},
		_hasMultipleValues: function() {
			return this.options.values && this.options.values.length
		},
		_start: function(e, t) {
			return this._trigger("start", e, this._uiHash(t))
		},
		_slide: function(e, t, i) {
			var n, r = this.value(),
				o = this.values();
			this._hasMultipleValues() && (n = this.values(t ? 0 : 1), r = this.values(t), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === t ? Math.min(n, i) : Math.max(n, i)), o[t] = i), i !== r && !1 !== this._trigger("slide", e, this._uiHash(t, i, o)) && (this._hasMultipleValues() ? this.values(t, i) : this.value(i))
		},
		_stop: function(e, t) {
			this._trigger("stop", e, this._uiHash(t))
		},
		_change: function(e, t) {
			this._keySliding || this._mouseSliding || (this._lastChangedValue = t, this._trigger("change", e, this._uiHash(t)))
		},
		value: function(e) {
			return arguments.length ? (this.options.value = this._trimAlignValue(e), this._refreshValue(), void this._change(null, 0)) : this._value()
		},
		values: function(t, i) {
			var n, r, o;
			if (1 < arguments.length) return this.options.values[t] = this._trimAlignValue(i), this._refreshValue(), void this._change(null, t);
			if (!arguments.length) return this._values();
			if (!e.isArray(t)) return this._hasMultipleValues() ? this._values(t) : this.value();
			for (n = this.options.values, r = t, o = 0; o < n.length; o += 1) n[o] = this._trimAlignValue(r[o]), this._change(null, o);
			this._refreshValue()
		},
		_setOption: function(t, i) {
			var n, r = 0;
			switch ("range" === t && !0 === this.options.range && ("min" === i ? (this.options.value = this._values(0), this.options.values = null) : "max" === i && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), e.isArray(this.options.values) && (r = this.options.values.length), this._super(t, i), t) {
				case "orientation":
					this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(i), this.handles.css("horizontal" === i ? "bottom" : "left", "");
					break;
				case "value":
					this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
					break;
				case "values":
					for (this._animateOff = !0, this._refreshValue(), n = r - 1; 0 <= n; n--) this._change(null, n);
					this._animateOff = !1;
					break;
				case "step":
				case "min":
				case "max":
					this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
					break;
				case "range":
					this._animateOff = !0, this._refresh(), this._animateOff = !1
			}
		},
		_setOptionDisabled: function(e) {
			this._super(e), this._toggleClass(null, "ui-state-disabled", !!e)
		},
		_value: function() {
			var e = this.options.value;
			return this._trimAlignValue(e)
		},
		_values: function(e) {
			var t, i, n;
			if (arguments.length) return t = this.options.values[e], this._trimAlignValue(t);
			if (this._hasMultipleValues()) {
				for (i = this.options.values.slice(), n = 0; n < i.length; n += 1) i[n] = this._trimAlignValue(i[n]);
				return i
			}
			return []
		},
		_trimAlignValue: function(e) {
			if (e <= this._valueMin()) return this._valueMin();
			if (e >= this._valueMax()) return this._valueMax();
			var t = 0 < this.options.step ? this.options.step : 1,
				i = (e - this._valueMin()) % t;
			return e -= i, 2 * Math.abs(i) >= t && (e += 0 < i ? t : -t), parseFloat(e.toFixed(5))
		},
		_calculateNewMax: function() {
			var e = this.options.max,
				t = this._valueMin(),
				i = this.options.step;
			(e = Math.round((e - t) / i) * i + t) > this.options.max && (e -= i), this.max = parseFloat(e.toFixed(this._precision()))
		},
		_precision: function() {
			var e = this._precisionOf(this.options.step);
			return null !== this.options.min && (e = Math.max(e, this._precisionOf(this.options.min))), e
		},
		_precisionOf: function(e) {
			var t = e.toString();
			return -1 === (e = t.indexOf(".")) ? 0 : t.length - e - 1
		},
		_valueMin: function() {
			return this.options.min
		},
		_valueMax: function() {
			return this.max
		},
		_refreshRange: function(e) {
			"vertical" === e && this.range.css({
				width: "",
				left: ""
			}), "horizontal" === e && this.range.css({
				height: "",
				bottom: ""
			})
		},
		_refreshValue: function() {
			var t, i, n, r, o, s = this.options.range,
				a = this.options,
				l = this,
				c = !this._animateOff && a.animate,
				h = {};
			this._hasMultipleValues() ? this.handles.each((function(n) {
				i = (l.values(n) - l._valueMin()) / (l._valueMax() - l._valueMin()) * 100, h["horizontal" === l.orientation ? "left" : "bottom"] = i + "%", e(this).stop(1, 1)[c ? "animate" : "css"](h, a.animate), !0 === l.options.range && ("horizontal" === l.orientation ? (0 === n && l.range.stop(1, 1)[c ? "animate" : "css"]({
					left: i + "%"
				}, a.animate), 1 === n && l.range[c ? "animate" : "css"]({
					width: i - t + "%"
				}, {
					queue: !1,
					duration: a.animate
				})) : (0 === n && l.range.stop(1, 1)[c ? "animate" : "css"]({
					bottom: i + "%"
				}, a.animate), 1 === n && l.range[c ? "animate" : "css"]({
					height: i - t + "%"
				}, {
					queue: !1,
					duration: a.animate
				}))), t = i
			})) : (n = this.value(), r = this._valueMin(), o = this._valueMax(), i = o !== r ? (n - r) / (o - r) * 100 : 0, h["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[c ? "animate" : "css"](h, a.animate), "min" === s && "horizontal" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
				width: i + "%"
			}, a.animate), "max" === s && "horizontal" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
				width: 100 - i + "%"
			}, a.animate), "min" === s && "vertical" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
				height: i + "%"
			}, a.animate), "max" === s && "vertical" === this.orientation && this.range.stop(1, 1)[c ? "animate" : "css"]({
				height: 100 - i + "%"
			}, a.animate))
		},
		_handleEvents: {
			keydown: function(t) {
				var i, n, r, o = e(t.target).data("ui-slider-handle-index");
				switch (t.keyCode) {
					case e.ui.keyCode.HOME:
					case e.ui.keyCode.END:
					case e.ui.keyCode.PAGE_UP:
					case e.ui.keyCode.PAGE_DOWN:
					case e.ui.keyCode.UP:
					case e.ui.keyCode.RIGHT:
					case e.ui.keyCode.DOWN:
					case e.ui.keyCode.LEFT:
						if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(e(t.target), null, "ui-state-active"), !1 === this._start(t, o))) return
				}
				switch (r = this.options.step, i = n = this._hasMultipleValues() ? this.values(o) : this.value(), t.keyCode) {
					case e.ui.keyCode.HOME:
						n = this._valueMin();
						break;
					case e.ui.keyCode.END:
						n = this._valueMax();
						break;
					case e.ui.keyCode.PAGE_UP:
						n = this._trimAlignValue(i + (this._valueMax() - this._valueMin()) / this.numPages);
						break;
					case e.ui.keyCode.PAGE_DOWN:
						n = this._trimAlignValue(i - (this._valueMax() - this._valueMin()) / this.numPages);
						break;
					case e.ui.keyCode.UP:
					case e.ui.keyCode.RIGHT:
						if (i === this._valueMax()) return;
						n = this._trimAlignValue(i + r);
						break;
					case e.ui.keyCode.DOWN:
					case e.ui.keyCode.LEFT:
						if (i === this._valueMin()) return;
						n = this._trimAlignValue(i - r)
				}
				this._slide(t, o, n)
			},
			keyup: function(t) {
				var i = e(t.target).data("ui-slider-handle-index");
				this._keySliding && (this._keySliding = !1, this._stop(t, i), this._change(t, i), this._removeClass(e(t.target), null, "ui-state-active"))
			}
		}
	})
})),
function() {
	"use strict";

	function e(n) {
		if (!n) throw new Error("No options passed to Waypoint constructor");
		if (!n.element) throw new Error("No element option passed to Waypoint constructor");
		if (!n.handler) throw new Error("No handler option passed to Waypoint constructor");
		this.key = "waypoint-" + t, this.options = e.Adapter.extend({}, e.defaults, n), this.element = this.options.element, this.adapter = new e.Adapter(this.element), this.callback = n.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", this.enabled = this.options.enabled, this.triggerPoint = null, this.group = e.Group.findOrCreate({
			name: this.options.group,
			axis: this.axis
		}), this.context = e.Context.findOrCreateByElement(this.options.context), e.offsetAliases[this.options.offset] && (this.options.offset = e.offsetAliases[this.options.offset]), this.group.add(this), this.context.add(this), i[this.key] = this, t += 1
	}
	var t = 0,
		i = {};
	e.prototype.queueTrigger = function(e) {
		this.group.queueTrigger(this, e)
	}, e.prototype.trigger = function(e) {
		this.enabled && this.callback && this.callback.apply(this, e)
	}, e.prototype.destroy = function() {
		this.context.remove(this), this.group.remove(this), delete i[this.key]
	}, e.prototype.disable = function() {
		return this.enabled = !1, this
	}, e.prototype.enable = function() {
		return this.context.refresh(), this.enabled = !0, this
	}, e.prototype.next = function() {
		return this.group.next(this)
	}, e.prototype.previous = function() {
		return this.group.previous(this)
	}, e.invokeAll = function(e) {
		var t = [];
		for (var n in i) t.push(i[n]);
		for (var r = 0, o = t.length; o > r; r++) t[r][e]()
	}, e.destroyAll = function() {
		e.invokeAll("destroy")
	}, e.disableAll = function() {
		e.invokeAll("disable")
	}, e.enableAll = function() {
		e.invokeAll("enable")
	}, e.refreshAll = function() {
		e.Context.refreshAll()
	}, e.viewportHeight = function() {
		return window.innerHeight || document.documentElement.clientHeight
	}, e.viewportWidth = function() {
		return document.documentElement.clientWidth
	}, e.adapters = [], e.defaults = {
		context: window,
		continuous: !0,
		enabled: !0,
		group: "default",
		horizontal: !1,
		offset: 0
	}, e.offsetAliases = {
		"bottom-in-view": function() {
			return this.context.innerHeight() - this.adapter.outerHeight()
		},
		"right-in-view": function() {
			return this.context.innerWidth() - this.adapter.outerWidth()
		}
	}, window.Waypoint = e
}(),
function() {
	"use strict";

	function e(e) {
		window.setTimeout(e, 1e3 / 60)
	}

	function t(e) {
		this.element = e, this.Adapter = r.Adapter, this.adapter = new this.Adapter(e), this.key = "waypoint-context-" + i, this.didScroll = !1, this.didResize = !1, this.oldScroll = {
			x: this.adapter.scrollLeft(),
			y: this.adapter.scrollTop()
		}, this.waypoints = {
			vertical: {},
			horizontal: {}
		}, e.waypointContextKey = this.key, n[e.waypointContextKey] = this, i += 1, this.createThrottledScrollHandler(), this.createThrottledResizeHandler()
	}
	var i = 0,
		n = {},
		r = window.Waypoint,
		o = window.onload;
	t.prototype.add = function(e) {
		var t = e.options.horizontal ? "horizontal" : "vertical";
		this.waypoints[t][e.key] = e, this.refresh()
	}, t.prototype.checkEmpty = function() {
		var e = this.Adapter.isEmptyObject(this.waypoints.horizontal),
			t = this.Adapter.isEmptyObject(this.waypoints.vertical);
		e && t && (this.adapter.off(".waypoints"), delete n[this.key])
	}, t.prototype.createThrottledResizeHandler = function() {
		function e() {
			t.handleResize(), t.didResize = !1
		}
		var t = this;
		this.adapter.on("resize.waypoints", (function() {
			t.didResize || (t.didResize = !0, r.requestAnimationFrame(e))
		}))
	}, t.prototype.createThrottledScrollHandler = function() {
		function e() {
			t.handleScroll(), t.didScroll = !1
		}
		var t = this;
		this.adapter.on("scroll.waypoints", (function() {
			(!t.didScroll || r.isTouch) && (t.didScroll = !0, r.requestAnimationFrame(e))
		}))
	}, t.prototype.handleResize = function() {
		r.Context.refreshAll()
	}, t.prototype.handleScroll = function() {
		var e = {},
			t = {
				horizontal: {
					newScroll: this.adapter.scrollLeft(),
					oldScroll: this.oldScroll.x,
					forward: "right",
					backward: "left"
				},
				vertical: {
					newScroll: this.adapter.scrollTop(),
					oldScroll: this.oldScroll.y,
					forward: "down",
					backward: "up"
				}
			};
		for (var i in t) {
			var n = t[i],
				r = n.newScroll > n.oldScroll ? n.forward : n.backward;
			for (var o in this.waypoints[i]) {
				var s = this.waypoints[i][o],
					a = n.oldScroll < s.triggerPoint,
					l = n.newScroll >= s.triggerPoint;
				(a && l || !a && !l) && (s.queueTrigger(r), e[s.group.id] = s.group)
			}
		}
		for (var c in e) e[c].flushTriggers();
		this.oldScroll = {
			x: t.horizontal.newScroll,
			y: t.vertical.newScroll
		}
	}, t.prototype.innerHeight = function() {
		return this.element == this.element.window ? r.viewportHeight() : this.adapter.innerHeight()
	}, t.prototype.remove = function(e) {
		delete this.waypoints[e.axis][e.key], this.checkEmpty()
	}, t.prototype.innerWidth = function() {
		return this.element == this.element.window ? r.viewportWidth() : this.adapter.innerWidth()
	}, t.prototype.destroy = function() {
		var e = [];
		for (var t in this.waypoints)
			for (var i in this.waypoints[t]) e.push(this.waypoints[t][i]);
		for (var n = 0, r = e.length; r > n; n++) e[n].destroy()
	}, t.prototype.refresh = function() {
		var e, t = this.element == this.element.window,
			i = t ? void 0 : this.adapter.offset(),
			n = {};
		for (var o in this.handleScroll(), e = {
				horizontal: {
					contextOffset: t ? 0 : i.left,
					contextScroll: t ? 0 : this.oldScroll.x,
					contextDimension: this.innerWidth(),
					oldScroll: this.oldScroll.x,
					forward: "right",
					backward: "left",
					offsetProp: "left"
				},
				vertical: {
					contextOffset: t ? 0 : i.top,
					contextScroll: t ? 0 : this.oldScroll.y,
					contextDimension: this.innerHeight(),
					oldScroll: this.oldScroll.y,
					forward: "down",
					backward: "up",
					offsetProp: "top"
				}
			}) {
			var s = e[o];
			for (var a in this.waypoints[o]) {
				var l, c, h, u, d = this.waypoints[o][a],
					p = d.options.offset,
					f = d.triggerPoint,
					m = 0,
					g = null == f;
				d.element !== d.element.window && (m = d.adapter.offset()[s.offsetProp]), "function" == typeof p ? p = p.apply(d) : "string" == typeof p && (p = parseFloat(p), d.options.offset.indexOf("%") > -1 && (p = Math.ceil(s.contextDimension * p / 100))), l = s.contextScroll - s.contextOffset, d.triggerPoint = m + l - p, c = f < s.oldScroll, h = d.triggerPoint >= s.oldScroll, u = !c && !h, !g && (c && h) ? (d.queueTrigger(s.backward), n[d.group.id] = d.group) : (!g && u || g && s.oldScroll >= d.triggerPoint) && (d.queueTrigger(s.forward), n[d.group.id] = d.group)
			}
		}
		return r.requestAnimationFrame((function() {
			for (var e in n) n[e].flushTriggers()
		})), this
	}, t.findOrCreateByElement = function(e) {
		return t.findByElement(e) || new t(e)
	}, t.refreshAll = function() {
		for (var e in n) n[e].refresh()
	}, t.findByElement = function(e) {
		return n[e.waypointContextKey]
	}, window.onload = function() {
		o && o(), t.refreshAll()
	}, r.requestAnimationFrame = function(t) {
		(window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || e).call(window, t)
	}, r.Context = t
}(),
function() {
	"use strict";

	function e(e, t) {
		return e.triggerPoint - t.triggerPoint
	}

	function t(e, t) {
		return t.triggerPoint - e.triggerPoint
	}

	function i(e) {
		this.name = e.name, this.axis = e.axis, this.id = this.name + "-" + this.axis, this.waypoints = [], this.clearTriggerQueues(), n[this.axis][this.name] = this
	}
	var n = {
			vertical: {},
			horizontal: {}
		},
		r = window.Waypoint;
	i.prototype.add = function(e) {
		this.waypoints.push(e)
	}, i.prototype.clearTriggerQueues = function() {
		this.triggerQueues = {
			up: [],
			down: [],
			left: [],
			right: []
		}
	}, i.prototype.flushTriggers = function() {
		for (var i in this.triggerQueues) {
			var n = this.triggerQueues[i],
				r = "up" === i || "left" === i;
			n.sort(r ? t : e);
			for (var o = 0, s = n.length; s > o; o += 1) {
				var a = n[o];
				(a.options.continuous || o === n.length - 1) && a.trigger([i])
			}
		}
		this.clearTriggerQueues()
	}, i.prototype.next = function(t) {
		this.waypoints.sort(e);
		var i = r.Adapter.inArray(t, this.waypoints);
		return i === this.waypoints.length - 1 ? null : this.waypoints[i + 1]
	}, i.prototype.previous = function(t) {
		this.waypoints.sort(e);
		var i = r.Adapter.inArray(t, this.waypoints);
		return i ? this.waypoints[i - 1] : null
	}, i.prototype.queueTrigger = function(e, t) {
		this.triggerQueues[t].push(e)
	}, i.prototype.remove = function(e) {
		var t = r.Adapter.inArray(e, this.waypoints);
		t > -1 && this.waypoints.splice(t, 1)
	}, i.prototype.first = function() {
		return this.waypoints[0]
	}, i.prototype.last = function() {
		return this.waypoints[this.waypoints.length - 1]
	}, i.findOrCreate = function(e) {
		return n[e.axis][e.name] || new i(e)
	}, r.Group = i
}(),
function() {
	"use strict";

	function e(e) {
		this.$element = t(e)
	}
	var t = window.jQuery,
		i = window.Waypoint;
	t.each(["innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop"], (function(t, i) {
		e.prototype[i] = function() {
			var e = Array.prototype.slice.call(arguments);
			return this.$element[i].apply(this.$element, e)
		}
	})), t.each(["extend", "inArray", "isEmptyObject"], (function(i, n) {
		e[n] = t[n]
	})), i.adapters.push({
		name: "jquery",
		Adapter: e
	}), i.Adapter = e
}(),
function() {
	"use strict";

	function e(e) {
		return function() {
			var i = [],
				n = arguments[0];
			return e.isFunction(arguments[0]) && ((n = e.extend({}, arguments[1])).handler = arguments[0]), this.each((function() {
				var r = e.extend({}, n, {
					element: this
				});
				"string" == typeof r.context && (r.context = e(this).closest(r.context)[0]), i.push(new t(r))
			})), i
		}
	}
	var t = window.Waypoint;
	window.jQuery && (window.jQuery.fn.waypoint = e(window.jQuery)), window.Zepto && (window.Zepto.fn.waypoint = e(window.Zepto))
}(),
/*!
 * jquery.counterup.js 1.0
 *
 * Copyright 2013, Benjamin Intal http://gambit.ph @bfintal
 * Released under the GPL v2 License
 *
 * Date: Nov 26, 2013
 */
function(e) {
	"use strict";
	e.fn.counterUp = function(t) {
		var i, n = e.extend({
			time: 400,
			delay: 10,
			offset: 100,
			beginAt: 0,
			formatter: !1,
			context: "window",
			callback: function() {}
		}, t);
		return this.each((function() {
			var t = e(this),
				r = {
					time: e(this).data("counterup-time") || n.time,
					delay: e(this).data("counterup-delay") || n.delay,
					offset: e(this).data("counterup-offset") || n.offset,
					beginAt: e(this).data("counterup-beginat") || n.beginAt,
					context: e(this).data("counterup-context") || n.context
				};
			t.waypoint((function(o) {
				! function() {
					var o = [],
						s = r.time / r.delay,
						a = e(this).attr("data-num") ? e(this).attr("data-num") : t.text(),
						l = /[0-9]+,[0-9]+/.test(a),
						c = ((a = a.replace(/,/g, "")).split(".")[1] || []).length;
					r.beginAt > a && (r.beginAt = a);
					var h = /[0-9]+:[0-9]+:[0-9]+/.test(a);
					if (h) {
						var u = a.split(":"),
							d = 1;
						for (i = 0; u.length > 0;) i += d * parseInt(u.pop(), 10), d *= 60
					}
					for (var p = s; p >= r.beginAt / a * s; p--) {
						var f = parseFloat(a / s * p).toFixed(c);
						if (h) {
							f = parseInt(i / s * p);
							var m = parseInt(f / 3600) % 24,
								g = parseInt(f / 60) % 60,
								v = parseInt(f % 60, 10);
							f = (m < 10 ? "0" + m : m) + ":" + (g < 10 ? "0" + g : g) + ":" + (v < 10 ? "0" + v : v)
						}
						if (l)
							for (;
								/(\d+)(\d{3})/.test(f.toString());) f = f.toString().replace(/(\d+)(\d{3})/, "$1,$2");
						n.formatter && (f = n.formatter.call(this, f)), o.unshift(f)
					}
					t.data("counterup-nums", o), t.text(r.beginAt);
					t.data("counterup-func", (function() {
						t.data("counterup-nums") ? (t.html(t.data("counterup-nums").shift()), t.data("counterup-nums").length ? setTimeout(t.data("counterup-func"), r.delay) : (t.data("counterup-nums", null), t.data("counterup-func", null), n.callback.call(this))) : n.callback.call(this)
					})), setTimeout(t.data("counterup-func"), r.delay)
				}(), this.destroy()
			}), {
				offset: r.offset + "%",
				context: r.context
			})
		}))
	}
}(jQuery),
function(e) {
	"function" == typeof define && define.amd ? define(["jquery"], e) : e("object" == typeof exports ? require("jquery") : window.jQuery || window.Zepto)
}((function(e) {
	var t, i, n, r, o, s, a = "Close",
		l = "BeforeClose",
		c = "MarkupParse",
		h = "Open",
		u = "Change",
		d = "mfp",
		p = ".mfp",
		f = "mfp-ready",
		m = "mfp-removing",
		g = "mfp-prevent-close",
		v = function() {},
		y = !!window.jQuery,
		b = e(window),
		w = function(e, i) {
			t.ev.on(d + e + p, i)
		},
		x = function(t, i, n, r) {
			var o = document.createElement("div");
			return o.className = "mfp-" + t, n && (o.innerHTML = n), r ? i && i.appendChild(o) : (o = e(o), i && o.appendTo(i)), o
		},
		_ = function(i, n) {
			t.ev.triggerHandler(d + i, n), t.st.callbacks && (i = i.charAt(0).toLowerCase() + i.slice(1), t.st.callbacks[i] && t.st.callbacks[i].apply(t, e.isArray(n) ? n : [n]))
		},
		E = function(i) {
			return i === s && t.currTemplate.closeBtn || (t.currTemplate.closeBtn = e(t.st.closeMarkup.replace("%title%", t.st.tClose)), s = i), t.currTemplate.closeBtn
		},
		M = function() {
			e.magnificPopup.instance || ((t = new v).init(), e.magnificPopup.instance = t)
		};
	v.prototype = {
		constructor: v,
		init: function() {
			var i = navigator.appVersion;
			t.isLowIE = t.isIE8 = document.all && !document.addEventListener, t.isAndroid = /android/gi.test(i), t.isIOS = /iphone|ipad|ipod/gi.test(i), t.supportsTransition = function() {
				var e = document.createElement("p").style,
					t = ["ms", "O", "Moz", "Webkit"];
				if (void 0 !== e.transition) return !0;
				for (; t.length;)
					if (t.pop() + "Transition" in e) return !0;
				return !1
			}(), t.probablyMobile = t.isAndroid || t.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), n = e(document), t.popupsCache = {}
		},
		open: function(i) {
			var r;
			if (!1 === i.isObj) {
				t.items = i.items.toArray(), t.index = 0;
				var s, a = i.items;
				for (r = 0; r < a.length; r++)
					if ((s = a[r]).parsed && (s = s.el[0]), s === i.el[0]) {
						t.index = r;
						break
					}
			} else t.items = e.isArray(i.items) ? i.items : [i.items], t.index = i.index || 0;
			if (!t.isOpen) {
				t.types = [], o = "", i.mainEl && i.mainEl.length ? t.ev = i.mainEl.eq(0) : t.ev = n, i.key ? (t.popupsCache[i.key] || (t.popupsCache[i.key] = {}), t.currTemplate = t.popupsCache[i.key]) : t.currTemplate = {}, t.st = e.extend(!0, {}, e.magnificPopup.defaults, i), t.fixedContentPos = "auto" === t.st.fixedContentPos ? !t.probablyMobile : t.st.fixedContentPos, t.st.modal && (t.st.closeOnContentClick = !1, t.st.closeOnBgClick = !1, t.st.showCloseBtn = !1, t.st.enableEscapeKey = !1), t.bgOverlay || (t.bgOverlay = x("bg").on("click" + p, (function() {
					t.close()
				})), t.wrap = x("wrap").attr("tabindex", -1).on("click" + p, (function(e) {
					t._checkIfClose(e.target) && t.close()
				})), t.container = x("container", t.wrap)), t.contentContainer = x("content"), t.st.preloader && (t.preloader = x("preloader", t.container, t.st.tLoading));
				var l = e.magnificPopup.modules;
				for (r = 0; r < l.length; r++) {
					var u = l[r];
					u = u.charAt(0).toUpperCase() + u.slice(1), t["init" + u].call(t)
				}
				_("BeforeOpen"), t.st.showCloseBtn && (t.st.closeBtnInside ? (w(c, (function(e, t, i, n) {
					i.close_replaceWith = E(n.type)
				})), o += " mfp-close-btn-in") : t.wrap.append(E())), t.st.alignTop && (o += " mfp-align-top"), t.fixedContentPos ? t.wrap.css({
					overflow: t.st.overflowY,
					overflowX: "hidden",
					overflowY: t.st.overflowY
				}) : t.wrap.css({
					top: b.scrollTop(),
					position: "absolute"
				}), (!1 === t.st.fixedBgPos || "auto" === t.st.fixedBgPos && !t.fixedContentPos) && t.bgOverlay.css({
					height: n.height(),
					position: "absolute"
				}), t.st.enableEscapeKey && n.on("keyup" + p, (function(e) {
					27 === e.keyCode && t.close()
				})), b.on("resize" + p, (function() {
					t.updateSize()
				})), t.st.closeOnContentClick || (o += " mfp-auto-cursor"), o && t.wrap.addClass(o);
				var d = t.wH = b.height(),
					m = {};
				if (t.fixedContentPos && t._hasScrollBar(d)) {
					var g = t._getScrollbarSize();
					g && (m.marginRight = g)
				}
				t.fixedContentPos && (t.isIE7 ? e("body, html").css("overflow", "hidden") : m.overflow = "hidden");
				var v = t.st.mainClass;
				return t.isIE7 && (v += " mfp-ie7"), v && t._addClassToMFP(v), t.updateItemHTML(), _("BuildControls"), e("html").css(m), t.bgOverlay.add(t.wrap).prependTo(t.st.prependTo || e(document.body)), t._lastFocusedEl = document.activeElement, setTimeout((function() {
					t.content ? (t._addClassToMFP(f), t._setFocus()) : t.bgOverlay.addClass(f), n.on("focusin" + p, t._onFocusIn)
				}), 16), t.isOpen = !0, t.updateSize(d), _(h), i
			}
			t.updateItemHTML()
		},
		close: function() {
			t.isOpen && (_(l), t.isOpen = !1, t.st.removalDelay && !t.isLowIE && t.supportsTransition ? (t._addClassToMFP(m), setTimeout((function() {
				t._close()
			}), t.st.removalDelay)) : t._close())
		},
		_close: function() {
			_(a);
			var i = m + " " + f + " ";
			if (t.bgOverlay.detach(), t.wrap.detach(), t.container.empty(), t.st.mainClass && (i += t.st.mainClass + " "), t._removeClassFromMFP(i), t.fixedContentPos) {
				var r = {
					marginRight: ""
				};
				t.isIE7 ? e("body, html").css("overflow", "") : r.overflow = "", e("html").css(r)
			}
			n.off("keyup.mfp focusin" + p), t.ev.off(p), t.wrap.attr("class", "mfp-wrap").removeAttr("style"), t.bgOverlay.attr("class", "mfp-bg"), t.container.attr("class", "mfp-container"), !t.st.showCloseBtn || t.st.closeBtnInside && !0 !== t.currTemplate[t.currItem.type] || t.currTemplate.closeBtn && t.currTemplate.closeBtn.detach(), t.st.autoFocusLast && t._lastFocusedEl && e(t._lastFocusedEl).focus(), t.currItem = null, t.content = null, t.currTemplate = null, t.prevHeight = 0, _("AfterClose")
		},
		updateSize: function(e) {
			if (t.isIOS) {
				var i = document.documentElement.clientWidth / window.innerWidth,
					n = window.innerHeight * i;
				t.wrap.css("height", n), t.wH = n
			} else t.wH = e || b.height();
			t.fixedContentPos || t.wrap.css("height", t.wH), _("Resize")
		},
		updateItemHTML: function() {
			var i = t.items[t.index];
			t.contentContainer.detach(), t.content && t.content.detach(), i.parsed || (i = t.parseEl(t.index));
			var n = i.type;
			if (_("BeforeChange", [t.currItem ? t.currItem.type : "", n]), t.currItem = i, !t.currTemplate[n]) {
				var o = !!t.st[n] && t.st[n].markup;
				_("FirstMarkupParse", o), t.currTemplate[n] = !o || e(o)
			}
			r && r !== i.type && t.container.removeClass("mfp-" + r + "-holder");
			var s = t["get" + n.charAt(0).toUpperCase() + n.slice(1)](i, t.currTemplate[n]);
			t.appendContent(s, n), i.preloaded = !0, _(u, i), r = i.type, t.container.prepend(t.contentContainer), _("AfterChange")
		},
		appendContent: function(e, i) {
			t.content = e, e ? t.st.showCloseBtn && t.st.closeBtnInside && !0 === t.currTemplate[i] ? t.content.find(".mfp-close").length || t.content.append(E()) : t.content = e : t.content = "", _("BeforeAppend"), t.container.addClass("mfp-" + i + "-holder"), t.contentContainer.append(t.content)
		},
		parseEl: function(i) {
			var n, r = t.items[i];
			if (r.tagName ? r = {
					el: e(r)
				} : (n = r.type, r = {
					data: r,
					src: r.src
				}), r.el) {
				for (var o = t.types, s = 0; s < o.length; s++)
					if (r.el.hasClass("mfp-" + o[s])) {
						n = o[s];
						break
					} r.src = r.el.attr("data-mfp-src"), r.src || (r.src = r.el.attr("href"))
			}
			return r.type = n || t.st.type || "inline", r.index = i, r.parsed = !0, t.items[i] = r, _("ElementParse", r), t.items[i]
		},
		addGroup: function(e, i) {
			var n = function(n) {
				n.mfpEl = this, t._openClick(n, e, i)
			};
			i || (i = {});
			var r = "click.magnificPopup";
			i.mainEl = e, i.items ? (i.isObj = !0, e.off(r).on(r, n)) : (i.isObj = !1, i.delegate ? e.off(r).on(r, i.delegate, n) : (i.items = e, e.off(r).on(r, n)))
		},
		_openClick: function(i, n, r) {
			if ((void 0 !== r.midClick ? r.midClick : e.magnificPopup.defaults.midClick) || !(2 === i.which || i.ctrlKey || i.metaKey || i.altKey || i.shiftKey)) {
				var o = void 0 !== r.disableOn ? r.disableOn : e.magnificPopup.defaults.disableOn;
				if (o)
					if (e.isFunction(o)) {
						if (!o.call(t)) return !0
					} else if (b.width() < o) return !0;
				i.type && (i.preventDefault(), t.isOpen && i.stopPropagation()), r.el = e(i.mfpEl), r.delegate && (r.items = n.find(r.delegate)), t.open(r)
			}
		},
		updateStatus: function(e, n) {
			if (t.preloader) {
				i !== e && t.container.removeClass("mfp-s-" + i), n || "loading" !== e || (n = t.st.tLoading);
				var r = {
					status: e,
					text: n
				};
				_("UpdateStatus", r), e = r.status, n = r.text, t.preloader.html(n), t.preloader.find("a").on("click", (function(e) {
					e.stopImmediatePropagation()
				})), t.container.addClass("mfp-s-" + e), i = e
			}
		},
		_checkIfClose: function(i) {
			if (!e(i).hasClass(g)) {
				var n = t.st.closeOnContentClick,
					r = t.st.closeOnBgClick;
				if (n && r) return !0;
				if (!t.content || e(i).hasClass("mfp-close") || t.preloader && i === t.preloader[0]) return !0;
				if (i === t.content[0] || e.contains(t.content[0], i)) {
					if (n) return !0
				} else if (r && e.contains(document, i)) return !0;
				return !1
			}
		},
		_addClassToMFP: function(e) {
			t.bgOverlay.addClass(e), t.wrap.addClass(e)
		},
		_removeClassFromMFP: function(e) {
			this.bgOverlay.removeClass(e), t.wrap.removeClass(e)
		},
		_hasScrollBar: function(e) {
			return (t.isIE7 ? n.height() : document.body.scrollHeight) > (e || b.height())
		},
		_setFocus: function() {
			(t.st.focus ? t.content.find(t.st.focus).eq(0) : t.wrap).focus()
		},
		_onFocusIn: function(i) {
			return i.target === t.wrap[0] || e.contains(t.wrap[0], i.target) ? void 0 : (t._setFocus(), !1)
		},
		_parseMarkup: function(t, i, n) {
			var r;
			n.data && (i = e.extend(n.data, i)), _(c, [t, i, n]), e.each(i, (function(i, n) {
				if (void 0 === n || !1 === n) return !0;
				if ((r = i.split("_")).length > 1) {
					var o = t.find(p + "-" + r[0]);
					if (o.length > 0) {
						var s = r[1];
						"replaceWith" === s ? o[0] !== n[0] && o.replaceWith(n) : "img" === s ? o.is("img") ? o.attr("src", n) : o.replaceWith(e("<img>").attr("src", n).attr("class", o.attr("class"))) : o.attr(r[1], n)
					}
				} else t.find(p + "-" + i).html(n)
			}))
		},
		_getScrollbarSize: function() {
			if (void 0 === t.scrollbarSize) {
				var e = document.createElement("div");
				e.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;", document.body.appendChild(e), t.scrollbarSize = e.offsetWidth - e.clientWidth, document.body.removeChild(e)
			}
			return t.scrollbarSize
		}
	}, e.magnificPopup = {
		instance: null,
		proto: v.prototype,
		modules: [],
		open: function(t, i) {
			return M(), (t = t ? e.extend(!0, {}, t) : {}).isObj = !0, t.index = i || 0, this.instance.open(t)
		},
		close: function() {
			return e.magnificPopup.instance && e.magnificPopup.instance.close()
		},
		registerModule: function(t, i) {
			i.options && (e.magnificPopup.defaults[t] = i.options), e.extend(this.proto, i.proto), this.modules.push(t)
		},
		defaults: {
			disableOn: 0,
			key: null,
			midClick: !1,
			mainClass: "",
			preloader: !0,
			focus: "",
			closeOnContentClick: !1,
			closeOnBgClick: !0,
			closeBtnInside: !0,
			showCloseBtn: !0,
			enableEscapeKey: !0,
			modal: !1,
			alignTop: !1,
			removalDelay: 0,
			prependTo: null,
			fixedContentPos: "auto",
			fixedBgPos: "auto",
			overflowY: "auto",
			closeMarkup: '<button title="%title%" type="button" class="mfp-close">&#215;</button>',
			tClose: "Close (Esc)",
			tLoading: "Loading...",
			autoFocusLast: !0
		}
	}, e.fn.magnificPopup = function(i) {
		M();
		var n = e(this);
		if ("string" == typeof i)
			if ("open" === i) {
				var r, o = y ? n.data("magnificPopup") : n[0].magnificPopup,
					s = parseInt(arguments[1], 10) || 0;
				o.items ? r = o.items[s] : (r = n, o.delegate && (r = r.find(o.delegate)), r = r.eq(s)), t._openClick({
					mfpEl: r
				}, n, o)
			} else t.isOpen && t[i].apply(t, Array.prototype.slice.call(arguments, 1));
		else i = e.extend(!0, {}, i), y ? n.data("magnificPopup", i) : n[0].magnificPopup = i, t.addGroup(n, i);
		return n
	};
	var S, T, A, L = "inline",
		C = function() {
			A && (T.after(A.addClass(S)).detach(), A = null)
		};
	e.magnificPopup.registerModule(L, {
		options: {
			hiddenClass: "hide",
			markup: "",
			tNotFound: "Content not found"
		},
		proto: {
			initInline: function() {
				t.types.push(L), w(a + "." + L, (function() {
					C()
				}))
			},
			getInline: function(i, n) {
				if (C(), i.src) {
					var r = t.st.inline,
						o = e(i.src);
					if (o.length) {
						var s = o[0].parentNode;
						s && s.tagName && (T || (S = r.hiddenClass, T = x(S), S = "mfp-" + S), A = o.after(T).detach().removeClass(S)), t.updateStatus("ready")
					} else t.updateStatus("error", r.tNotFound), o = e("<div>");
					return i.inlineElement = o, o
				}
				return t.updateStatus("ready"), t._parseMarkup(n, {}, i), n
			}
		}
	});
	var P, I = "ajax",
		R = function() {
			P && e(document.body).removeClass(P)
		},
		O = function() {
			R(), t.req && t.req.abort()
		};
	e.magnificPopup.registerModule(I, {
		options: {
			settings: null,
			cursor: "mfp-ajax-cur",
			tError: '<a href="%url%">The content</a> could not be loaded.'
		},
		proto: {
			initAjax: function() {
				t.types.push(I), P = t.st.ajax.cursor, w(a + "." + I, O), w("BeforeChange." + I, O)
			},
			getAjax: function(i) {
				P && e(document.body).addClass(P), t.updateStatus("loading");
				var n = e.extend({
					url: i.src,
					success: function(n, r, o) {
						var s = {
							data: n,
							xhr: o
						};
						_("ParseAjax", s), t.appendContent(e(s.data), I), i.finished = !0, R(), t._setFocus(), setTimeout((function() {
							t.wrap.addClass(f)
						}), 16), t.updateStatus("ready"), _("AjaxContentAdded")
					},
					error: function() {
						R(), i.finished = i.loadError = !0, t.updateStatus("error", t.st.ajax.tError.replace("%url%", i.src))
					}
				}, t.st.ajax.settings);
				return t.req = e.ajax(n), ""
			}
		}
	});
	var D, z = function(i) {
		if (i.data && void 0 !== i.data.title) return i.data.title;
		var n = t.st.image.titleSrc;
		if (n) {
			if (e.isFunction(n)) return n.call(t, i);
			if (i.el) return i.el.attr(n) || ""
		}
		return ""
	};
	e.magnificPopup.registerModule("image", {
		options: {
			markup: '<div class="mfp-figure"><div class="mfp-close"></div><figure><div class="mfp-img"></div><figcaption><div class="mfp-bottom-bar"><div class="mfp-title"></div><div class="mfp-counter"></div></div></figcaption></figure></div>',
			cursor: "mfp-zoom-out-cur",
			titleSrc: "title",
			verticalFit: !0,
			tError: '<a href="%url%">The image</a> could not be loaded.'
		},
		proto: {
			initImage: function() {
				var i = t.st.image,
					n = ".image";
				t.types.push("image"), w(h + n, (function() {
					"image" === t.currItem.type && i.cursor && e(document.body).addClass(i.cursor)
				})), w(a + n, (function() {
					i.cursor && e(document.body).removeClass(i.cursor), b.off("resize" + p)
				})), w("Resize" + n, t.resizeImage), t.isLowIE && w("AfterChange", t.resizeImage)
			},
			resizeImage: function() {
				var e = t.currItem;
				if (e && e.img && t.st.image.verticalFit) {
					var i = 0;
					t.isLowIE && (i = parseInt(e.img.css("padding-top"), 10) + parseInt(e.img.css("padding-bottom"), 10)), e.img.css("max-height", t.wH - i)
				}
			},
			_onImageHasSize: function(e) {
				e.img && (e.hasSize = !0, D && clearInterval(D), e.isCheckingImgSize = !1, _("ImageHasSize", e), e.imgHidden && (t.content && t.content.removeClass("mfp-loading"), e.imgHidden = !1))
			},
			findImageSize: function(e) {
				var i = 0,
					n = e.img[0],
					r = function(o) {
						D && clearInterval(D), D = setInterval((function() {
							return n.naturalWidth > 0 ? void t._onImageHasSize(e) : (i > 200 && clearInterval(D), void(3 === ++i ? r(10) : 40 === i ? r(50) : 100 === i && r(500)))
						}), o)
					};
				r(1)
			},
			getImage: function(i, n) {
				var r = 0,
					o = function() {
						i && (i.img[0].complete ? (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("ready")), i.hasSize = !0, i.loaded = !0, _("ImageLoadComplete")) : 200 > ++r ? setTimeout(o, 100) : s())
					},
					s = function() {
						i && (i.img.off(".mfploader"), i === t.currItem && (t._onImageHasSize(i), t.updateStatus("error", a.tError.replace("%url%", i.src))), i.hasSize = !0, i.loaded = !0, i.loadError = !0)
					},
					a = t.st.image,
					l = n.find(".mfp-img");
				if (l.length) {
					var c = document.createElement("img");
					c.className = "mfp-img", i.el && i.el.find("img").length && (c.alt = i.el.find("img").attr("alt")), i.img = e(c).on("load.mfploader", o).on("error.mfploader", s), c.src = i.src, l.is("img") && (i.img = i.img.clone()), (c = i.img[0]).naturalWidth > 0 ? i.hasSize = !0 : c.width || (i.hasSize = !1)
				}
				return t._parseMarkup(n, {
					title: z(i),
					img_replaceWith: i.img
				}, i), t.resizeImage(), i.hasSize ? (D && clearInterval(D), i.loadError ? (n.addClass("mfp-loading"), t.updateStatus("error", a.tError.replace("%url%", i.src))) : (n.removeClass("mfp-loading"), t.updateStatus("ready")), n) : (t.updateStatus("loading"), i.loading = !0, i.hasSize || (i.imgHidden = !0, n.addClass("mfp-loading"), t.findImageSize(i)), n)
			}
		}
	});
	var k;
	e.magnificPopup.registerModule("zoom", {
		options: {
			enabled: !1,
			easing: "ease-in-out",
			duration: 300,
			opener: function(e) {
				return e.is("img") ? e : e.find("img")
			}
		},
		proto: {
			initZoom: function() {
				var e, i = t.st.zoom,
					n = ".zoom";
				if (i.enabled && t.supportsTransition) {
					var r, o, s = i.duration,
						c = function(e) {
							var t = e.clone().removeAttr("style").removeAttr("class").addClass("mfp-animated-image"),
								n = "all " + i.duration / 1e3 + "s " + i.easing,
								r = {
									position: "fixed",
									zIndex: 9999,
									left: 0,
									top: 0,
									"-webkit-backface-visibility": "hidden"
								},
								o = "transition";
							return r["-webkit-" + o] = r["-moz-" + o] = r["-o-" + o] = r[o] = n, t.css(r), t
						},
						h = function() {
							t.content.css("visibility", "visible")
						};
					w("BuildControls" + n, (function() {
						if (t._allowZoom()) {
							if (clearTimeout(r), t.content.css("visibility", "hidden"), !(e = t._getItemToZoom())) return void h();
							(o = c(e)).css(t._getOffset()), t.wrap.append(o), r = setTimeout((function() {
								o.css(t._getOffset(!0)), r = setTimeout((function() {
									h(), setTimeout((function() {
										o.remove(), e = o = null, _("ZoomAnimationEnded")
									}), 16)
								}), s)
							}), 16)
						}
					})), w(l + n, (function() {
						if (t._allowZoom()) {
							if (clearTimeout(r), t.st.removalDelay = s, !e) {
								if (!(e = t._getItemToZoom())) return;
								o = c(e)
							}
							o.css(t._getOffset(!0)), t.wrap.append(o), t.content.css("visibility", "hidden"), setTimeout((function() {
								o.css(t._getOffset())
							}), 16)
						}
					})), w(a + n, (function() {
						t._allowZoom() && (h(), o && o.remove(), e = null)
					}))
				}
			},
			_allowZoom: function() {
				return "image" === t.currItem.type
			},
			_getItemToZoom: function() {
				return !!t.currItem.hasSize && t.currItem.img
			},
			_getOffset: function(i) {
				var n, r = (n = i ? t.currItem.img : t.st.zoom.opener(t.currItem.el || t.currItem)).offset(),
					o = parseInt(n.css("padding-top"), 10),
					s = parseInt(n.css("padding-bottom"), 10);
				r.top -= e(window).scrollTop() - o;
				var a = {
					width: n.width(),
					height: (y ? n.innerHeight() : n[0].offsetHeight) - s - o
				};
				return void 0 === k && (k = void 0 !== document.createElement("p").style.MozTransform), k ? a["-moz-transform"] = a.transform = "translate(" + r.left + "px," + r.top + "px)" : (a.left = r.left, a.top = r.top), a
			}
		}
	});
	var N = "iframe",
		B = function(e) {
			if (t.currTemplate[N]) {
				var i = t.currTemplate[N].find("iframe");
				i.length && (e || (i[0].src = "//about:blank"), t.isIE8 && i.css("display", e ? "block" : "none"))
			}
		};
	e.magnificPopup.registerModule(N, {
		options: {
			markup: '<div class="mfp-iframe-scaler"><div class="mfp-close"></div><iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe></div>',
			srcAction: "iframe_src",
			patterns: {
				youtube: {
					index: "youtube.com",
					id: "v=",
					src: "//www.youtube.com/embed/%id%?autoplay=1"
				},
				vimeo: {
					index: "vimeo.com/",
					id: "/",
					src: "//player.vimeo.com/video/%id%?autoplay=1"
				},
				gmaps: {
					index: "//maps.google.",
					src: "%id%&output=embed"
				}
			}
		},
		proto: {
			initIframe: function() {
				t.types.push(N), w("BeforeChange", (function(e, t, i) {
					t !== i && (t === N ? B() : i === N && B(!0))
				})), w(a + "." + N, (function() {
					B()
				}))
			},
			getIframe: function(i, n) {
				var r = i.src,
					o = t.st.iframe;
				e.each(o.patterns, (function() {
					return r.indexOf(this.index) > -1 ? (this.id && (r = "string" == typeof this.id ? r.substr(r.lastIndexOf(this.id) + this.id.length, r.length) : this.id.call(this, r)), r = this.src.replace("%id%", r), !1) : void 0
				}));
				var s = {};
				return o.srcAction && (s[o.srcAction] = r), t._parseMarkup(n, s, i), t.updateStatus("ready"), n
			}
		}
	});
	var H = function(e) {
			var i = t.items.length;
			return e > i - 1 ? e - i : 0 > e ? i + e : e
		},
		F = function(e, t, i) {
			return e.replace(/%curr%/gi, t + 1).replace(/%total%/gi, i)
		};
	e.magnificPopup.registerModule("gallery", {
		options: {
			enabled: !1,
			arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
			preload: [0, 2],
			navigateByImgClick: !0,
			arrows: !0,
			tPrev: "Previous (Left arrow key)",
			tNext: "Next (Right arrow key)",
			tCounter: "%curr% of %total%"
		},
		proto: {
			initGallery: function() {
				var i = t.st.gallery,
					r = ".mfp-gallery";
				return t.direction = !0, !(!i || !i.enabled) && (o += " mfp-gallery", w(h + r, (function() {
					i.navigateByImgClick && t.wrap.on("click" + r, ".mfp-img", (function() {
						return t.items.length > 1 ? (t.next(), !1) : void 0
					})), n.on("keydown" + r, (function(e) {
						37 === e.keyCode ? t.prev() : 39 === e.keyCode && t.next()
					}))
				})), w("UpdateStatus" + r, (function(e, i) {
					i.text && (i.text = F(i.text, t.currItem.index, t.items.length))
				})), w(c + r, (function(e, n, r, o) {
					var s = t.items.length;
					r.counter = s > 1 ? F(i.tCounter, o.index, s) : ""
				})), w("BuildControls" + r, (function() {
					if (t.items.length > 1 && i.arrows && !t.arrowLeft) {
						var n = i.arrowMarkup,
							r = t.arrowLeft = e(n.replace(/%title%/gi, i.tPrev).replace(/%dir%/gi, "left")).addClass(g),
							o = t.arrowRight = e(n.replace(/%title%/gi, i.tNext).replace(/%dir%/gi, "right")).addClass(g);
						r.click((function() {
							t.prev()
						})), o.click((function() {
							t.next()
						})), t.container.append(r.add(o))
					}
				})), w(u + r, (function() {
					t._preloadTimeout && clearTimeout(t._preloadTimeout), t._preloadTimeout = setTimeout((function() {
						t.preloadNearbyImages(), t._preloadTimeout = null
					}), 16)
				})), void w(a + r, (function() {
					n.off(r), t.wrap.off("click" + r), t.arrowRight = t.arrowLeft = null
				})))
			},
			next: function() {
				t.direction = !0, t.index = H(t.index + 1), t.updateItemHTML()
			},
			prev: function() {
				t.direction = !1, t.index = H(t.index - 1), t.updateItemHTML()
			},
			goTo: function(e) {
				t.direction = e >= t.index, t.index = e, t.updateItemHTML()
			},
			preloadNearbyImages: function() {
				var e, i = t.st.gallery.preload,
					n = Math.min(i[0], t.items.length),
					r = Math.min(i[1], t.items.length);
				for (e = 1; e <= (t.direction ? r : n); e++) t._preloadItem(t.index + e);
				for (e = 1; e <= (t.direction ? n : r); e++) t._preloadItem(t.index - e)
			},
			_preloadItem: function(i) {
				if (i = H(i), !t.items[i].preloaded) {
					var n = t.items[i];
					n.parsed || (n = t.parseEl(i)), _("LazyLoad", n), "image" === n.type && (n.img = e('<img class="mfp-img" />').on("load.mfploader", (function() {
						n.hasSize = !0
					})).on("error.mfploader", (function() {
						n.hasSize = !0, n.loadError = !0, _("LazyLoadError", n)
					})).attr("src", n.src)), n.preloaded = !0
				}
			}
		}
	});
	var U = "retina";
	e.magnificPopup.registerModule(U, {
		options: {
			replaceSrc: function(e) {
				return e.src.replace(/\.\w+$/, (function(e) {
					return "@2x" + e
				}))
			},
			ratio: 1
		},
		proto: {
			initRetina: function() {
				if (window.devicePixelRatio > 1) {
					var e = t.st.retina,
						i = e.ratio;
					(i = isNaN(i) ? i() : i) > 1 && (w("ImageHasSize." + U, (function(e, t) {
						t.img.css({
							"max-width": t.img[0].naturalWidth / i,
							width: "100%"
						})
					})), w("ElementParse." + U, (function(t, n) {
						n.src = e.replaceSrc(n, i)
					})))
				}
			}
		}
	}), M()
})),
function(e, t) {
	"object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e || self).Lenis = t()
}(this, (function() {
	function e(e, t) {
		for (var i = 0; i < t.length; i++) {
			var n = t[i];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, "symbol" == typeof(r = function(e, t) {
				if ("object" != typeof e || null === e) return e;
				var i = e[Symbol.toPrimitive];
				if (void 0 !== i) {
					var n = i.call(e, "string");
					if ("object" != typeof n) return n;
					throw new TypeError("@@toPrimitive must return a primitive value.")
				}
				return String(e)
			}(n.key)) ? r : String(r), n)
		}
		var r
	}

	function t(t, i, n) {
		return i && e(t.prototype, i), n && e(t, n), Object.defineProperty(t, "prototype", {
			writable: !1
		}), t
	}

	function i() {
		return (i = Object.assign ? Object.assign.bind() : function(e) {
			for (var t = 1; t < arguments.length; t++) {
				var i = arguments[t];
				for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n])
			}
			return e
		}).apply(this, arguments)
	}

	function n(e, t, i) {
		return Math.max(e, Math.min(t, i))
	}
	var r = function() {
			function e() {}
			var t = e.prototype;
			return t.advance = function(e) {
				var t, i, r, o;
				if (this.isRunning) {
					var s = !1;
					if (this.lerp) this.value = (i = this.value, r = this.to, (1 - (o = 1 - Math.exp(-60 * this.lerp * e))) * i + o * r), Math.round(this.value) === this.to && (this.value = this.to, s = !0);
					else {
						this.currentTime += e;
						var a = n(0, this.currentTime / this.duration, 1),
							l = (s = a >= 1) ? 1 : this.easing(a);
						this.value = this.from + (this.to - this.from) * l
					}
					null == (t = this.onUpdate) || t.call(this, this.value, {
						completed: s
					}), s && this.stop()
				}
			}, t.stop = function() {
				this.isRunning = !1
			}, t.fromTo = function(e, t, i) {
				var n = i.lerp,
					r = void 0 === n ? .1 : n,
					o = i.duration,
					s = void 0 === o ? 1 : o,
					a = i.easing,
					l = void 0 === a ? function(e) {
						return e
					} : a,
					c = i.onUpdate;
				this.from = this.value = e, this.to = t, this.lerp = r, this.duration = s, this.easing = l, this.currentTime = 0, this.isRunning = !0, this.onUpdate = c
			}, e
		}(),
		o = function() {
			function e(e) {
				var t, i, n = this,
					r = void 0 === e ? {} : e,
					o = r.wrapper,
					s = r.content,
					a = r.autoResize,
					l = void 0 === a || a;
				if (this.resize = function() {
						n.onWrapperResize(), n.onContentResize()
					}, this.onWrapperResize = function() {
						n.wrapper === window ? (n.width = window.innerWidth, n.height = window.innerHeight) : (n.width = n.wrapper.clientWidth, n.height = n.wrapper.clientHeight)
					}, this.onContentResize = function() {
						n.scrollHeight = n.content.scrollHeight, n.scrollWidth = n.content.scrollWidth
					}, this.wrapper = o, this.content = s, l) {
					var c = (t = this.resize, function() {
						var e = arguments,
							n = this;
						clearTimeout(i), i = setTimeout((function() {
							t.apply(n, e)
						}), 250)
					});
					this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(c), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(c), this.contentResizeObserver.observe(this.content)
				}
				this.resize()
			}
			return e.prototype.destroy = function() {
				var e, t;
				null == (e = this.wrapperResizeObserver) || e.disconnect(), null == (t = this.contentResizeObserver) || t.disconnect()
			}, t(e, [{
				key: "limit",
				get: function() {
					return {
						x: this.scrollWidth - this.width,
						y: this.scrollHeight - this.height
					}
				}
			}]), e
		}(),
		s = function() {
			function e() {
				this.events = {}
			}
			var t = e.prototype;
			return t.emit = function(e) {
				for (var t = this.events[e] || [], i = 0, n = t.length; i < n; i++) t[i].apply(t, [].slice.call(arguments, 1))
			}, t.on = function(e, t) {
				var i, n = this;
				return (null == (i = this.events[e]) ? void 0 : i.push(t)) || (this.events[e] = [t]),
					function() {
						var i;
						n.events[e] = null == (i = n.events[e]) ? void 0 : i.filter((function(e) {
							return t !== e
						}))
					}
			}, t.off = function(e, t) {
				var i;
				this.events[e] = null == (i = this.events[e]) ? void 0 : i.filter((function(e) {
					return t !== e
				}))
			}, t.destroy = function() {
				this.events = {}
			}, e
		}(),
		a = function() {
			function e(e, t) {
				var i = this,
					r = t.wheelMultiplier,
					o = void 0 === r ? 1 : r,
					a = t.touchMultiplier,
					l = void 0 === a ? 2 : a,
					c = t.normalizeWheel,
					h = void 0 !== c && c;
				this.onTouchStart = function(e) {
					var t = e.targetTouches ? e.targetTouches[0] : e,
						n = t.clientY;
					i.touchStart.x = t.clientX, i.touchStart.y = n, i.lastDelta = {
						x: 0,
						y: 0
					}
				}, this.onTouchMove = function(e) {
					var t = e.targetTouches ? e.targetTouches[0] : e,
						n = t.clientX,
						r = t.clientY,
						o = -(n - i.touchStart.x) * i.touchMultiplier,
						s = -(r - i.touchStart.y) * i.touchMultiplier;
					i.touchStart.x = n, i.touchStart.y = r, i.lastDelta = {
						x: o,
						y: s
					}, i.emitter.emit("scroll", {
						deltaX: o,
						deltaY: s,
						event: e
					})
				}, this.onTouchEnd = function(e) {
					i.emitter.emit("scroll", {
						deltaX: i.lastDelta.x,
						deltaY: i.lastDelta.y,
						event: e
					})
				}, this.onWheel = function(e) {
					var t = e.deltaX,
						r = e.deltaY;
					i.normalizeWheel && (t = n(-100, t, 100), r = n(-100, r, 100)), i.emitter.emit("scroll", {
						deltaX: t *= i.wheelMultiplier,
						deltaY: r *= i.wheelMultiplier,
						event: e
					})
				}, this.element = e, this.wheelMultiplier = o, this.touchMultiplier = l, this.normalizeWheel = h, this.touchStart = {
					x: null,
					y: null
				}, this.emitter = new s, this.element.addEventListener("wheel", this.onWheel, {
					passive: !1
				}), this.element.addEventListener("touchstart", this.onTouchStart, {
					passive: !1
				}), this.element.addEventListener("touchmove", this.onTouchMove, {
					passive: !1
				}), this.element.addEventListener("touchend", this.onTouchEnd, {
					passive: !1
				})
			}
			var t = e.prototype;
			return t.on = function(e, t) {
				return this.emitter.on(e, t)
			}, t.destroy = function() {
				this.emitter.destroy(), this.element.removeEventListener("wheel", this.onWheel, {
					passive: !1
				}), this.element.removeEventListener("touchstart", this.onTouchStart, {
					passive: !1
				}), this.element.removeEventListener("touchmove", this.onTouchMove, {
					passive: !1
				}), this.element.removeEventListener("touchend", this.onTouchEnd, {
					passive: !1
				})
			}, e
		}();
	return function() {
		function e(e) {
			var t = this,
				n = void 0 === e ? {} : e,
				l = n.wrapper,
				c = void 0 === l ? window : l,
				h = n.content,
				u = void 0 === h ? document.documentElement : h,
				d = n.wheelEventsTarget,
				p = void 0 === d ? c : d,
				f = n.smoothWheel,
				m = void 0 === f || f,
				g = n.smoothTouch,
				v = void 0 !== g && g,
				y = n.syncTouch,
				b = void 0 !== y && y,
				w = n.syncTouchLerp,
				x = void 0 === w ? .1 : w,
				_ = n.__iosNoInertiaSyncTouchLerp,
				E = void 0 === _ ? .4 : _,
				M = n.touchInertiaMultiplier,
				S = void 0 === M ? 35 : M,
				T = n.duration,
				A = n.easing,
				L = void 0 === A ? function(e) {
					return Math.min(1, 1.001 - Math.pow(2, -10 * e))
				} : A,
				C = n.lerp,
				P = void 0 === C ? T && .1 : C,
				I = n.infinite,
				R = void 0 !== I && I,
				O = n.orientation,
				D = void 0 === O ? "vertical" : O,
				z = n.gestureOrientation,
				k = void 0 === z ? "vertical" : z,
				N = n.touchMultiplier,
				B = void 0 === N ? 1 : N,
				H = n.wheelMultiplier,
				F = void 0 === H ? 1 : H,
				U = n.normalizeWheel,
				j = void 0 !== U && U,
				G = n.autoResize,
				V = void 0 === G || G;
			this.onVirtualScroll = function(e) {
				var n = e.deltaX,
					r = e.deltaY,
					o = e.event;
				if (!o.ctrlKey) {
					var s = o.type.includes("touch"),
						a = o.type.includes("wheel");
					if (!("vertical" === t.options.gestureOrientation && 0 === r || "horizontal" === t.options.gestureOrientation && 0 === n || s && "vertical" === t.options.gestureOrientation && 0 === t.scroll && !t.options.infinite && r <= 0)) {
						var l = o.composedPath();
						if (!(l = l.slice(0, l.indexOf(t.rootElement))).find((function(e) {
								var t;
								return (null == e.hasAttribute ? void 0 : e.hasAttribute("data-lenis-prevent")) || s && (null == e.hasAttribute ? void 0 : e.hasAttribute("data-lenis-prevent-touch")) || a && (null == e.hasAttribute ? void 0 : e.hasAttribute("data-lenis-prevent-wheel")) || (null == (t = e.classList) ? void 0 : t.contains("lenis"))
							})))
							if (t.isStopped || t.isLocked) o.preventDefault();
							else {
								if (t.isSmooth = (t.options.smoothTouch || t.options.syncTouch) && s || t.options.smoothWheel && a, !t.isSmooth) return t.isScrolling = !1, void t.animate.stop();
								o.preventDefault();
								var c = r;
								"both" === t.options.gestureOrientation ? c = Math.abs(r) > Math.abs(n) ? r : n : "horizontal" === t.options.gestureOrientation && (c = n);
								var h = s && t.options.syncTouch,
									u = s && "touchend" === o.type && Math.abs(c) > 1;
								u && (c = t.velocity * t.options.touchInertiaMultiplier), t.scrollTo(t.targetScroll + c, i({
									programmatic: !1
								}, h && {
									lerp: u ? t.syncTouchLerp : t.options.__iosNoInertiaSyncTouchLerp
								}))
							}
					}
				}
			}, this.onScroll = function() {
				if (!t.isScrolling) {
					var e = t.animatedScroll;
					t.animatedScroll = t.targetScroll = t.actualScroll, t.velocity = 0, t.direction = Math.sign(t.animatedScroll - e), t.emit()
				}
			}, window.lenisVersion = "1.0.23", c !== document.documentElement && c !== document.body || (c = window), this.options = {
				wrapper: c,
				content: u,
				wheelEventsTarget: p,
				smoothWheel: m,
				smoothTouch: v,
				syncTouch: b,
				syncTouchLerp: x,
				__iosNoInertiaSyncTouchLerp: E,
				touchInertiaMultiplier: S,
				duration: T,
				easing: L,
				lerp: P,
				infinite: R,
				gestureOrientation: k,
				orientation: D,
				touchMultiplier: B,
				wheelMultiplier: F,
				normalizeWheel: j,
				autoResize: V
			}, this.dimensions = new o({
				wrapper: c,
				content: u,
				autoResize: V
			}), this.rootElement.classList.add("lenis"), this.velocity = 0, this.isStopped = !1, this.isSmooth = m || v, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.animate = new r, this.emitter = new s, this.options.wrapper.addEventListener("scroll", this.onScroll, {
				passive: !1
			}), this.virtualScroll = new a(p, {
				touchMultiplier: B,
				wheelMultiplier: F,
				normalizeWheel: j
			}), this.virtualScroll.on("scroll", this.onVirtualScroll)
		}
		var l = e.prototype;
		return l.destroy = function() {
			this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onScroll, {
				passive: !1
			}), this.virtualScroll.destroy(), this.dimensions.destroy(), this.rootElement.classList.remove("lenis"), this.rootElement.classList.remove("lenis-smooth"), this.rootElement.classList.remove("lenis-scrolling"), this.rootElement.classList.remove("lenis-stopped")
		}, l.on = function(e, t) {
			return this.emitter.on(e, t)
		}, l.off = function(e, t) {
			return this.emitter.off(e, t)
		}, l.setScroll = function(e) {
			this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
		}, l.resize = function() {
			this.dimensions.resize()
		}, l.emit = function() {
			this.emitter.emit("scroll", this)
		}, l.reset = function() {
			this.isLocked = !1, this.isScrolling = !1, this.velocity = 0, this.animate.stop()
		}, l.start = function() {
			this.isStopped = !1, this.reset()
		}, l.stop = function() {
			this.isStopped = !0, this.animate.stop(), this.reset()
		}, l.raf = function(e) {
			var t = e - (this.time || e);
			this.time = e, this.animate.advance(.001 * t)
		}, l.scrollTo = function(e, t) {
			var i = this,
				r = void 0 === t ? {} : t,
				o = r.offset,
				s = void 0 === o ? 0 : o,
				a = r.immediate,
				l = void 0 !== a && a,
				c = r.lock,
				h = void 0 !== c && c,
				u = r.duration,
				d = void 0 === u ? this.options.duration : u,
				p = r.easing,
				f = void 0 === p ? this.options.easing : p,
				m = r.lerp,
				g = void 0 === m ? !d && this.options.lerp : m,
				v = r.onComplete,
				y = void 0 === v ? null : v,
				b = r.force,
				w = r.programmatic,
				x = void 0 === w || w;
			if (!this.isStopped || void 0 !== b && b) {
				if (["top", "left", "start"].includes(e)) e = 0;
				else if (["bottom", "right", "end"].includes(e)) e = this.limit;
				else {
					var _, E;
					if ("string" == typeof e ? E = document.querySelector(e) : null != (_ = e) && _.nodeType && (E = e), E) {
						if (this.options.wrapper !== window) {
							var M = this.options.wrapper.getBoundingClientRect();
							s -= this.isHorizontal ? M.left : M.top
						}
						var S = E.getBoundingClientRect();
						e = (this.isHorizontal ? S.left : S.top) + this.animatedScroll
					}
				}
				if ("number" == typeof e) {
					if (e += s, e = Math.round(e), this.options.infinite ? x && (this.targetScroll = this.animatedScroll = this.scroll) : e = n(0, e, this.limit), l) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), this.emit(), void(null == y || y());
					if (!x) {
						if (e === this.targetScroll) return;
						this.targetScroll = e
					}
					this.animate.fromTo(this.animatedScroll, e, {
						duration: d,
						easing: f,
						lerp: g,
						onUpdate: function(e, t) {
							var n = t.completed;
							h && (i.isLocked = !0), i.isScrolling = !0, i.velocity = e - i.animatedScroll, i.direction = Math.sign(i.velocity), i.animatedScroll = e, i.setScroll(i.scroll), x && (i.targetScroll = e), n && (h && (i.isLocked = !1), requestAnimationFrame((function() {
								i.isScrolling = !1
							})), i.velocity = 0, null == y || y()), i.emit()
						}
					})
				}
			}
		}, t(e, [{
			key: "rootElement",
			get: function() {
				return this.options.wrapper === window ? this.options.content : this.options.wrapper
			}
		}, {
			key: "limit",
			get: function() {
				return this.dimensions.limit[this.isHorizontal ? "x" : "y"]
			}
		}, {
			key: "isHorizontal",
			get: function() {
				return "horizontal" === this.options.orientation
			}
		}, {
			key: "actualScroll",
			get: function() {
				return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
			}
		}, {
			key: "scroll",
			get: function() {
				return this.options.infinite ? (this.animatedScroll % (e = this.limit) + e) % e : this.animatedScroll;
				var e
			}
		}, {
			key: "progress",
			get: function() {
				return 0 === this.limit ? 1 : this.scroll / this.limit
			}
		}, {
			key: "isSmooth",
			get: function() {
				return this.__isSmooth
			},
			set: function(e) {
				this.__isSmooth !== e && (this.rootElement.classList.toggle("lenis-smooth", e), this.__isSmooth = e)
			}
		}, {
			key: "isScrolling",
			get: function() {
				return this.__isScrolling
			},
			set: function(e) {
				this.__isScrolling !== e && (this.rootElement.classList.toggle("lenis-scrolling", e), this.__isScrolling = e)
			}
		}, {
			key: "isStopped",
			get: function() {
				return this.__isStopped
			},
			set: function(e) {
				this.__isStopped !== e && (this.rootElement.classList.toggle("lenis-stopped", e), this.__isStopped = e)
			}
		}, {
			key: "className",
			get: function() {
				var e = "lenis";
				return this.isStopped && (e += " lenis-stopped"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e
			}
		}]), e
	}()
})),
function(e, t) {
	"object" == typeof exports && "undefined" != typeof module ? t(exports, require("three")) : "function" == typeof define && define.amd ? define(["exports", "three"], t) : t((e = e || self).PANOLENS = {}, e.THREE)
}(this, (function(e, t) {
	function i(e) {
		this.constraints = Object.assign({
			video: {
				width: {
					ideal: 1920
				},
				height: {
					ideal: 1080
				},
				facingMode: {
					exact: "environment"
				}
			},
			audio: !1
		}, e), this.element = this.scene = this.container = null, this.devices = [], this.stream = null, this.ratioScalar = 1, this.videoDeviceIndex = 0
	}

	function n(e, i, n) {
		e = void 0 === e ? 16777215 : e, i = void 0 === i || i, n = void 0 === n ? 1500 : n, this.dpr = window.devicePixelRatio;
		var r = this.createCanvas(),
			o = r.canvas;
		r = r.context;
		var s = new t.SpriteMaterial({
			color: e,
			map: this.createCanvasTexture(o)
		});
		t.Sprite.call(this, s), this.canvasWidth = o.width, this.canvasHeight = o.height, this.context = r, this.color = e instanceof t.Color ? e : new t.Color(e), this.autoSelect = i, this.dwellTime = n, this.rippleDuration = 500, this.position.z = -10, this.center.set(.5, .5), this.scale.set(.5, .5, 1), this.callback = this.timerId = this.startTimestamp = null, this.frustumCulled = !1, this.updateCanvasArcByProgress(0)
	}

	function r(e, i, n) {
		e = void 0 === e ? 300 : e, i = i || M.Info, t.Sprite.call(this), this.type = "infospot", this.animated = void 0 === n || n, this.frustumCulled = this.isHovering = !1, this.cursorStyle = this.toPanorama = this.element = null, this.mode = E.NORMAL, this.scale.set(e, e, 1), this.rotation.y = Math.PI, this.container = null, this.originalRaycast = this.raycast, this.HANDLER_FOCUS = null, this.material.side = t.DoubleSide, this.material.depthTest = !1, this.material.transparent = !0, this.material.opacity = 0, this.scaleUpAnimation = new C.Tween, this.scaleDownAnimation = new C.Tween, n = function(i) {
			if (this.material) {
				var n = i.image.width / i.image.height,
					r = new t.Vector3;
				i.image.width = i.image.naturalWidth || 64, i.image.height = i.image.naturalHeight || 64, this.scale.set(n * e, e, 1), r.copy(this.scale), this.scaleUpAnimation = new C.Tween(this.scale).to({
					x: 1.3 * r.x,
					y: 1.3 * r.y
				}, 500).easing(C.Easing.Elastic.Out), this.scaleDownAnimation = new C.Tween(this.scale).to({
					x: r.x,
					y: r.y
				}, 500).easing(C.Easing.Elastic.Out), this.material.map = i, this.material.needsUpdate = !0
			}
		}.bind(this), this.showAnimation = new C.Tween(this.material).to({
			opacity: 1
		}, 500).onStart(this.enableRaycast.bind(this, !0)).easing(C.Easing.Quartic.Out), this.hideAnimation = new C.Tween(this.material).to({
			opacity: 0
		}, 500).onStart(this.enableRaycast.bind(this, !1)).easing(C.Easing.Quartic.Out), this.addEventListener("click", this.onClick), this.addEventListener("hover", this.onHover), this.addEventListener("hoverenter", this.onHoverStart), this.addEventListener("hoverleave", this.onHoverEnd), this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("dismiss", this.onDismiss), this.addEventListener("panolens-infospot-focus", this.setFocusMethod), T.load(i, n)
	}

	function o(e) {
		e || console.warn("PANOLENS.Widget: No container specified"), t.EventDispatcher.call(this), this.DEFAULT_TRANSITION = "all 0.27s ease", this.TOUCH_ENABLED = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch), this.PREVENT_EVENT_HANDLER = function(e) {
			e.preventDefault(), e.stopPropagation()
		}, this.container = e, this.mask = this.activeSubMenu = this.activeMainItem = this.mainMenu = this.settingElement = this.videoElement = this.fullscreenElement = this.barElement = null
	}

	function s(e, i) {
		t.Mesh.call(this, e, i), this.type = "panorama", this.ImageQualityLow = 1, this.ImageQualityFair = 2, this.ImageQualityMedium = 3, this.ImageQualityHigh = 4, this.ImageQualitySuperHigh = 5, this.animationDuration = 1e3, this.defaultInfospotSize = 350, this.container = void 0, this.loaded = !1, this.linkedSpots = [], this.isInfospotVisible = !1, this.linkingImageScale = this.linkingImageURL = void 0, this.material.side = t.BackSide, this.material.opacity = 0, this.scale.x *= -1, this.renderOrder = -1, this.active = !1, this.infospotAnimation = new C.Tween(this).to({}, this.animationDuration / 2), this.addEventListener("load", this.fadeIn.bind(this)), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("click", this.onClick.bind(this)), this.setupTransitions()
	}

	function a(e, i, n) {
		i = i || new t.SphereBufferGeometry(5e3, 60, 40), n = n || new t.MeshBasicMaterial({
			opacity: 0,
			transparent: !0
		}), s.call(this, i, n), this.src = e, this.radius = 5e3
	}

	function l() {
		var e = new t.BufferGeometry,
			i = new t.MeshBasicMaterial({
				color: 0,
				opacity: 0,
				transparent: !0
			});
		e.addAttribute("position", new t.BufferAttribute(new Float32Array, 1)), s.call(this, e, i)
	}

	function c(e) {
		e = void 0 === e ? [] : e;
		var i = Object.assign({}, t.ShaderLib.cube),
			n = new t.BoxBufferGeometry(1e4, 1e4, 1e4);
		i = new t.ShaderMaterial({
			fragmentShader: i.fragmentShader,
			vertexShader: i.vertexShader,
			uniforms: i.uniforms,
			side: t.BackSide,
			transparent: !0
		}), s.call(this, n, i), this.images = e, this.edgeLength = 1e4, this.material.uniforms.opacity.value = 0
	}

	function h() {
		for (var e = [], t = 0; 6 > t; t++) e.push(M.WhiteTile);
		c.call(this, e)
	}

	function u(e, i) {
		i = void 0 === i ? {} : i;
		var n = new t.SphereBufferGeometry(5e3, 60, 40),
			r = new t.MeshBasicMaterial({
				opacity: 0,
				transparent: !0
			});
		s.call(this, n, r), this.src = e, this.options = {
			videoElement: document.createElement("video"),
			loop: !0,
			muted: !0,
			autoplay: !1,
			playsinline: !0,
			crossOrigin: "anonymous"
		}, Object.assign(this.options, i), this.videoElement = this.options.videoElement, this.videoProgress = 0, this.radius = 5e3, this.addEventListener("leave", this.pauseVideo.bind(this)), this.addEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.addEventListener("video-toggle", this.toggleVideo.bind(this)), this.addEventListener("video-time", this.setVideoCurrentTime.bind(this))
	}

	function d(e) {
		var t;
		this._parameters = e = void 0 === e ? {} : e, this._panoId = this._zoom = null, this._panoClient = new google.maps.StreetViewService, this._total = this._count = 0, this._canvas = [], this._ctx = [], this._hc = this._wc = 0, this.result = null, this.rotation = 0, this.copyright = "", this.onPanoramaLoad = this.onSizeChange = null, this.levelsW = [1, 2, 4, 7, 13, 26], this.levelsH = [1, 1, 2, 4, 7, 13], this.widths = [416, 832, 1664, 3328, 6656, 13312], this.heights = [416, 416, 832, 1664, 3328, 6656], this.maxH = this.maxW = 6656;
		try {
			var i = document.createElement("canvas");
			(t = i.getContext("experimental-webgl")) || (t = i.getContext("webgl"))
		} catch (e) {}
		this.maxW = Math.max(t.getParameter(t.MAX_TEXTURE_SIZE), this.maxW), this.maxH = Math.max(t.getParameter(t.MAX_TEXTURE_SIZE), this.maxH)
	}

	function p(e, t) {
		a.call(this), this.panoId = e, this.gsvLoader = null, this.loadRequested = !1, this.setupGoogleMapAPI(t)
	}

	function f(e, i, n, r) {
		n = void 0 === n ? 1e4 : n, r = void 0 === r ? .5 : r, "image" === (void 0 === e ? "image" : e) && a.call(this, i, this.createGeometry(n, r), this.createMaterial(n)), this.size = n, this.ratio = r, this.EPS = 1e-6, this.frameId = null, this.dragging = !1, this.userMouse = new t.Vector2, this.quatA = new t.Quaternion, this.quatB = new t.Quaternion, this.quatCur = new t.Quaternion, this.quatSlerp = new t.Quaternion, this.vectorX = new t.Vector3(1, 0, 0), this.vectorY = new t.Vector3(0, 1, 0), this.addEventListener("window-resize", this.onWindowResize)
	}

	function m(e, t, i) {
		f.call(this, "image", e, t, i)
	}

	function g(e) {
		var n = new t.SphereBufferGeometry(5e3, 60, 40),
			r = new t.MeshBasicMaterial({
				visible: !1
			});
		s.call(this, n, r), this.media = new i(e), this.radius = 5e3, this.addEventListener("enter", this.start.bind(this)), this.addEventListener("leave", this.stop.bind(this)), this.addEventListener("panolens-container", this.onPanolensContainer.bind(this)), this.addEventListener("panolens-scene", this.onPanolensScene.bind(this))
	}

	function v(e, i) {
		function n(e) {
			if (H = !1, N = B = 0, !1 !== v.enabled) {
				if (e.preventDefault(), e.button === v.mouseButtons.ORBIT) {
					if (!0 === v.noRotate) return;
					U = F.ROTATE, y.set(e.clientX, e.clientY)
				} else if (e.button === v.mouseButtons.ZOOM) {
					if (!0 === v.noZoom) return;
					U = F.DOLLY, T.set(e.clientX, e.clientY)
				} else if (e.button === v.mouseButtons.PAN) {
					if (!0 === v.noPan) return;
					U = F.PAN, x.set(e.clientX, e.clientY)
				}
				U !== F.NONE && (document.addEventListener("mousemove", r, !1), document.addEventListener("mouseup", o, !1), v.dispatchEvent(W)), v.update()
			}
		}

		function r(e) {
			if (!1 !== v.enabled) {
				e.preventDefault();
				var t = v.domElement === document ? v.domElement.body : v.domElement;
				if (U === F.ROTATE) {
					if (!0 === v.noRotate) return;
					b.set(e.clientX, e.clientY), w.subVectors(b, y), v.rotateLeft(2 * Math.PI * w.x / t.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * w.y / t.clientHeight * v.rotateSpeed), y.copy(b), d && (N = e.clientX - d.clientX, B = e.clientY - d.clientY), d = e
				} else if (U === F.DOLLY) {
					if (!0 === v.noZoom) return;
					A.set(e.clientX, e.clientY), L.subVectors(A, T), 0 < L.y ? v.dollyIn() : 0 > L.y && v.dollyOut(), T.copy(A)
				} else if (U === F.PAN) {
					if (!0 === v.noPan) return;
					_.set(e.clientX, e.clientY), E.subVectors(_, x), v.pan(E.x, E.y), x.copy(_)
				}
				U !== F.NONE && v.update()
			}
		}

		function o() {
			H = !0, d = void 0, !1 !== v.enabled && (document.removeEventListener("mousemove", r, !1), document.removeEventListener("mouseup", o, !1), v.dispatchEvent(q), U = F.NONE)
		}

		function s(e) {
			if (!1 !== v.enabled && !0 !== v.noZoom && U === F.NONE) {
				e.preventDefault(), e.stopPropagation();
				var t = 0;
				void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), 0 < t ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 > t && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), v.update(), v.dispatchEvent(V), v.dispatchEvent(W), v.dispatchEvent(q)
			}
		}

		function a(e) {
			switch (e.keyCode) {
				case v.keys.UP:
					p = !1;
					break;
				case v.keys.BOTTOM:
					f = !1;
					break;
				case v.keys.LEFT:
					m = !1;
					break;
				case v.keys.RIGHT:
					g = !1
			}
		}

		function l(e) {
			if (!1 !== v.enabled && !0 !== v.noKeys && !0 !== v.noRotate) {
				switch (e.keyCode) {
					case v.keys.UP:
						p = !0;
						break;
					case v.keys.BOTTOM:
						f = !0;
						break;
					case v.keys.LEFT:
						m = !0;
						break;
					case v.keys.RIGHT:
						g = !0
				}(p || f || m || g) && (H = !0, p && (B = -v.rotateSpeed * v.momentumKeydownFactor), f && (B = v.rotateSpeed * v.momentumKeydownFactor), m && (N = -v.rotateSpeed * v.momentumKeydownFactor), g && (N = v.rotateSpeed * v.momentumKeydownFactor))
			}
		}

		function c(e) {
			if (H = !1, N = B = 0, !1 !== v.enabled) {
				switch (e.touches.length) {
					case 1:
						if (!0 === v.noRotate) return;
						U = F.TOUCH_ROTATE, y.set(e.touches[0].pageX, e.touches[0].pageY);
						break;
					case 2:
						if (!0 === v.noZoom) return;
						U = F.TOUCH_DOLLY;
						var t = e.touches[0].pageX - e.touches[1].pageX;
						e = e.touches[0].pageY - e.touches[1].pageY, T.set(0, Math.sqrt(t * t + e * e));
						break;
					case 3:
						if (!0 === v.noPan) return;
						U = F.TOUCH_PAN, x.set(e.touches[0].pageX, e.touches[0].pageY);
						break;
					default:
						U = F.NONE
				}
				U !== F.NONE && v.dispatchEvent(W)
			}
		}

		function h(e) {
			if (!1 !== v.enabled) {
				e.preventDefault(), e.stopPropagation();
				var t = v.domElement === document ? v.domElement.body : v.domElement;
				switch (e.touches.length) {
					case 1:
						if (!0 === v.noRotate) break;
						if (U !== F.TOUCH_ROTATE) break;
						b.set(e.touches[0].pageX, e.touches[0].pageY), w.subVectors(b, y), v.rotateLeft(2 * Math.PI * w.x / t.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * w.y / t.clientHeight * v.rotateSpeed), y.copy(b), d && (N = e.touches[0].pageX - d.pageX, B = e.touches[0].pageY - d.pageY), d = {
							pageX: e.touches[0].pageX,
							pageY: e.touches[0].pageY
						}, v.update();
						break;
					case 2:
						if (!0 === v.noZoom) break;
						if (U !== F.TOUCH_DOLLY) break;
						t = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, A.set(0, Math.sqrt(t * t + e * e)), L.subVectors(A, T), 0 > L.y ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 < L.y && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), T.copy(A), v.update(), v.dispatchEvent(V);
						break;
					case 3:
						if (!0 === v.noPan) break;
						if (U !== F.TOUCH_PAN) break;
						_.set(e.touches[0].pageX, e.touches[0].pageY), E.subVectors(_, x), v.pan(E.x, E.y), x.copy(_), v.update();
						break;
					default:
						U = F.NONE
				}
			}
		}

		function u() {
			H = !0, d = void 0, !1 !== v.enabled && (v.dispatchEvent(q), U = F.NONE)
		}
		this.object = e, this.domElement = void 0 !== i ? i : document, this.frameId = null, this.enabled = !0, this.center = this.target = new t.Vector3, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.noRotate = !1, this.rotateSpeed = -.15, this.noPan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.momentumDampingFactor = .9, this.momentumScalingFactor = -.005, this.momentumKeydownFactor = 20, this.minFov = 30, this.maxFov = 120, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.noKeys = !1, this.keys = {
			LEFT: 37,
			UP: 38,
			RIGHT: 39,
			BOTTOM: 40
		}, this.mouseButtons = {
			ORBIT: t.MOUSE.LEFT,
			ZOOM: t.MOUSE.MIDDLE,
			PAN: t.MOUSE.RIGHT
		};
		var d, p, f, m, g, v = this,
			y = new t.Vector2,
			b = new t.Vector2,
			w = new t.Vector2,
			x = new t.Vector2,
			_ = new t.Vector2,
			E = new t.Vector2,
			M = new t.Vector3,
			S = new t.Vector3,
			T = new t.Vector2,
			A = new t.Vector2,
			L = new t.Vector2,
			C = 0,
			P = 0,
			I = 0,
			R = 0,
			O = 1,
			D = new t.Vector3,
			z = new t.Vector3,
			k = new t.Quaternion,
			N = 0,
			B = 0,
			H = !1,
			F = {
				NONE: -1,
				ROTATE: 0,
				DOLLY: 1,
				PAN: 2,
				TOUCH_ROTATE: 3,
				TOUCH_DOLLY: 4,
				TOUCH_PAN: 5
			},
			U = F.NONE;
		this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom;
		var j = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)),
			G = j.clone().inverse(),
			V = {
				type: "change"
			},
			W = {
				type: "start"
			},
			q = {
				type: "end"
			};
		this.setLastQuaternion = function(e) {
			k.copy(e), v.object.quaternion.copy(e)
		}, this.getLastPosition = function() {
			return z
		}, this.rotateLeft = function(e) {
			void 0 === e && (e = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), R -= e
		}, this.rotateUp = function(e) {
			void 0 === e && (e = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), I -= e
		}, this.panLeft = function(e) {
			var t = this.object.matrix.elements;
			M.set(t[0], t[1], t[2]), M.multiplyScalar(-e), D.add(M)
		}, this.panUp = function(e) {
			var t = this.object.matrix.elements;
			M.set(t[4], t[5], t[6]), M.multiplyScalar(e), D.add(M)
		}, this.pan = function(e, i) {
			var n = v.domElement === document ? v.domElement.body : v.domElement;
			if (v.object instanceof t.PerspectiveCamera) {
				var r = v.object.position.clone().sub(v.target).length();
				r *= Math.tan(v.object.fov / 2 * Math.PI / 180), v.panLeft(2 * e * r / n.clientHeight), v.panUp(2 * i * r / n.clientHeight)
			} else v.object instanceof t.OrthographicCamera ? (v.panLeft(e * (v.object.right - v.object.left) / n.clientWidth), v.panUp(i * (v.object.top - v.object.bottom) / n.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.")
		}, this.momentum = function() {
			H && (1e-4 > Math.abs(N) && 1e-4 > Math.abs(B) ? H = !1 : (B *= this.momentumDampingFactor, N *= this.momentumDampingFactor, R -= this.momentumScalingFactor * N, I -= this.momentumScalingFactor * B))
		}, this.dollyIn = function(e) {
			void 0 === e && (e = Math.pow(.95, v.zoomSpeed)), v.object instanceof t.PerspectiveCamera ? O /= e : v.object instanceof t.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * e)), v.object.updateProjectionMatrix(), v.dispatchEvent(V)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
		}, this.dollyOut = function(e) {
			void 0 === e && (e = Math.pow(.95, v.zoomSpeed)), v.object instanceof t.PerspectiveCamera ? O *= e : v.object instanceof t.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / e)), v.object.updateProjectionMatrix(), v.dispatchEvent(V)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.")
		}, this.update = function(e) {
			var t = this.object.position;
			S.copy(t).sub(this.target), S.applyQuaternion(j), C = Math.atan2(S.x, S.z), P = Math.atan2(Math.sqrt(S.x * S.x + S.z * S.z), S.y), this.autoRotate && U === F.NONE && this.rotateLeft(2 * Math.PI / 60 / 60 * v.autoRotateSpeed), this.momentum(), C += R, P += I, C = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, C)), P = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, P)), P = Math.max(1e-7, Math.min(Math.PI - 1e-7, P));
			var i = S.length() * O;
			i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(D), S.x = i * Math.sin(P) * Math.sin(C), S.y = i * Math.cos(P), S.z = i * Math.sin(P) * Math.cos(C), S.applyQuaternion(G), t.copy(this.target).add(S), this.object.lookAt(this.target), I = R = 0, O = 1, D.set(0, 0, 0), (1e-7 < z.distanceToSquared(this.object.position) || 1e-7 < 8 * (1 - k.dot(this.object.quaternion))) && (!0 !== e && this.dispatchEvent(V), z.copy(this.object.position), k.copy(this.object.quaternion))
		}, this.reset = function() {
			U = F.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(V), this.update()
		}, this.getPolarAngle = function() {
			return P
		}, this.getAzimuthalAngle = function() {
			return C
		}, this.dispose = function() {
			this.domElement.removeEventListener("mousedown", n), this.domElement.removeEventListener("mousewheel", s), this.domElement.removeEventListener("DOMMouseScroll", s), this.domElement.removeEventListener("touchstart", c), this.domElement.removeEventListener("touchend", u), this.domElement.removeEventListener("touchmove", h), window.removeEventListener("keyup", a), window.removeEventListener("keydown", l)
		}, this.domElement.addEventListener("mousedown", n, {
			passive: !1
		}), this.domElement.addEventListener("mousewheel", s, {
			passive: !1
		}), this.domElement.addEventListener("DOMMouseScroll", s, {
			passive: !1
		}), this.domElement.addEventListener("touchstart", c, {
			passive: !1
		}), this.domElement.addEventListener("touchend", u, {
			passive: !1
		}), this.domElement.addEventListener("touchmove", h, {
			passive: !1
		}), window.addEventListener("keyup", a, {
			passive: !1
		}), window.addEventListener("keydown", l, {
			passive: !1
		}), this.update()
	}

	function y(e, i) {
		var n = this,
			r = {
				type: "change"
			},
			o = 0,
			s = 0,
			a = 0,
			l = 0;
		this.camera = e, this.camera.rotation.reorder("YXZ"), this.domElement = void 0 !== i ? i : document, this.enabled = !0, this.deviceOrientation = {}, this.alphaOffsetAngle = this.alpha = this.screenOrientation = 0;
		var c = function(e) {
				n.deviceOrientation = e
			},
			h = function() {
				n.screenOrientation = window.orientation || 0
			},
			u = function(e) {
				e.preventDefault(), e.stopPropagation(), a = e.touches[0].pageX, l = e.touches[0].pageY
			},
			d = function(e) {
				e.preventDefault(), e.stopPropagation(), o += t.Math.degToRad((e.touches[0].pageX - a) / 4), s += t.Math.degToRad((l - e.touches[0].pageY) / 4), n.updateAlphaOffsetAngle(o), a = e.touches[0].pageX, l = e.touches[0].pageY
			};
		this.connect = function() {
			h(), window.addEventListener("orientationchange", h, {
				passive: !0
			}), window.addEventListener("deviceorientation", c, {
				passive: !0
			}), window.addEventListener("deviceorientation", this.update.bind(this), {
				passive: !0
			}), n.domElement.addEventListener("touchstart", u, {
				passive: !1
			}), n.domElement.addEventListener("touchmove", d, {
				passive: !1
			}), n.enabled = !0
		}, this.disconnect = function() {
			window.removeEventListener("orientationchange", h, !1), window.removeEventListener("deviceorientation", c, !1), window.removeEventListener("deviceorientation", this.update.bind(this), !1), n.domElement.removeEventListener("touchstart", u, !1), n.domElement.removeEventListener("touchmove", d, !1), n.enabled = !1
		}, this.update = function(e) {
			if (!1 !== n.enabled) {
				var i = n.deviceOrientation.alpha ? t.Math.degToRad(n.deviceOrientation.alpha) + n.alphaOffsetAngle : 0,
					o = n.deviceOrientation.beta ? t.Math.degToRad(n.deviceOrientation.beta) : 0,
					a = n.deviceOrientation.gamma ? t.Math.degToRad(n.deviceOrientation.gamma) : 0,
					l = n.screenOrientation ? t.Math.degToRad(n.screenOrientation) : 0,
					c = n.camera.quaternion,
					h = new t.Vector3(0, 0, 1),
					u = new t.Euler,
					d = new t.Quaternion,
					p = new t.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)),
					f = new t.Quaternion,
					m = new t.Quaternion;
				if (0 == n.screenOrientation) {
					var g = new t.Vector3(1, 0, 0);
					f.setFromAxisAngle(g, -s)
				} else 180 == n.screenOrientation ? (g = new t.Vector3(1, 0, 0), f.setFromAxisAngle(g, s)) : 90 == n.screenOrientation ? (g = new t.Vector3(0, 1, 0), f.setFromAxisAngle(g, s)) : -90 == n.screenOrientation && (g = new t.Vector3(0, 1, 0), f.setFromAxisAngle(g, -s));
				p.multiply(f), p.multiply(m), u.set(o, i, -a, "YXZ"), c.setFromEuler(u), c.multiply(p), c.multiply(d.setFromAxisAngle(h, -l)), n.alpha = i, !0 !== e && n.dispatchEvent(r)
			}
		}, this.updateAlphaOffsetAngle = function(e) {
			this.alphaOffsetAngle = e, this.update()
		}, this.dispose = function() {
			this.disconnect()
		}, this.connect()
	}

	function b(e) {
		var i = new t.OrthographicCamera(-1, 1, 1, -1, 0, 1),
			n = new t.Scene,
			r = new t.StereoCamera;
		r.aspect = .5;
		var o = new t.WebGLRenderTarget(512, 512, {
			minFilter: t.LinearFilter,
			magFilter: t.NearestFilter,
			format: t.RGBAFormat
		});
		o.scissorTest = !0, o.texture.generateMipmaps = !1;
		var s = new t.Vector2(.441, .156),
			a = new t.PlaneBufferGeometry(1, 1, 10, 20).removeAttribute("normal").toNonIndexed(),
			l = a.attributes.position.array,
			c = a.attributes.uv.array;
		a.attributes.position.count *= 2, a.attributes.uv.count *= 2;
		var h = new Float32Array(2 * l.length);
		h.set(l), h.set(l, l.length);
		var u = new Float32Array(2 * c.length);
		u.set(c), u.set(c, c.length), c = new t.Vector2, l = l.length / 3;
		for (var d = 0, p = h.length / 3; d < p; d++) {
			c.x = h[3 * d], c.y = h[3 * d + 1];
			var f = c.dot(c);
			f = 1.5 + (s.x + s.y * f) * f;
			var m = d < l ? 0 : 1;
			h[3 * d] = c.x / f * 1.5 - .5 + m, h[3 * d + 1] = c.y / f * 3, u[2 * d] = .5 * (u[2 * d] + m)
		}
		a.attributes.position.array = h, a.attributes.uv.array = u, s = new t.MeshBasicMaterial({
			map: o.texture
		}), a = new t.Mesh(a, s), n.add(a), this.setSize = function(t, i) {
			e.setSize(t, i);
			var n = e.getPixelRatio();
			o.setSize(t * n, i * n)
		}, this.render = function(t, s) {
			t.updateMatrixWorld(), null === s.parent && s.updateMatrixWorld(), r.update(s), s = o.width / 2;
			var a = o.height;
			e.autoClear && e.clear(), o.scissor.set(0, 0, s, a), o.viewport.set(0, 0, s, a), e.setRenderTarget(o), e.render(t, r.cameraL), e.clearDepth(), o.scissor.set(s, 0, s, a), o.viewport.set(s, 0, s, a), e.setRenderTarget(o), e.render(t, r.cameraR), e.clearDepth(), e.setRenderTarget(null), e.render(n, i)
		}
	}

	function w(e) {
		if ((e = e || {}).controlBar = void 0 === e.controlBar || e.controlBar, e.controlButtons = e.controlButtons || ["fullscreen", "setting", "video"], e.autoHideControlBar = void 0 !== e.autoHideControlBar && e.autoHideControlBar, e.autoHideInfospot = void 0 === e.autoHideInfospot || e.autoHideInfospot, e.horizontalView = void 0 !== e.horizontalView && e.horizontalView, e.clickTolerance = e.clickTolerance || 10, e.cameraFov = e.cameraFov || 60, e.reverseDragging = e.reverseDragging || !1, e.enableReticle = e.enableReticle || !1, e.dwellTime = e.dwellTime || 1500, e.autoReticleSelect = void 0 === e.autoReticleSelect || e.autoReticleSelect, e.viewIndicator = void 0 !== e.viewIndicator && e.viewIndicator, e.indicatorSize = e.indicatorSize || 30, e.output = e.output ? e.output : "none", e.autoRotate = e.autoRotate || !1, e.autoRotateSpeed = e.autoRotateSpeed || 2, e.autoRotateActivationDuration = e.autoRotateActivationDuration || 5e3, this.options = e, e.container) {
			var i = e.container;
			i._width = i.clientWidth, i._height = i.clientHeight
		} else(i = document.createElement("div")).classList.add("panolens-container"), i.style.width = "100%", i.style.height = "100%", i._width = window.innerWidth, i._height = window.innerHeight, document.body.appendChild(i);
		this.container = i, this.camera = e.camera || new t.PerspectiveCamera(this.options.cameraFov, this.container.clientWidth / this.container.clientHeight, 1, 1e4), this.scene = e.scene || new t.Scene, this.renderer = e.renderer || new t.WebGLRenderer({
			alpha: !0,
			antialias: !1
		}), this.sceneReticle = new t.Scene, this.viewIndicatorSize = this.options.indicatorSize, this.reticle = {}, this.tempEnableReticle = this.options.enableReticle, this.mode = E.NORMAL, this.pressObject = this.pressEntityObject = this.infospot = this.hoverObject = this.widget = this.panorama = null, this.raycaster = new t.Raycaster, this.raycasterPoint = new t.Vector2, this.userMouse = new t.Vector2, this.updateCallbacks = [], this.requestAnimationId = null, this.cameraFrustum = new t.Frustum, this.cameraViewProjectionMatrix = new t.Matrix4, this.outputDivElement = this.autoRotateRequestId = null, this.touchSupported = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch, this.HANDLER_MOUSE_DOWN = this.onMouseDown.bind(this), this.HANDLER_MOUSE_UP = this.onMouseUp.bind(this), this.HANDLER_MOUSE_MOVE = this.onMouseMove.bind(this), this.HANDLER_WINDOW_RESIZE = this.onWindowResize.bind(this), this.HANDLER_KEY_DOWN = this.onKeyDown.bind(this), this.HANDLER_KEY_UP = this.onKeyUp.bind(this), this.HANDLER_TAP = this.onTap.bind(this, {
			clientX: this.container.clientWidth / 2,
			clientY: this.container.clientHeight / 2
		}), this.OUTPUT_INFOSPOT = !1, this.tweenLeftAnimation = new C.Tween, this.tweenUpAnimation = new C.Tween, this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.renderer.setClearColor(0, 0), this.renderer.autoClear = !1, this.renderer.domElement.classList.add("panolens-canvas"), this.renderer.domElement.style.display = "block", this.container.style.backgroundColor = "#000", this.container.appendChild(this.renderer.domElement), this.OrbitControls = new v(this.camera, this.container), this.OrbitControls.id = "orbit", this.OrbitControls.minDistance = 1, this.OrbitControls.noPan = !0, this.OrbitControls.autoRotate = this.options.autoRotate, this.OrbitControls.autoRotateSpeed = this.options.autoRotateSpeed, this.DeviceOrientationControls = new y(this.camera, this.container), this.DeviceOrientationControls.id = "device-orientation", this.DeviceOrientationControls.enabled = !1, this.camera.position.z = 1, this.options.passiveRendering && console.warn("passiveRendering is now deprecated"), this.controls = [this.OrbitControls, this.DeviceOrientationControls], this.control = this.OrbitControls, this.CardboardEffect = new b(this.renderer), this.CardboardEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.StereoEffect = new I(this.renderer), this.StereoEffect.setSize(this.container.clientWidth, this.container.clientHeight), this.effect = this.CardboardEffect, this.addReticle(), this.options.horizontalView && (this.OrbitControls.minPolarAngle = Math.PI / 2, this.OrbitControls.maxPolarAngle = Math.PI / 2), !1 !== this.options.controlBar && this.addDefaultControlBar(this.options.controlButtons), this.options.viewIndicator && this.addViewIndicator(), this.options.reverseDragging && this.reverseDraggingDirection(), this.options.enableReticle ? this.enableReticleControl() : this.registerMouseAndTouchEvents(), "overlay" === this.options.output && this.addOutputElement(), this.registerEventListeners(), this.animate.call(this)
	}
	var x = "^0.105.2".replace(/[^0-9.]/g, ""),
		_ = {
			ORBIT: 0,
			DEVICEORIENTATION: 1
		},
		E = {
			UNKNOWN: 0,
			NORMAL: 1,
			CARDBOARD: 2,
			STEREO: 3
		},
		M = {
			Info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC",
			Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=",
			FullscreenEnter: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=",
			FullscreenLeave: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=",
			VideoPlay: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==",
			VideoPause: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==",
			WhiteTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KAtiABQAAACRQTFRFAAAAAAAABgYGBwcHHh4eKysrx8fHy8vLzMzM7OzsAAAABgYG+q7SZgAAAAp0Uk5TAP7+/v7+/v7+/iJx/a8AAAOwSURBVHja7d0hbsNAEAVQo6SFI6XEcALDcgNLvUBvEBQVhpkWVYWlhSsVFS7t5QIshRt695lEASZP+8c7a1kzDL1fz+/zyuvzp6FbvoddrL6uDd1yGZ5eXldeb18N3fIx7A+58prmhm65DfvDcd0952lu6JabFbD/zVprZj1lzcys+fj9z8xTZtbT8rv8yWlu6BYAIgAAAAAAAAAAAABAM6QXEAEAAAAAAAAAgJ2gnaAIiIA3Q2qAGgAAAAAAAAAAAAAAAAAAAAAAAAAAQJsADkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBVlfAcZ3aeZobusUKMGBhV6KUElHGKBERJR6/fxExRkQZl9/lT8S1oVsuhqyYMmPKjCkzvfcCpsxohrwY0Q06EAEAAAAAAAAAAACgGdILiAAAAAAAAAAAwE7QTlAERMCbITVADQAAAAAAAAAAAAAAAAAAAAAAAAAAwKmwQ1ERAAAAAACPQY9BERABERABERABERABERABAAAAAAAAAICdoJ2gCIiAT2bUADVADRABEQAAQBFUBEVABERgEyvAlJm+V4ApM6bMmDJjyowpM6bMdN0LmDKjGfJiRDfoQAQAAAAAAAAAAACAZkgvIAIAAAAAAAAAADtBO0EREAFvhtQANQAAAAAAAAAAAAAAAAAAAAAAAAAAAKfCDkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBTawAU2b6XgGmzJgyY8qMKTOmzJgy03UvYMqMZsiLEd2gAxEAAAAAAAAAAAAAmiG9gAgAAAAAAAAAAOwE7QRFQAS8GVID1AAAAAAAAAAAAAAAAAAAAAAAAAAAAJwKOxQVAQAAAADwGPQYFAEREAEREAEREAEREAERAAAAAAAAAADYCdoJioAI+GRGDVAD1AAREAEAABRBRVAEREAENrECTJnpewWYMmPKjCkzpsyYMmPKTNe9gCkzmiEvRnSDDkQAAAAAAAAAAAAAaIb0AiIAAAAAAAAAALATtBMUARHwZkgNUAMAAAAAAAAAAAAAAAAAAAAAAAAAAHAq7FBUBAAAAADAY9BjUAREQAREQAREQAREQAREAAAAAAAAAABgJ2gnKAIi4JMZNUANUANEQAQAAFAEFUEREAER2MQKMGWm7xVgyowpM50PWen9ugNGXz1XaocAFgAAAABJRU5ErkJggg==",
			Setting: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC",
			ChevronRight: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+",
			Check: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=",
			ViewIndicator: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+"
		},
		S = {
			load: function(e, i, n, r) {
				var o, s, a, l;
				for (l in i = void 0 === i ? function() {} : i, n = void 0 === n ? function() {} : n, r = void 0 === r ? function() {} : r, t.Cache.enabled = !0, M) M.hasOwnProperty(l) && e === M[l] && (o = l);
				var c = t.Cache.get(o || e);
				if (void 0 !== c) return i && setTimeout((function() {
					n({
						loaded: 1,
						total: 1
					}), i(c)
				}), 0), c;
				var h = window.URL || window.webkitURL,
					u = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
				t.Cache.add(o || e, u);
				var d = function() {
					h.revokeObjectURL(u.src), i(u)
				};
				if (0 === e.indexOf("data:")) return u.addEventListener("load", d, !1), u.src = e, u;
				u.crossOrigin = void 0 !== this.crossOrigin ? this.crossOrigin : "", (o = new window.XMLHttpRequest).open("GET", e, !0), o.responseType = "arraybuffer", o.addEventListener("error", r), o.addEventListener("progress", (function(e) {
					if (e) {
						var t = e.loaded,
							i = e.total;
						e.lengthComputable && n({
							loaded: t,
							total: i
						})
					}
				})), o.addEventListener("loadend", (function(e) {
					e && (s = new Uint8Array(e.currentTarget.response), a = new window.Blob([s]), u.addEventListener("load", d, !1), u.src = h.createObjectURL(a))
				})), o.send(null)
			}
		},
		T = {
			load: function(e, i, n, r) {
				i = void 0 === i ? function() {} : i;
				var o = new t.Texture;
				return S.load(e, (function(n) {
					o.image = n, n = 0 < e.search(/\.(jpg|jpeg)$/) || 0 === e.search(/^data:image\/jpeg/), o.format = n ? t.RGBFormat : t.RGBAFormat, o.needsUpdate = !0, i(o)
				}), n, r), o
			}
		},
		A = {
			load: function(e, i, n, r) {
				var o;
				i = void 0 === i ? function() {} : i, n = void 0 === n ? function() {} : n;
				var s = new t.CubeTexture([]),
					a = 0,
					l = {},
					c = {};
				return e.map((function(e, t) {
					S.load(e, (function(e) {
						s.images[t] = e, 6 == ++a && (s.needsUpdate = !0, i(s))
					}), (function(e) {
						for (var i in l[t] = {
								loaded: e.loaded,
								total: e.total
							}, c.loaded = 0, o = c.total = 0, l) o++, c.loaded += l[i].loaded, c.total += l[i].total;
						6 > o && (c.total = c.total / o * 6), n(c)
					}), r)
				})), s
			}
		};
	i.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
		setContainer: function(e) {
			this.container = e
		},
		setScene: function(e) {
			this.scene = e
		},
		enumerateDevices: function() {
			var e = this.devices,
				t = new Promise((function(t) {
					t(e)
				}));
			return 0 < e.length ? t : window.navigator.mediaDevices.enumerateDevices()
		},
		switchNextVideoDevice: function() {
			var e = this.stop.bind(this),
				t = this.start.bind(this),
				i = this.setVideDeviceIndex.bind(this),
				n = this.videoDeviceIndex;
			this.getDevices("video").then((function(r) {
				e(), ++n >= r.length ? (i(0), n--) : i(n), t(r[n])
			}))
		},
		getDevices: function(e) {
			e = void 0 === e ? "video" : e;
			var t = this.devices;
			return this.enumerateDevices().then((function(e) {
				return e.map((function(e) {
					return t.includes(e) || t.push(e), e
				}))
			})).then((function(t) {
				var i = new RegExp(e, "i");
				return t.filter((function(e) {
					return i.test(e.kind)
				}))
			}))
		},
		getUserMedia: function(e) {
			var t = this.setMediaStream.bind(this),
				i = this.playVideo.bind(this);
			return window.navigator.mediaDevices.getUserMedia(e).then(t).then(i).catch((function(e) {
				console.warn("PANOLENS.Media: " + e)
			}))
		},
		setVideDeviceIndex: function(e) {
			this.videoDeviceIndex = e
		},
		start: function(e) {
			var t = this.constraints,
				i = this.getUserMedia.bind(this);
			return this.element = this.createVideoElement(), this.getDevices().then((function(n) {
				if (!n || 0 === n.length) throw Error("no video device found");
				return t.video.deviceId = (e || n[0]).deviceId, i(t)
			}))
		},
		stop: function() {
			var e = this.stream;
			e && e.active && (e.getTracks()[0].stop(), window.removeEventListener("resize", this.onWindowResize.bind(this)), this.stream = this.element = null)
		},
		setMediaStream: function(e) {
			this.stream = e, this.element.srcObject = e, this.scene && (this.scene.background = this.createVideoTexture()), window.addEventListener("resize", this.onWindowResize.bind(this))
		},
		playVideo: function() {
			var e = this.element;
			e && (e.play(), this.dispatchEvent({
				type: "play"
			}))
		},
		pauseVideo: function() {
			var e = this.element;
			e && (e.pause(), this.dispatchEvent({
				type: "pause"
			}))
		},
		createVideoTexture: function() {
			var e = this.element,
				i = new t.VideoTexture(e);
			return i.generateMipmaps = !1, i.minFilter = t.LinearFilter, i.magFilter = t.LinearFilter, i.format = t.RGBFormat, i.center.set(.5, .5), e.addEventListener("canplay", this.onWindowResize.bind(this)), i
		},
		createVideoElement: function() {
			var e = this.dispatchEvent.bind(this),
				t = document.createElement("video");
			return t.setAttribute("autoplay", ""), t.setAttribute("muted", ""), t.setAttribute("playsinline", ""), t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", t.style.objectPosition = "center", t.style.objectFit = "cover", t.style.display = this.scene ? "none" : "", t.addEventListener("canplay", (function() {
				return e({
					type: "canplay"
				})
			})), t
		},
		onWindowResize: function() {
			if (this.element && this.element.videoWidth && this.element.videoHeight && this.scene) {
				var e = this.container,
					t = e.clientWidth;
				e = e.clientHeight;
				var i = this.scene.background,
					n = this.element;
				n = n.videoHeight / n.videoWidth * (this.container ? t / e : 1) * this.ratioScalar, t > e ? i.repeat.set(n, 1) : i.repeat.set(1, 1 / n)
			}
		}
	}), n.prototype = Object.assign(Object.create(t.Sprite.prototype), {
		constructor: n,
		setColor: function(e) {
			this.material.color.copy(e instanceof t.Color ? e : new t.Color(e))
		},
		createCanvasTexture: function(e) {
			return (e = new t.CanvasTexture(e)).minFilter = t.LinearFilter, e.magFilter = t.LinearFilter, e.generateMipmaps = !1, e
		},
		createCanvas: function() {
			var e = document.createElement("canvas"),
				t = e.getContext("2d"),
				i = this.dpr;
			return e.width = 32 * i, e.height = 32 * i, t.scale(i, i), t.shadowBlur = 5, t.shadowColor = "rgba(200,200,200,0.9)", {
				canvas: e,
				context: t
			}
		},
		updateCanvasArcByProgress: function(e) {
			var t = this.context,
				i = this.canvasWidth,
				n = this.canvasHeight,
				r = this.material,
				o = this.dpr,
				s = e * Math.PI * 2,
				a = this.color.getStyle(),
				l = .5 * i / o;
			o = .5 * n / o, t.clearRect(0, 0, i, n), t.beginPath(), 0 === e ? (t.arc(l, o, i / 16, 0, 2 * Math.PI), t.fillStyle = a, t.fill()) : (t.arc(l, o, i / 4 - 3, -Math.PI / 2, -Math.PI / 2 + s), t.strokeStyle = a, t.lineWidth = 3, t.stroke()), t.closePath(), r.map.needsUpdate = !0
		},
		ripple: function() {
			var e = this,
				t = this.context,
				i = this.canvasWidth,
				n = this.canvasHeight,
				r = this.material,
				o = this.rippleDuration,
				s = performance.now(),
				a = this.color,
				l = this.dpr,
				c = .5 * i / l,
				h = .5 * n / l,
				u = function() {
					var d = window.requestAnimationFrame(u),
						p = (performance.now() - s) / o,
						f = 0 < 1 - p ? 1 - p : 0,
						m = p * i * .5 / l;
					t.clearRect(0, 0, i, n), t.beginPath(), t.arc(c, h, m, 0, 2 * Math.PI), t.fillStyle = "rgba(" + 255 * a.r + ", " + 255 * a.g + ", " + 255 * a.b + ", " + f + ")", t.fill(), t.closePath(), 1 <= p && (window.cancelAnimationFrame(d), e.updateCanvasArcByProgress(0), e.dispatchEvent({
						type: "reticle-ripple-end"
					})), r.map.needsUpdate = !0
				};
			this.dispatchEvent({
				type: "reticle-ripple-start"
			}), u()
		},
		show: function() {
			this.visible = !0
		},
		hide: function() {
			this.visible = !1
		},
		start: function(e) {
			this.autoSelect && (this.dispatchEvent({
				type: "reticle-start"
			}), this.startTimestamp = performance.now(), this.callback = e, this.update())
		},
		end: function() {
			this.startTimestamp && (window.cancelAnimationFrame(this.timerId), this.updateCanvasArcByProgress(0), this.startTimestamp = this.timerId = this.callback = null, this.dispatchEvent({
				type: "reticle-end"
			}))
		},
		update: function() {
			this.timerId = window.requestAnimationFrame(this.update.bind(this));
			var e = (performance.now() - this.startTimestamp) / this.dwellTime;
			this.updateCanvasArcByProgress(e), this.dispatchEvent({
				type: "reticle-update",
				progress: e
			}), 1 <= e && (window.cancelAnimationFrame(this.timerId), this.callback && this.callback(), this.end(), this.ripple())
		}
	});
	var L, C = (function(e, t) {
		(t = function() {
			this._tweens = {}, this._tweensAddedDuringUpdate = {}
		}).prototype = {
			getAll: function() {
				return Object.keys(this._tweens).map(function(e) {
					return this._tweens[e]
				}.bind(this))
			},
			removeAll: function() {
				this._tweens = {}
			},
			add: function(e) {
				this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
			},
			remove: function(e) {
				delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
			},
			update: function(e, t) {
				var n = Object.keys(this._tweens);
				if (0 === n.length) return !1;
				for (e = void 0 !== e ? e : i.now(); 0 < n.length;) {
					this._tweensAddedDuringUpdate = {};
					for (var r = 0; r < n.length; r++) {
						var o = this._tweens[n[r]];
						o && !1 === o.update(e) && (o._isPlaying = !1, t || delete this._tweens[n[r]])
					}
					n = Object.keys(this._tweensAddedDuringUpdate)
				}
				return !0
			}
		};
		var i = new t;
		i.Group = t, i._nextId = 0, i.nextId = function() {
			return i._nextId++
		}, i.now = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function() {
			var e = process.hrtime();
			return 1e3 * e[0] + e[1] / 1e6
		} : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function() {
			return (new Date).getTime()
		}, i.Tween = function(e, t) {
			this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._reversed = this._isPlaying = this._yoyo = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = i.Easing.Linear.None, this._interpolationFunction = i.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onStopCallback = this._onCompleteCallback = this._onRepeatCallback = this._onUpdateCallback = null, this._group = t || i, this._id = i.nextId()
		}, i.Tween.prototype = {
			getId: function() {
				return this._id
			},
			isPlaying: function() {
				return this._isPlaying
			},
			to: function(e, t) {
				return this._valuesEnd = Object.create(e), void 0 !== t && (this._duration = t), this
			},
			duration: function(e) {
				return this._duration = e, this
			},
			start: function(e) {
				for (var t in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== e ? "string" == typeof e ? i.now() + parseFloat(e) : e : i.now(), this._startTime += this._delayTime, this._valuesEnd) {
					if (this._valuesEnd[t] instanceof Array) {
						if (0 === this._valuesEnd[t].length) continue;
						this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
					}
					void 0 !== this._object[t] && (this._valuesStart[t] = this._object[t], 0 == this._valuesStart[t] instanceof Array && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0)
				}
				return this
			},
			stop: function() {
				return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this
			},
			end: function() {
				return this.update(1 / 0), this
			},
			stopChainedTweens: function() {
				for (var e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].stop()
			},
			group: function(e) {
				return this._group = e, this
			},
			delay: function(e) {
				return this._delayTime = e, this
			},
			repeat: function(e) {
				return this._repeat = e, this
			},
			repeatDelay: function(e) {
				return this._repeatDelayTime = e, this
			},
			yoyo: function(e) {
				return this._yoyo = e, this
			},
			easing: function(e) {
				return this._easingFunction = e, this
			},
			interpolation: function(e) {
				return this._interpolationFunction = e, this
			},
			chain: function() {
				return this._chainedTweens = arguments, this
			},
			onStart: function(e) {
				return this._onStartCallback = e, this
			},
			onUpdate: function(e) {
				return this._onUpdateCallback = e, this
			},
			onRepeat: function(e) {
				return this._onRepeatCallback = e, this
			},
			onComplete: function(e) {
				return this._onCompleteCallback = e, this
			},
			onStop: function(e) {
				return this._onStopCallback = e, this
			},
			update: function(e) {
				var t;
				if (e < this._startTime) return !0;
				!1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0);
				var i = (e - this._startTime) / this._duration;
				i = 0 === this._duration || 1 < i ? 1 : i;
				var n = this._easingFunction(i);
				for (t in this._valuesEnd)
					if (void 0 !== this._valuesStart[t]) {
						var r = this._valuesStart[t] || 0,
							o = this._valuesEnd[t];
						o instanceof Array ? this._object[t] = this._interpolationFunction(o, n) : ("string" == typeof o && (o = "+" === o.charAt(0) || "-" === o.charAt(0) ? r + parseFloat(o) : parseFloat(o)), "number" == typeof o && (this._object[t] = r + (o - r) * n))
					} if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, i), 1 === i) {
					if (!(0 < this._repeat)) {
						for (null !== this._onCompleteCallback && this._onCompleteCallback(this._object), e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].start(this._startTime + this._duration);
						return !1
					}
					for (t in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) "string" == typeof this._valuesEnd[t] && (this._valuesStartRepeat[t] += parseFloat(this._valuesEnd[t])), this._yoyo && (i = this._valuesStartRepeat[t], this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = i), this._valuesStart[t] = this._valuesStartRepeat[t];
					this._yoyo && (this._reversed = !this._reversed), this._startTime = void 0 !== this._repeatDelayTime ? e + this._repeatDelayTime : e + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object)
				}
				return !0
			}
		}, i.Easing = {
			Linear: {
				None: function(e) {
					return e
				}
			},
			Quadratic: {
				In: function(e) {
					return e * e
				},
				Out: function(e) {
					return e * (2 - e)
				},
				InOut: function(e) {
					return 1 > (e *= 2) ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
				}
			},
			Cubic: {
				In: function(e) {
					return e * e * e
				},
				Out: function(e) {
					return --e * e * e + 1
				},
				InOut: function(e) {
					return 1 > (e *= 2) ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
				}
			},
			Quartic: {
				In: function(e) {
					return e * e * e * e
				},
				Out: function(e) {
					return 1 - --e * e * e * e
				},
				InOut: function(e) {
					return 1 > (e *= 2) ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
				}
			},
			Quintic: {
				In: function(e) {
					return e * e * e * e * e
				},
				Out: function(e) {
					return --e * e * e * e * e + 1
				},
				InOut: function(e) {
					return 1 > (e *= 2) ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
				}
			},
			Sinusoidal: {
				In: function(e) {
					return 1 - Math.cos(e * Math.PI / 2)
				},
				Out: function(e) {
					return Math.sin(e * Math.PI / 2)
				},
				InOut: function(e) {
					return .5 * (1 - Math.cos(Math.PI * e))
				}
			},
			Exponential: {
				In: function(e) {
					return 0 === e ? 0 : Math.pow(1024, e - 1)
				},
				Out: function(e) {
					return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
				},
				InOut: function(e) {
					return 0 === e ? 0 : 1 === e ? 1 : 1 > (e *= 2) ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
				}
			},
			Circular: {
				In: function(e) {
					return 1 - Math.sqrt(1 - e * e)
				},
				Out: function(e) {
					return Math.sqrt(1 - --e * e)
				},
				InOut: function(e) {
					return 1 > (e *= 2) ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
				}
			},
			Elastic: {
				In: function(e) {
					return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
				},
				Out: function(e) {
					return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
				},
				InOut: function(e) {
					return 0 === e ? 0 : 1 === e ? 1 : 1 > (e *= 2) ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
				}
			},
			Back: {
				In: function(e) {
					return e * e * (2.70158 * e - 1.70158)
				},
				Out: function(e) {
					return --e * e * (2.70158 * e + 1.70158) + 1
				},
				InOut: function(e) {
					return 1 > (e *= 2) ? .5 * e * e * (3.5949095 * e - 2.5949095) : .5 * ((e -= 2) * e * (3.5949095 * e + 2.5949095) + 2)
				}
			},
			Bounce: {
				In: function(e) {
					return 1 - i.Easing.Bounce.Out(1 - e)
				},
				Out: function(e) {
					return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
				},
				InOut: function(e) {
					return .5 > e ? .5 * i.Easing.Bounce.In(2 * e) : .5 * i.Easing.Bounce.Out(2 * e - 1) + .5
				}
			}
		}, i.Interpolation = {
			Linear: function(e, t) {
				var n = e.length - 1,
					r = n * t,
					o = Math.floor(r),
					s = i.Interpolation.Utils.Linear;
				return 0 > t ? s(e[0], e[1], r) : 1 < t ? s(e[n], e[n - 1], n - r) : s(e[o], e[o + 1 > n ? n : o + 1], r - o)
			},
			Bezier: function(e, t) {
				for (var n = 0, r = e.length - 1, o = Math.pow, s = i.Interpolation.Utils.Bernstein, a = 0; a <= r; a++) n += o(1 - t, r - a) * o(t, a) * e[a] * s(r, a);
				return n
			},
			CatmullRom: function(e, t) {
				var n = e.length - 1,
					r = n * t,
					o = Math.floor(r),
					s = i.Interpolation.Utils.CatmullRom;
				return e[0] === e[n] ? (0 > t && (o = Math.floor(r = n * (1 + t))), s(e[(o - 1 + n) % n], e[o], e[(o + 1) % n], e[(o + 2) % n], r - o)) : 0 > t ? e[0] - (s(e[0], e[0], e[1], e[1], -r) - e[0]) : 1 < t ? e[n] - (s(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : s(e[o ? o - 1 : 0], e[o], e[n < o + 1 ? n : o + 1], e[n < o + 2 ? n : o + 2], r - o)
			},
			Utils: {
				Linear: function(e, t, i) {
					return (t - e) * i + e
				},
				Bernstein: function(e, t) {
					var n = i.Interpolation.Utils.Factorial;
					return n(e) / n(t) / n(e - t)
				},
				Factorial: function() {
					var e = [1];
					return function(t) {
						var i = 1;
						if (e[t]) return e[t];
						for (var n = t; 1 < n; n--) i *= n;
						return e[t] = i
					}
				}(),
				CatmullRom: function(e, t, i, n, r) {
					var o = r * r;
					return (2 * t - 2 * i + (e = .5 * (i - e)) + (n = .5 * (n - t))) * r * o + (-3 * t + 3 * i - 2 * e - n) * o + e * r + t
				}
			}
		}, e.exports = i
	}(L = {
		exports: {}
	}, L.exports), L.exports);
	r.prototype = Object.assign(Object.create(t.Sprite.prototype), {
		constructor: r,
		setContainer: function(e) {
			if (e instanceof HTMLElement) var t = e;
			else e && e.container && (t = e.container);
			t && this.element && t.appendChild(this.element), this.container = t
		},
		getContainer: function() {
			return this.container
		},
		onClick: function(e) {
			this.element && this.getContainer() && (this.onHoverStart(e), this.lockHoverElement())
		},
		onDismiss: function() {
			this.element && (this.unlockHoverElement(), this.onHoverEnd())
		},
		onHover: function() {},
		onHoverStart: function(e) {
			if (this.getContainer()) {
				var t = this.cursorStyle || (this.mode === E.NORMAL ? "pointer" : "default"),
					i = this.scaleDownAnimation,
					n = this.scaleUpAnimation,
					r = this.element;
				this.isHovering = !0, this.container.style.cursor = t, this.animated && (i.stop(), n.start()), r && 0 <= e.mouseEvent.clientX && 0 <= e.mouseEvent.clientY && (e = r.left, t = r.right, i = r.style, this.mode === E.CARDBOARD || this.mode === E.STEREO ? (i.display = "none", e.style.display = "block", t.style.display = "block", r._width = e.clientWidth, r._height = e.clientHeight) : (i.display = "block", e && (e.style.display = "none"), t && (t.style.display = "none"), r._width = r.clientWidth, r._height = r.clientHeight))
			}
		},
		onHoverEnd: function() {
			if (this.getContainer()) {
				var e = this.scaleDownAnimation,
					t = this.scaleUpAnimation,
					i = this.element;
				this.isHovering = !1, this.container.style.cursor = "default", this.animated && (t.stop(), e.start()), i && !this.element.locked && (e = i.left, t = i.right, i.style.display = "none", e && (e.style.display = "none"), t && (t.style.display = "none"), this.unlockHoverElement())
			}
		},
		onDualEyeEffect: function(e) {
			if (this.getContainer()) {
				this.mode = e.mode, e = this.element;
				var t = this.container.clientWidth / 2,
					i = this.container.clientHeight / 2;
				e && (e.left || e.right || (e.left = e.cloneNode(!0), e.right = e.cloneNode(!0)), this.mode === E.CARDBOARD || this.mode === E.STEREO ? (e.left.style.display = e.style.display, e.right.style.display = e.style.display, e.style.display = "none") : (e.style.display = e.left.style.display, e.left.style.display = "none", e.right.style.display = "none"), this.translateElement(t, i), this.container.appendChild(e.left), this.container.appendChild(e.right))
			}
		},
		translateElement: function(e, t) {
			if (this.element._width && this.element._height && this.getContainer()) {
				var i = this.container,
					n = this.element,
					r = n._width / 2,
					o = n._height / 2,
					s = void 0 !== n.verticalDelta ? n.verticalDelta : 40,
					a = e - r,
					l = t - o - s;
				this.mode !== E.CARDBOARD && this.mode !== E.STEREO || !n.left || !n.right || e === i.clientWidth / 2 && t === i.clientHeight / 2 ? this.setElementStyle("transform", n, "translate(" + a + "px, " + l + "px)") : (a = i.clientWidth / 4 - r + (e - i.clientWidth / 2), l = i.clientHeight / 2 - o - s + (t - i.clientHeight / 2), this.setElementStyle("transform", n.left, "translate(" + a + "px, " + l + "px)"), a += i.clientWidth / 2, this.setElementStyle("transform", n.right, "translate(" + a + "px, " + l + "px)"))
			}
		},
		setElementStyle: function(e, t, i) {
			t = t.style, "transform" === e && (t.webkitTransform = t.msTransform = t.transform = i)
		},
		setText: function(e) {
			this.element && (this.element.textContent = e)
		},
		setCursorHoverStyle: function(e) {
			this.cursorStyle = e
		},
		addHoverText: function(e, t) {
			t = void 0 === t ? 40 : t, this.element || (this.element = document.createElement("div"), this.element.style.display = "none", this.element.style.color = "#fff", this.element.style.top = 0, this.element.style.maxWidth = "50%", this.element.style.maxHeight = "50%", this.element.style.textShadow = "0 0 3px #000000", this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif', this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = t), this.setText(e)
		},
		addHoverElement: function(e, t) {
			t = void 0 === t ? 40 : t, this.element || (this.element = e.cloneNode(!0), this.element.style.display = "none", this.element.style.top = 0, this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = t)
		},
		removeHoverElement: function() {
			this.element && (this.element.left && (this.container.removeChild(this.element.left), this.element.left = null), this.element.right && (this.container.removeChild(this.element.right), this.element.right = null), this.container.removeChild(this.element), this.element = null)
		},
		lockHoverElement: function() {
			this.element && (this.element.locked = !0)
		},
		unlockHoverElement: function() {
			this.element && (this.element.locked = !1)
		},
		enableRaycast: function(e) {
			this.raycast = void 0 === e || e ? this.originalRaycast : function() {}
		},
		show: function(e) {
			e = void 0 === e ? 0 : e;
			var t = this.hideAnimation,
				i = this.showAnimation,
				n = this.material;
			this.animated ? (t.stop(), i.delay(e).start()) : (this.enableRaycast(!0), n.opacity = 1)
		},
		hide: function(e) {
			e = void 0 === e ? 0 : e;
			var t = this.hideAnimation,
				i = this.showAnimation,
				n = this.material;
			this.animated ? (i.stop(), t.delay(e).start()) : (this.enableRaycast(!1), n.opacity = 0)
		},
		setFocusMethod: function(e) {
			e && (this.HANDLER_FOCUS = e.method)
		},
		focus: function(e, t) {
			this.HANDLER_FOCUS && (this.HANDLER_FOCUS(this.position, e, t), this.onDismiss())
		},
		dispose: function() {
			var e = this.geometry,
				t = this.material,
				i = t.map;
			this.removeHoverElement(), this.parent && this.parent.remove(this), i && (i.dispose(), t.map = null), e && (e.dispose(), this.geometry = null), t && (t.dispose(), this.material = null)
		}
	}), o.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
		constructor: o,
		addControlBar: function() {
			if (this.container) {
				var e, t, i = this,
					n = document.createElement("div");
				n.style.width = "100%", n.style.height = "44px", n.style.float = "left", n.style.transform = n.style.webkitTransform = n.style.msTransform = "translateY(-100%)", n.style.background = "-webkit-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-moz-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-o-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "-ms-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.background = "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", n.style.transition = this.DEFAULT_TRANSITION, n.style.pointerEvents = "none", n.isHidden = !1, n.toggle = function() {
					n.isHidden = !n.isHidden, e = n.isHidden ? "translateY(0)" : "translateY(-100%)", t = n.isHidden ? 0 : 1, n.style.transform = n.style.webkitTransform = n.style.msTransform = e, n.style.opacity = t
				};
				var r = this.createDefaultMenu();
				this.mainMenu = this.createMainMenu(r), n.appendChild(this.mainMenu), this.mask = r = this.createMask(), this.container.appendChild(r), n.dispose = function() {
					i.fullscreenElement && (n.removeChild(i.fullscreenElement), i.fullscreenElement.dispose(), i.fullscreenElement = null), i.settingElement && (n.removeChild(i.settingElement), i.settingElement.dispose(), i.settingElement = null), i.videoElement && (n.removeChild(i.videoElement), i.videoElement.dispose(), i.videoElement = null)
				}, this.container.appendChild(n), this.mask.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", (function(e) {
					e.preventDefault(), e.stopPropagation(), i.mask.hide(), i.settingElement.deactivate()
				}), !1), this.addEventListener("control-bar-toggle", n.toggle), this.barElement = n
			} else console.warn("Widget container not set")
		},
		createDefaultMenu: function() {
			var e = this,
				t = function(t, i) {
					return function() {
						e.dispatchEvent({
							type: "panolens-viewer-handler",
							method: t,
							data: i
						})
					}
				};
			return [{
				title: "Control",
				subMenu: [{
					title: this.TOUCH_ENABLED ? "Touch" : "Mouse",
					handler: t("enableControl", _.ORBIT)
				}, {
					title: "Sensor",
					handler: t("enableControl", _.DEVICEORIENTATION)
				}]
			}, {
				title: "Mode",
				subMenu: [{
					title: "Normal",
					handler: t("disableEffect")
				}, {
					title: "Cardboard",
					handler: t("enableEffect", E.CARDBOARD)
				}, {
					title: "Stereoscopic",
					handler: t("enableEffect", E.STEREO)
				}]
			}]
		},
		addControlButton: function(e) {
			switch (e) {
				case "fullscreen":
					this.fullscreenElement = e = this.createFullscreenButton();
					break;
				case "setting":
					this.settingElement = e = this.createSettingButton();
					break;
				case "video":
					this.videoElement = e = this.createVideoControl();
					break;
				default:
					return
			}
			e && this.barElement.appendChild(e)
		},
		createMask: function() {
			var e = document.createElement("div");
			return e.style.position = "absolute", e.style.top = 0, e.style.left = 0, e.style.width = "100%", e.style.height = "100%", e.style.background = "transparent", e.style.display = "none", e.show = function() {
				this.style.display = "block"
			}, e.hide = function() {
				this.style.display = "none"
			}, e
		},
		createSettingButton: function() {
			var e = this,
				t = this.createCustomItem({
					style: {
						backgroundImage: 'url("' + M.Setting + '")',
						webkitTransition: this.DEFAULT_TRANSITION,
						transition: this.DEFAULT_TRANSITION
					},
					onTap: function(t) {
						t.preventDefault(), t.stopPropagation(), e.mainMenu.toggle(), this.activated ? this.deactivate() : this.activate()
					}
				});
			return t.activate = function() {
				this.style.transform = "rotate3d(0,0,1,90deg)", this.activated = !0, e.mask.show()
			}, t.deactivate = function() {
				this.style.transform = "rotate3d(0,0,0,0)", this.activated = !1, e.mask.hide(), e.mainMenu && e.mainMenu.visible && e.mainMenu.hide(), e.activeSubMenu && e.activeSubMenu.visible && e.activeSubMenu.hide(), e.mainMenu && e.mainMenu._width && (e.mainMenu.changeSize(e.mainMenu._width), e.mainMenu.unslideAll())
			}, t.activated = !1, t
		},
		createFullscreenButton: function() {
			function e() {
				n && (i = !i, o.style.backgroundImage = i ? 'url("' + M.FullscreenLeave + '")' : 'url("' + M.FullscreenEnter + '")'), t.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "onWindowResize"
				}), n = !0
			}
			var t = this,
				i = !1,
				n = !0,
				r = this.container;
			if (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) {
				document.addEventListener("fullscreenchange", e, !1), document.addEventListener("webkitfullscreenchange", e, !1), document.addEventListener("mozfullscreenchange", e, !1), document.addEventListener("MSFullscreenChange", e, !1);
				var o = this.createCustomItem({
					style: {
						backgroundImage: 'url("' + M.FullscreenEnter + '")'
					},
					onTap: function(e) {
						e.preventDefault(), e.stopPropagation(), n = !1, i ? (document.exitFullscreen && document.exitFullscreen(), document.msExitFullscreen && document.msExitFullscreen(), document.mozCancelFullScreen && document.mozCancelFullScreen(), document.webkitExitFullscreen && document.webkitExitFullscreen(), i = !1) : (r.requestFullscreen && r.requestFullscreen(), r.msRequestFullscreen && r.msRequestFullscreen(), r.mozRequestFullScreen && r.mozRequestFullScreen(), r.webkitRequestFullscreen && r.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT), i = !0), this.style.backgroundImage = i ? 'url("' + M.FullscreenLeave + '")' : 'url("' + M.FullscreenEnter + '")'
					}
				});
				if (!document.querySelector("panolens-style-addon")) {
					var s = document.createElement("style");
					s.id = "panolens-style-addon", s.innerHTML = ":-webkit-full-screen { width: 100% !important; height: 100% !important }", document.body.appendChild(s)
				}
				return o
			}
		},
		createVideoControl: function() {
			var e = document.createElement("span");
			return e.style.display = "none", e.show = function() {
				e.style.display = ""
			}, e.hide = function() {
				e.style.display = "none", e.controlButton.paused = !0, e.controlButton.update()
			}, e.controlButton = this.createVideoControlButton(), e.seekBar = this.createVideoControlSeekbar(), e.appendChild(e.controlButton), e.appendChild(e.seekBar), e.dispose = function() {
				e.removeChild(e.controlButton), e.removeChild(e.seekBar), e.controlButton.dispose(), e.controlButton = null, e.seekBar.dispose(), e.seekBar = null
			}, this.addEventListener("video-control-show", e.show), this.addEventListener("video-control-hide", e.hide), e
		},
		createVideoControlButton: function() {
			var e = this,
				t = this.createCustomItem({
					style: {
						float: "left",
						backgroundImage: 'url("' + M.VideoPlay + '")'
					},
					onTap: function(i) {
						i.preventDefault(), i.stopPropagation(), e.dispatchEvent({
							type: "panolens-viewer-handler",
							method: "toggleVideoPlay",
							data: !this.paused
						}), this.paused = !this.paused, t.update()
					}
				});
			return t.paused = !0, t.update = function(e) {
				this.paused = void 0 !== e ? e : this.paused, this.style.backgroundImage = 'url("' + (this.paused ? M.VideoPlay : M.VideoPause) + '")'
			}, t
		},
		createVideoControlSeekbar: function() {
			function e(e) {
				e.stopPropagation(), l = !0, r = e.clientX || e.changedTouches && e.changedTouches[0].clientX, o = parseInt(c.style.width) / 100, a.container.addEventListener("mousemove", t, {
					passive: !0
				}), a.container.addEventListener("mouseup", i, {
					passive: !0
				}), a.container.addEventListener("touchmove", t, {
					passive: !0
				}), a.container.addEventListener("touchend", i, {
					passive: !0
				})
			}

			function t(e) {
				l && (s = ((e.clientX || e.changedTouches && e.changedTouches[0].clientX) - r) / u.clientWidth, s = 1 < (s = o + s) ? 1 : 0 > s ? 0 : s, u.setProgress(s), a.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "setVideoCurrentTime",
					data: s
				}))
			}

			function i(e) {
				e.stopPropagation(), l = !1, n()
			}

			function n() {
				a.container.removeEventListener("mousemove", t, !1), a.container.removeEventListener("mouseup", i, !1), a.container.removeEventListener("touchmove", t, !1), a.container.removeEventListener("touchend", i, !1)
			}
			var r, o, s, a = this,
				l = !1,
				c = document.createElement("div");
			c.style.width = "0%", c.style.height = "100%", c.style.backgroundColor = "#fff";
			var h = document.createElement("div");
			h.style.float = "right", h.style.width = "14px", h.style.height = "14px", h.style.transform = "translate(7px, -5px)", h.style.borderRadius = "50%", h.style.backgroundColor = "#ddd", h.addEventListener("mousedown", e, {
				passive: !0
			}), h.addEventListener("touchstart", e, {
				passive: !0
			}), c.appendChild(h);
			var u = this.createCustomItem({
				style: {
					float: "left",
					width: "30%",
					height: "4px",
					marginTop: "20px",
					backgroundColor: "rgba(188,188,188,0.8)"
				},
				onTap: function(e) {
					if (e.preventDefault(), e.stopPropagation(), e.target !== h) {
						var t = e.changedTouches && 0 < e.changedTouches.length ? (e.changedTouches[0].pageX - e.target.getBoundingClientRect().left) / this.clientWidth : e.offsetX / this.clientWidth;
						a.dispatchEvent({
							type: "panolens-viewer-handler",
							method: "setVideoCurrentTime",
							data: t
						}), u.setProgress(e.offsetX / this.clientWidth)
					}
				},
				onDispose: function() {
					n(), h = c = null
				}
			});
			return u.appendChild(c), u.setProgress = function(e) {
				c.style.width = 100 * e + "%"
			}, this.addEventListener("video-update", (function(e) {
				u.setProgress(e.percentage)
			})), u.progressElement = c, u.progressElementControl = h, u
		},
		createMenuItem: function(e) {
			var t = this,
				i = document.createElement("a");
			return i.textContent = e, i.style.display = "block", i.style.padding = "10px", i.style.textDecoration = "none", i.style.cursor = "pointer", i.style.pointerEvents = "auto", i.style.transition = this.DEFAULT_TRANSITION, i.slide = function(e) {
				this.style.transform = "translateX(" + (e ? "" : "-") + "100%)"
			}, i.unslide = function() {
				this.style.transform = "translateX(0)"
			}, i.setIcon = function(e) {
				this.icon && (this.icon.style.backgroundImage = "url(" + e + ")")
			}, i.setSelectionTitle = function(e) {
				this.selection && (this.selection.textContent = e)
			}, i.addSelection = function(e) {
				var t = document.createElement("span");
				return t.style.fontSize = "13px", t.style.fontWeight = "300", t.style.float = "right", this.selection = t, this.setSelectionTitle(e), this.appendChild(t), this
			}, i.addIcon = function(e, t, i) {
				e = void 0 === e ? M.ChevronRight : e, t = void 0 !== t && t, i = void 0 !== i && i;
				var n = document.createElement("span");
				return n.style.float = t ? "left" : "right", n.style.width = "17px", n.style.height = "17px", n.style["margin" + (t ? "Right" : "Left")] = "12px", n.style.backgroundSize = "cover", i && (n.style.transform = "rotateZ(180deg)"), this.icon = n, this.setIcon(e), this.appendChild(n), this
			}, i.addSubMenu = function(e, i) {
				return this.subMenu = t.createSubMenu(e, i), this
			}, i.addEventListener("mouseenter", (function() {
				this.style.backgroundColor = "#e0e0e0"
			}), !1), i.addEventListener("mouseleave", (function() {
				this.style.backgroundColor = "#fafafa"
			}), !1), i
		},
		createMenuItemHeader: function(e) {
			return (e = this.createMenuItem(e)).style.borderBottom = "1px solid #333", e.style.paddingBottom = "15px", e
		},
		createMainMenu: function(e) {
			function t(e) {
				e.preventDefault(), e.stopPropagation();
				var t = i.mainMenu,
					n = this.subMenu;
				t.hide(), t.slideAll(), t.parentElement.appendChild(n), i.activeMainItem = this, i.activeSubMenu = n, window.requestAnimationFrame((function() {
					t.changeSize(n.clientWidth), n.show(), n.unslideAll()
				}))
			}
			var i = this,
				n = this.createMenu();
			n._width = 200, n.changeSize(n._width);
			for (var r = 0; r < e.length; r++) {
				var o = n.addItem(e[r].title);
				o.style.paddingLeft = "20px", o.addIcon().addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", t, !1), e[r].subMenu && 0 < e[r].subMenu.length && o.addSelection(e[r].subMenu[0].title).addSubMenu(e[r].title, e[r].subMenu)
			}
			return n
		},
		createSubMenu: function(e, t) {
			function i(e) {
				e.preventDefault(), e.stopPropagation(), (n = r.mainMenu).changeSize(n._width), n.unslideAll(), n.show(), o.slideAll(!0), o.hide(), "header" !== this.type && (o.setActiveItem(this), r.activeMainItem.setSelectionTitle(this.textContent), this.handler && this.handler())
			}
			var n, r = this,
				o = this.createMenu();
			for (o.items = t, o.activeItem = null, o.addHeader(e).addIcon(void 0, !0, !0).addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), e = 0; e < t.length; e++) {
				var s = o.addItem(t[e].title);
				s.style.fontWeight = 300, s.handler = t[e].handler, s.addIcon(" ", !0), s.addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), o.activeItem || o.setActiveItem(s)
			}
			return o.slideAll(!0), o
		},
		createMenu: function() {
			var e = this,
				t = document.createElement("span"),
				i = t.style;
			return i.padding = "5px 0", i.position = "fixed", i.bottom = "100%", i.right = "14px", i.backgroundColor = "#fafafa", i.fontFamily = "Helvetica Neue", i.fontSize = "14px", i.visibility = "hidden", i.opacity = 0, i.boxShadow = "0 0 12pt rgba(0,0,0,0.25)", i.borderRadius = "2px", i.overflow = "hidden", i.willChange = "width, height, opacity", i.pointerEvents = "auto", i.transition = this.DEFAULT_TRANSITION, t.visible = !1, t.changeSize = function(e, t) {
				e && (this.style.width = e + "px"), t && (this.style.height = t + "px")
			}, t.show = function() {
				this.style.opacity = 1, this.style.visibility = "visible", this.visible = !0
			}, t.hide = function() {
				this.style.opacity = 0, this.style.visibility = "hidden", this.visible = !1
			}, t.toggle = function() {
				this.visible ? this.hide() : this.show()
			}, t.slideAll = function(e) {
				for (var i = 0; i < t.children.length; i++) t.children[i].slide && t.children[i].slide(e)
			}, t.unslideAll = function() {
				for (var e = 0; e < t.children.length; e++) t.children[e].unslide && t.children[e].unslide()
			}, t.addHeader = function(t) {
				return (t = e.createMenuItemHeader(t)).type = "header", this.appendChild(t), t
			}, t.addItem = function(t) {
				return (t = e.createMenuItem(t)).type = "item", this.appendChild(t), t
			}, t.setActiveItem = function(e) {
				this.activeItem && this.activeItem.setIcon(" "), e.setIcon(M.Check), this.activeItem = e
			}, t.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), t.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), t.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), t
		},
		createCustomItem: function(e) {
			var t = this,
				i = (e = void 0 === e ? {} : e).element || document.createElement("span"),
				n = e.onDispose;
			return i.style.cursor = "pointer", i.style.float = "right", i.style.width = "44px", i.style.height = "100%", i.style.backgroundSize = "60%", i.style.backgroundRepeat = "no-repeat", i.style.backgroundPosition = "center", i.style.webkitUserSelect = i.style.MozUserSelect = i.style.userSelect = "none", i.style.position = "relative", i.style.pointerEvents = "auto", i.addEventListener(t.TOUCH_ENABLED ? "touchstart" : "mouseenter", (function() {
				i.style.filter = i.style.webkitFilter = "drop-shadow(0 0 5px rgba(255,255,255,1))"
			}), {
				passive: !0
			}), i.addEventListener(t.TOUCH_ENABLED ? "touchend" : "mouseleave", (function() {
				i.style.filter = i.style.webkitFilter = ""
			}), {
				passive: !0
			}), this.mergeStyleOptions(i, e.style), e.onTap && i.addEventListener(t.TOUCH_ENABLED ? "touchend" : "click", e.onTap, !1), i.dispose = function() {
				i.removeEventListener(t.TOUCH_ENABLED ? "touchend" : "click", e.onTap, !1), n && e.onDispose()
			}, i
		},
		mergeStyleOptions: function(e, t) {
			for (var i in t = void 0 === t ? {} : t) t.hasOwnProperty(i) && (e.style[i] = t[i]);
			return e
		},
		dispose: function() {
			this.barElement && (this.container.removeChild(this.barElement), this.barElement.dispose(), this.barElement = null)
		}
	}), s.prototype = Object.assign(Object.create(t.Mesh.prototype), {
		constructor: s,
		add: function(e) {
			var i;
			if (1 < arguments.length) {
				for (i = 0; i < arguments.length; i++) this.add(arguments[i]);
				return this
			}
			if (e instanceof r) {
				if (i = e, e.dispatchEvent) {
					var n = this.container;
					n && e.dispatchEvent({
						type: "panolens-container",
						container: n
					}), e.dispatchEvent({
						type: "panolens-infospot-focus",
						method: function(e, t, i) {
							this.dispatchEvent({
								type: "panolens-viewer-handler",
								method: "tweenControlCenter",
								data: [e, t, i]
							})
						}.bind(this)
					})
				}
			} else(i = new t.Object3D).scale.x = -1, i.scalePlaceHolder = !0, i.add(e);
			t.Object3D.prototype.add.call(this, i)
		},
		load: function() {
			this.onLoad()
		},
		onClick: function(e) {
			e.intersects && 0 === e.intersects.length && this.traverse((function(e) {
				e.dispatchEvent({
					type: "dismiss"
				})
			}))
		},
		setContainer: function(e) {
			if (e instanceof HTMLElement) var t = e;
			else e && e.container && (t = e.container);
			t && (this.children.forEach((function(e) {
				e instanceof r && e.dispatchEvent && e.dispatchEvent({
					type: "panolens-container",
					container: t
				})
			})), this.container = t)
		},
		onLoad: function() {
			this.loaded = !0, this.dispatchEvent({
				type: "load"
			})
		},
		onProgress: function(e) {
			this.dispatchEvent({
				type: "progress",
				progress: e
			})
		},
		onError: function() {
			this.dispatchEvent({
				type: "error"
			})
		},
		getZoomLevel: function() {
			return 800 >= window.innerWidth ? this.ImageQualityFair : 800 < window.innerWidth && 1280 >= window.innerWidth ? this.ImageQualityMedium : 1280 < window.innerWidth && 1920 >= window.innerWidth ? this.ImageQualityHigh : 1920 < window.innerWidth ? this.ImageQualitySuperHigh : this.ImageQualityLow
		},
		updateTexture: function(e) {
			this.material.map = e, this.material.needsUpdate = !0
		},
		toggleInfospotVisibility: function(e, t) {
			t = void 0 !== t ? t : 0;
			var i = void 0 !== e ? e : !this.isInfospotVisible;
			this.traverse((function(e) {
				e instanceof r && (i ? e.show(t) : e.hide(t))
			})), this.isInfospotVisible = i, this.infospotAnimation.onComplete(function() {
				this.dispatchEvent({
					type: "infospot-animation-complete",
					visible: i
				})
			}.bind(this)).delay(t).start()
		},
		setLinkingImage: function(e, t) {
			this.linkingImageURL = e, this.linkingImageScale = t
		},
		link: function(e, t, i, n) {
			this.visible = !0, t ? ((n = new r(i = void 0 !== i ? i : void 0 !== e.linkingImageScale ? e.linkingImageScale : 300, n = n || (e.linkingImageURL ? e.linkingImageURL : M.Arrow))).position.copy(t), n.toPanorama = e, n.addEventListener("click", function() {
				this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "setPanorama",
					data: e
				})
			}.bind(this)), this.linkedSpots.push(n), this.add(n), this.visible = !1) : console.warn("Please specify infospot position for linking")
		},
		reset: function() {
			this.children.length = 0
		},
		setupTransitions: function() {
			this.fadeInAnimation = new C.Tween(this.material).easing(C.Easing.Quartic.Out).onStart(function() {
				this.visible = !0, this.dispatchEvent({
					type: "enter-fade-start"
				})
			}.bind(this)), this.fadeOutAnimation = new C.Tween(this.material).easing(C.Easing.Quartic.Out).onComplete(function() {
				this.visible = !1, this.dispatchEvent({
					type: "leave-complete"
				})
			}.bind(this)), this.enterTransition = new C.Tween(this).easing(C.Easing.Quartic.Out).onComplete(function() {
				this.dispatchEvent({
					type: "enter-complete"
				})
			}.bind(this)).start(), this.leaveTransition = new C.Tween(this).easing(C.Easing.Quartic.Out)
		},
		onFadeAnimationUpdate: function() {
			var e = this.material.opacity,
				t = this.material.uniforms;
			t && t.opacity && (t.opacity.value = e)
		},
		fadeIn: function(e) {
			e = 0 <= e ? e : this.animationDuration, this.fadeOutAnimation.stop(), this.fadeInAnimation.to({
				opacity: 1
			}, e).onUpdate(this.onFadeAnimationUpdate.bind(this)).onComplete(function() {
				this.toggleInfospotVisibility(!0, e / 2), this.dispatchEvent({
					type: "enter-fade-complete"
				})
			}.bind(this)).start()
		},
		fadeOut: function(e) {
			e = 0 <= e ? e : this.animationDuration, this.fadeInAnimation.stop(), this.fadeOutAnimation.to({
				opacity: 0
			}, e).onUpdate(this.onFadeAnimationUpdate.bind(this)).start()
		},
		onEnter: function() {
			var e = this.animationDuration;
			this.leaveTransition.stop(), this.enterTransition.to({}, e).onStart(function() {
				this.dispatchEvent({
					type: "enter-start"
				}), this.loaded ? this.fadeIn(e) : this.load()
			}.bind(this)).start(), this.dispatchEvent({
				type: "enter"
			}), this.children.forEach((function(e) {
				e.dispatchEvent({
					type: "panorama-enter"
				})
			})), this.active = !0
		},
		onLeave: function() {
			var e = this.animationDuration;
			this.enterTransition.stop(), this.leaveTransition.to({}, e).onStart(function() {
				this.dispatchEvent({
					type: "leave-start"
				}), this.fadeOut(e), this.toggleInfospotVisibility(!1)
			}.bind(this)).start(), this.dispatchEvent({
				type: "leave"
			}), this.children.forEach((function(e) {
				e.dispatchEvent({
					type: "panorama-leave"
				})
			})), this.active = !1
		},
		dispose: function() {
			this.infospotAnimation.stop(), this.fadeInAnimation.stop(), this.fadeOutAnimation.stop(), this.enterTransition.stop(), this.leaveTransition.stop(), this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "onPanoramaDispose",
					data: this
				}),
				function e(t) {
					for (var i = t.geometry, n = t.material, o = t.children.length - 1; 0 <= o; o--) e(t.children[o]), t.remove(t.children[o]);
					t instanceof r && t.dispose(), i && (i.dispose(), t.geometry = null), n && (n.dispose(), t.material = null)
				}(this), this.parent && this.parent.remove(this)
		}
	}), a.prototype = Object.assign(Object.create(s.prototype), {
		constructor: a,
		load: function(e) {
			(e = e || this.src) ? "string" == typeof e ? T.load(e, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this)) : e instanceof HTMLImageElement && this.onLoad(new t.Texture(e)): console.warn("Image source undefined")
		},
		onLoad: function(e) {
			e.minFilter = e.magFilter = t.LinearFilter, e.needsUpdate = !0, this.updateTexture(e), window.requestAnimationFrame(s.prototype.onLoad.bind(this))
		},
		reset: function() {
			s.prototype.reset.call(this)
		},
		dispose: function() {
			var e = this.material.map;
			t.Cache.remove(this.src), e && e.dispose(), s.prototype.dispose.call(this)
		}
	}), l.prototype = Object.assign(Object.create(s.prototype), {
		constructor: l
	}), c.prototype = Object.assign(Object.create(s.prototype), {
		constructor: c,
		load: function() {
			A.load(this.images, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this))
		},
		onLoad: function(e) {
			this.material.uniforms.tCube.value = e, s.prototype.onLoad.call(this)
		},
		dispose: function() {
			var e = this.material.uniforms.tCube.value;
			this.images.forEach((function(e) {
				t.Cache.remove(e)
			})), e instanceof t.CubeTexture && e.dispose(), s.prototype.dispose.call(this)
		}
	}), h.prototype = Object.assign(Object.create(c.prototype), {
		constructor: h
	}), u.prototype = Object.assign(Object.create(s.prototype), {
		constructor: u,
		isMobile: function() {
			var e = !1,
				t = window.navigator.userAgent || window.navigator.vendor || window.opera;
			return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0), e
		},
		load: function() {
			var e = this.options,
				t = e.muted,
				i = e.loop,
				n = e.autoplay,
				r = e.playsinline;
			e = e.crossOrigin;
			var o = this.videoElement,
				s = this.material,
				a = this.onProgress.bind(this),
				l = this.onLoad.bind(this);
			o.loop = i, o.autoplay = n, o.playsinline = r, o.crossOrigin = e, o.muted = t, r && (o.setAttribute("playsinline", ""), o.setAttribute("webkit-playsinline", "")), r = function() {
				this.setVideoTexture(o), n && this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "updateVideoPlayButton",
					data: !1
				}), this.isMobile() && (o.pause(), n && t ? this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "updateVideoPlayButton",
					data: !1
				}) : this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "updateVideoPlayButton",
					data: !0
				})), window.requestAnimationFrame((function() {
					s.map.needsUpdate = !0, a({
						loaded: 1,
						total: 1
					}), l()
				}))
			}, 2 < o.readyState ? r.call(this) : (0 === o.querySelectorAll("source").length && ((e = document.createElement("source")).src = this.src, o.appendChild(e)), o.load()), o.addEventListener("loadeddata", r.bind(this)), o.addEventListener("timeupdate", function() {
				this.videoProgress = 0 <= o.duration ? o.currentTime / o.duration : 0, this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "onVideoUpdate",
					data: this.videoProgress
				})
			}.bind(this)), o.addEventListener("ended", function() {
				i || (this.resetVideo(), this.dispatchEvent({
					type: "panolens-viewer-handler",
					method: "updateVideoPlayButton",
					data: !0
				}))
			}.bind(this), !1)
		},
		setVideoTexture: function(e) {
			e && ((e = new t.VideoTexture(e)).minFilter = t.LinearFilter, e.magFilter = t.LinearFilter, e.format = t.RGBFormat, this.updateTexture(e))
		},
		reset: function() {
			this.videoElement = void 0, s.prototype.reset.call(this)
		},
		isVideoPaused: function() {
			return this.videoElement.paused
		},
		toggleVideo: function() {
			var e = this.videoElement;
			e && e[e.paused ? "play" : "pause"]()
		},
		setVideoCurrentTime: function(e) {
			e = e.percentage;
			var t = this.videoElement;
			t && !Number.isNaN(e) && 1 !== e && (t.currentTime = t.duration * e, this.dispatchEvent({
				type: "panolens-viewer-handler",
				method: "onVideoUpdate",
				data: e
			}))
		},
		playVideo: function() {
			var e = this.videoElement,
				t = this.playVideo.bind(this),
				i = this.dispatchEvent.bind(this);
			e && e.paused && e.play().then((function() {
				i({
					type: "play"
				})
			})).catch((function(e) {
				window.requestAnimationFrame(t), i({
					type: "play-error",
					error: e
				})
			}))
		},
		pauseVideo: function() {
			var e = this.videoElement;
			e && !e.paused && e.pause(), this.dispatchEvent({
				type: "pause"
			})
		},
		resumeVideoProgress: function() {
			var e = this.videoElement;
			4 <= e.readyState && e.autoplay && !this.isMobile() ? (this.playVideo(), this.dispatchEvent({
				type: "panolens-viewer-handler",
				method: "updateVideoPlayButton",
				data: !1
			})) : (this.pauseVideo(), this.dispatchEvent({
				type: "panolens-viewer-handler",
				method: "updateVideoPlayButton",
				data: !0
			})), this.setVideoCurrentTime({
				percentage: this.videoProgress
			})
		},
		resetVideo: function() {
			this.videoElement && this.setVideoCurrentTime({
				percentage: 0
			})
		},
		isVideoMuted: function() {
			return this.videoElement.muted
		},
		muteVideo: function() {
			var e = this.videoElement;
			e && !e.muted && (e.muted = !0), this.dispatchEvent({
				type: "volumechange"
			})
		},
		unmuteVideo: function() {
			var e = this.videoElement;
			e && this.isVideoMuted() && (e.muted = !1), this.dispatchEvent({
				type: "volumechange"
			})
		},
		getVideoElement: function() {
			return this.videoElement
		},
		dispose: function() {
			var e = this.material.map;
			this.pauseVideo(), this.removeEventListener("leave", this.pauseVideo.bind(this)), this.removeEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.removeEventListener("video-toggle", this.toggleVideo.bind(this)), this.removeEventListener("video-time", this.setVideoCurrentTime.bind(this)), e && e.dispose(), s.prototype.dispose.call(this)
		}
	}), Object.assign(d.prototype, {
		constructor: d,
		setProgress: function(e, t) {
			this.onProgress && this.onProgress({
				loaded: e,
				total: t
			})
		},
		adaptTextureToZoom: function() {
			var e = this.widths[this._zoom],
				t = this.heights[this._zoom],
				i = this.maxW,
				n = this.maxH;
			this._wc = Math.ceil(e / i), this._hc = Math.ceil(t / n);
			for (var r = 0; r < this._hc; r++)
				for (var o = 0; o < this._wc; o++) {
					var s = document.createElement("canvas");
					s.width = o < this._wc - 1 ? i : e - i * o, s.height = r < this._hc - 1 ? n : t - n * r, this._canvas.push(s), this._ctx.push(s.getContext("2d"))
				}
		},
		composeFromTile: function(e, t, i) {
			var n = this.maxW,
				r = this.maxH;
			e *= 512, t *= 512;
			var o = Math.floor(e / n),
				s = Math.floor(t / r);
			this._ctx[s * this._wc + o].drawImage(i, 0, 0, i.width, i.height, e - o * n, t - s * r, 512, 512), this.progress()
		},
		progress: function() {
			this._count++, this.setProgress(this._count, this._total), this._count === this._total && (this.canvas = this._canvas, this.panoId = this._panoId, this.zoom = this._zoom, this.onPanoramaLoad) && this.onPanoramaLoad(this._canvas[0])
		},
		composePanorama: function() {
			this.setProgress(0, 1);
			var e = this.levelsW[this._zoom],
				t = this.levelsH[this._zoom],
				i = this;
			this._count = 0, this._total = e * t;
			for (var n = this._parameters.useWebGL, r = 0; r < t; r++)
				for (var o = {}, s = 0; s < e; o = {
						$jscomp$loop$prop$url$1: o.$jscomp$loop$prop$url$1
					}, s++) o.$jscomp$loop$prop$url$1 = "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" + this._zoom + "&x=" + s + "&y=" + r + "&panoid=" + this._panoId + "&nbt&fover=2",
					function(e) {
						return function(t, r) {
							if (n) var o = T.load(e.$jscomp$loop$prop$url$1, null, (function() {
								i.composeFromTile(t, r, o)
							}));
							else {
								var s = new Image;
								s.addEventListener("load", (function() {
									i.composeFromTile(t, r, this)
								})), s.crossOrigin = "", s.src = e.$jscomp$loop$prop$url$1
							}
						}
					}(o)(s, r)
		},
		load: function(e) {
			this.loadPano(e)
		},
		loadPano: function(e) {
			var t = this;
			this._panoClient.getPanoramaById(e, (function(e, i) {
				i === google.maps.StreetViewStatus.OK && (t.result = e, t.copyright = e.copyright, t._panoId = e.location.pano, t.composePanorama())
			}))
		},
		setZoom: function(e) {
			this._zoom = e, this.adaptTextureToZoom()
		}
	}), p.prototype = Object.assign(Object.create(a.prototype), {
		constructor: p,
		load: function(e) {
			this.loadRequested = !0, e = e || this.panoId || {}, this.gsvLoader && this.loadGSVLoader(e)
		},
		setupGoogleMapAPI: function(e) {
			var t = document.createElement("script");
			t.src = "https://maps.googleapis.com/maps/api/js?", t.src += e ? "key=" + e : "", t.onreadystatechange = this.setGSVLoader.bind(this), t.onload = this.setGSVLoader.bind(this), document.querySelector("head").appendChild(t)
		},
		setGSVLoader: function() {
			this.gsvLoader = new d, this.loadRequested && this.load()
		},
		getGSVLoader: function() {
			return this.gsvLoader
		},
		loadGSVLoader: function(e) {
			this.loadRequested = !1, this.gsvLoader.onProgress = this.onProgress.bind(this), this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this), this.gsvLoader.setZoom(this.getZoomLevel()), this.gsvLoader.load(e), this.gsvLoader.loaded = !0
		},
		onLoad: function(e) {
			a.prototype.onLoad.call(this, new t.Texture(e))
		},
		reset: function() {
			this.gsvLoader = void 0, a.prototype.reset.call(this)
		}
	});
	var P = {
		uniforms: {
			tDiffuse: {
				value: new t.Texture
			},
			resolution: {
				value: 1
			},
			transform: {
				value: new t.Matrix4
			},
			zoom: {
				value: 1
			},
			opacity: {
				value: 1
			}
		},
		vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = vec4( position, 1.0 );\n}",
		fragmentShader: "uniform sampler2D tDiffuse;\nuniform float resolution;\nuniform mat4 transform;\nuniform float zoom;\nuniform float opacity;\nvarying vec2 vUv;\nconst float PI = 3.141592653589793;\nvoid main(){\nvec2 position = -1.0 +  2.0 * vUv;\nposition *= vec2( zoom * resolution, zoom * 0.5 );\nfloat x2y2 = position.x * position.x + position.y * position.y;\nvec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );\nsphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );\nvec2 sampleUV = vec2(\n(atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,\n(asin(sphere_pnt.z) / PI + 0.5)\n);\ngl_FragColor = texture2D( tDiffuse, sampleUV );\ngl_FragColor.a *= opacity;\n}"
	};
	f.prototype = Object.assign(Object.create(a.prototype), {
		constructor: f,
		add: function(e) {
			if (1 < arguments.length) {
				for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
				return this
			}
			e instanceof r && (e.material.depthTest = !1), a.prototype.add.call(this, e)
		},
		createGeometry: function(e, i) {
			return new t.PlaneBufferGeometry(e, e * i)
		},
		createMaterial: function(e) {
			var i = Object.assign({}, P),
				n = i.uniforms;
			return n.zoom.value = e, n.opacity.value = 0, new t.ShaderMaterial({
				uniforms: n,
				vertexShader: i.vertexShader,
				fragmentShader: i.fragmentShader,
				side: t.BackSide,
				transparent: !0
			})
		},
		registerMouseEvents: function() {
			this.container.addEventListener("mousedown", this.onMouseDown.bind(this), {
				passive: !0
			}), this.container.addEventListener("mousemove", this.onMouseMove.bind(this), {
				passive: !0
			}), this.container.addEventListener("mouseup", this.onMouseUp.bind(this), {
				passive: !0
			}), this.container.addEventListener("touchstart", this.onMouseDown.bind(this), {
				passive: !0
			}), this.container.addEventListener("touchmove", this.onMouseMove.bind(this), {
				passive: !0
			}), this.container.addEventListener("touchend", this.onMouseUp.bind(this), {
				passive: !0
			}), this.container.addEventListener("mousewheel", this.onMouseWheel.bind(this), {
				passive: !1
			}), this.container.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), {
				passive: !1
			}), this.container.addEventListener("contextmenu", this.onContextMenu.bind(this), {
				passive: !0
			})
		},
		unregisterMouseEvents: function() {
			this.container.removeEventListener("mousedown", this.onMouseDown.bind(this), !1), this.container.removeEventListener("mousemove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("mouseup", this.onMouseUp.bind(this), !1), this.container.removeEventListener("touchstart", this.onMouseDown.bind(this), !1), this.container.removeEventListener("touchmove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("touchend", this.onMouseUp.bind(this), !1), this.container.removeEventListener("mousewheel", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("contextmenu", this.onContextMenu.bind(this), !1)
		},
		onMouseDown: function(e) {
			switch (e.touches && e.touches.length || 1) {
				case 1:
					var t = 0 <= e.clientX ? e.clientX : e.touches[0].clientX;
					e = 0 <= e.clientY ? e.clientY : e.touches[0].clientY, this.dragging = !0, this.userMouse.set(t, e);
					break;
				case 2:
					t = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, this.userMouse.pinchDistance = Math.sqrt(t * t + e * e)
			}
			this.onUpdateCallback()
		},
		onMouseMove: function(e) {
			switch (e.touches && e.touches.length || 1) {
				case 1:
					var i = 0 <= e.clientX ? e.clientX : e.touches[0].clientX;
					e = 0 <= e.clientY ? e.clientY : e.touches[0].clientY;
					var n = .4 * t.Math.degToRad(i - this.userMouse.x),
						r = .4 * t.Math.degToRad(e - this.userMouse.y);
					this.dragging && (this.quatA.setFromAxisAngle(this.vectorY, n), this.quatB.setFromAxisAngle(this.vectorX, r), this.quatCur.multiply(this.quatA).multiply(this.quatB), this.userMouse.set(i, e));
					break;
				case 2:
					i = e.touches[0].pageX - e.touches[1].pageX, e = e.touches[0].pageY - e.touches[1].pageY, this.addZoomDelta(this.userMouse.pinchDistance - Math.sqrt(i * i + e * e))
			}
		},
		onMouseUp: function() {
			this.dragging = !1
		},
		onMouseWheel: function(e) {
			e.preventDefault(), e.stopPropagation();
			var t = 0;
			void 0 !== e.wheelDelta ? t = e.wheelDelta : void 0 !== e.detail && (t = -e.detail), this.addZoomDelta(t), this.onUpdateCallback()
		},
		addZoomDelta: function(e) {
			var t = this.material.uniforms,
				i = .1 * this.size,
				n = 10 * this.size;
			t.zoom.value += e, t.zoom.value <= i ? t.zoom.value = i : t.zoom.value >= n && (t.zoom.value = n)
		},
		onUpdateCallback: function() {
			this.frameId = window.requestAnimationFrame(this.onUpdateCallback.bind(this)), this.quatSlerp.slerp(this.quatCur, .1), this.material && this.material.uniforms.transform.value.makeRotationFromQuaternion(this.quatSlerp), !this.dragging && 1 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS && window.cancelAnimationFrame(this.frameId)
		},
		reset: function() {
			this.quatCur.set(0, 0, 0, 1), this.quatSlerp.set(0, 0, 0, 1), this.onUpdateCallback()
		},
		onLoad: function(e) {
			this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight, this.registerMouseEvents(), this.onUpdateCallback(), this.dispatchEvent({
				type: "panolens-viewer-handler",
				method: "disableControl"
			}), a.prototype.onLoad.call(this, e)
		},
		onLeave: function() {
			this.unregisterMouseEvents(), this.dispatchEvent({
				type: "panolens-viewer-handler",
				method: "enableControl",
				data: _.ORBIT
			}), window.cancelAnimationFrame(this.frameId), a.prototype.onLeave.call(this)
		},
		onWindowResize: function() {
			this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight
		},
		onContextMenu: function() {
			this.dragging = !1
		},
		dispose: function() {
			this.unregisterMouseEvents(), a.prototype.dispose.call(this)
		}
	}), m.prototype = Object.assign(Object.create(f.prototype), {
		constructor: m,
		onLoad: function(e) {
			this.updateTexture(e), f.prototype.onLoad.call(this, e)
		},
		updateTexture: function(e) {
			e.minFilter = e.magFilter = t.LinearFilter, this.material.uniforms.tDiffuse.value = e
		},
		dispose: function() {
			var e = this.material.uniforms.tDiffuse;
			e && e.value && e.value.dispose(), f.prototype.dispose.call(this)
		}
	}), g.prototype = Object.assign(Object.create(s.prototype), {
		constructor: g,
		onPanolensContainer: function(e) {
			this.media.setContainer(e.container)
		},
		onPanolensScene: function(e) {
			this.media.setScene(e.scene)
		},
		start: function() {
			return this.media.start()
		},
		stop: function() {
			this.media.stop()
		}
	}), v.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
		constructor: v
	}), y.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
		constructor: y
	});
	var I = function(e) {
		var i = new t.StereoCamera;
		i.aspect = .5;
		var n = new t.Vector2;
		this.setEyeSeparation = function(e) {
			i.eyeSep = e
		}, this.setSize = function(t, i) {
			e.setSize(t, i)
		}, this.render = function(t, r) {
			t.updateMatrixWorld(), null === r.parent && r.updateMatrixWorld(), i.update(r), e.getSize(n), e.autoClear && e.clear(), e.setScissorTest(!0), e.setScissor(0, 0, n.width / 2, n.height), e.setViewport(0, 0, n.width / 2, n.height), e.render(t, i.cameraL), e.setScissor(n.width / 2, 0, n.width / 2, n.height), e.setViewport(n.width / 2, 0, n.width / 2, n.height), e.render(t, i.cameraR), e.setScissorTest(!1)
		}
	};
	w.prototype = Object.assign(Object.create(t.EventDispatcher.prototype), {
		constructor: w,
		add: function(e) {
			if (1 < arguments.length) {
				for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
				return this
			}
			this.scene.add(e), e.addEventListener && e.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), e instanceof s && e.dispatchEvent && e.dispatchEvent({
				type: "panolens-container",
				container: this.container
			}), e instanceof g && e.dispatchEvent({
				type: "panolens-scene",
				scene: this.scene
			}), "panorama" === e.type && (this.addPanoramaEventListener(e), this.panorama || this.setPanorama(e))
		},
		remove: function(e) {
			e.removeEventListener && e.removeEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), this.scene.remove(e)
		},
		addDefaultControlBar: function(e) {
			if (this.widget) console.warn("Default control bar exists");
			else {
				var t = new o(this.container);
				t.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), t.addControlBar(), e.forEach((function(e) {
					t.addControlButton(e)
				})), this.widget = t
			}
		},
		setPanorama: function(e) {
			var t = this.panorama;
			if ("panorama" === e.type && t !== e) {
				this.hideInfospot();
				var i = function() {
					t && t.onLeave(), e.removeEventListener("enter-fade-start", i)
				};
				e.addEventListener("enter-fade-start", i), (this.panorama = e).onEnter()
			}
		},
		eventHandler: function(e) {
			e.method && this[e.method] && this[e.method](e.data)
		},
		dispatchEventToChildren: function(e) {
			this.scene.traverse((function(t) {
				t.dispatchEvent && t.dispatchEvent(e)
			}))
		},
		activateWidgetItem: function(e, t) {
			var i = this.widget.mainMenu,
				n = i.children[0];
			if (i = i.children[1], void 0 !== e) {
				switch (e) {
					case 0:
						e = n.subMenu.children[1];
						break;
					case 1:
						e = n.subMenu.children[2];
						break;
					default:
						e = n.subMenu.children[1]
				}
				n.subMenu.setActiveItem(e), n.setSelectionTitle(e.textContent)
			}
			if (void 0 !== t) {
				switch (t) {
					case E.CARDBOARD:
						e = i.subMenu.children[2];
						break;
					case E.STEREO:
						e = i.subMenu.children[3];
						break;
					default:
						e = i.subMenu.children[1]
				}
				i.subMenu.setActiveItem(e), i.setSelectionTitle(e.textContent)
			}
		},
		enableEffect: function(e) {
			if (this.mode !== e)
				if (e === E.NORMAL) this.disableEffect();
				else {
					this.mode = e;
					var t = this.camera.fov;
					switch (e) {
						case E.CARDBOARD:
							this.effect = this.CardboardEffect, this.enableReticleControl();
							break;
						case E.STEREO:
							this.effect = this.StereoEffect, this.enableReticleControl();
							break;
						default:
							this.effect = null, this.disableReticleControl()
					}
					this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
						type: "panolens-dual-eye-effect",
						mode: this.mode
					}), this.camera.fov = t + .01, this.effect.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.camera.fov = t, this.dispatchEvent({
						type: "mode-change",
						mode: this.mode
					})
				}
		},
		disableEffect: function() {
			this.mode !== E.NORMAL && (this.mode = E.NORMAL, this.disableReticleControl(), this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({
				type: "panolens-dual-eye-effect",
				mode: this.mode
			}), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.dispatchEvent({
				type: "mode-change",
				mode: this.mode
			}))
		},
		enableReticleControl: function() {
			this.reticle.visible || (this.tempEnableReticle = !0, this.unregisterMouseAndTouchEvents(), this.reticle.show(), this.registerReticleEvent(), this.updateReticleEvent())
		},
		disableReticleControl: function() {
			this.tempEnableReticle = !1, this.options.enableReticle ? this.updateReticleEvent() : (this.reticle.hide(), this.unregisterReticleEvent(), this.registerMouseAndTouchEvents())
		},
		enableAutoRate: function() {
			this.options.autoRotate = !0, this.OrbitControls.autoRotate = !0
		},
		disableAutoRate: function() {
			clearTimeout(this.autoRotateRequestId), this.options.autoRotate = !1, this.OrbitControls.autoRotate = !1
		},
		toggleVideoPlay: function(e) {
			this.panorama instanceof u && this.panorama.dispatchEvent({
				type: "video-toggle",
				pause: e
			})
		},
		setVideoCurrentTime: function(e) {
			this.panorama instanceof u && this.panorama.dispatchEvent({
				type: "video-time",
				percentage: e
			})
		},
		onVideoUpdate: function(e) {
			var t = this.widget;
			t && t.dispatchEvent({
				type: "video-update",
				percentage: e
			})
		},
		addUpdateCallback: function(e) {
			e && this.updateCallbacks.push(e)
		},
		removeUpdateCallback: function(e) {
			var t = this.updateCallbacks.indexOf(e);
			e && 0 <= t && this.updateCallbacks.splice(t, 1)
		},
		showVideoWidget: function() {
			var e = this.widget;
			e && e.dispatchEvent({
				type: "video-control-show"
			})
		},
		hideVideoWidget: function() {
			var e = this.widget;
			e && e.dispatchEvent({
				type: "video-control-hide"
			})
		},
		updateVideoPlayButton: function(e) {
			var t = this.widget;
			t && t.videoElement && t.videoElement.controlButton && t.videoElement.controlButton.update(e)
		},
		addPanoramaEventListener: function(e) {
			e.addEventListener("enter-fade-start", this.setCameraControl.bind(this)), e instanceof u && (e.addEventListener("enter-fade-start", this.showVideoWidget.bind(this)), e.addEventListener("leave", function() {
				this.panorama instanceof u || this.hideVideoWidget.call(this)
			}.bind(this)))
		},
		setCameraControl: function() {
			this.OrbitControls.target.copy(this.panorama.position)
		},
		getControl: function() {
			return this.control
		},
		getScene: function() {
			return this.scene
		},
		getCamera: function() {
			return this.camera
		},
		getRenderer: function() {
			return this.renderer
		},
		getContainer: function() {
			return this.container
		},
		getControlId: function() {
			return this.control.id
		},
		getNextControlId: function() {
			return this.controls[this.getNextControlIndex()].id
		},
		getNextControlIndex: function() {
			var e = this.controls,
				t = e.indexOf(this.control) + 1;
			return t >= e.length ? 0 : t
		},
		setCameraFov: function(e) {
			this.camera.fov = e, this.camera.updateProjectionMatrix()
		},
		enableControl: function(e) {
			switch (e = 0 <= e && e < this.controls.length ? e : 0, this.control.enabled = !1, this.control = this.controls[e], this.control.enabled = !0, e) {
				case _.ORBIT:
					this.camera.position.copy(this.panorama.position), this.camera.position.z += 1;
					break;
				case _.DEVICEORIENTATION:
					this.camera.position.copy(this.panorama.position)
			}
			this.control.update(), this.activateWidgetItem(e, void 0)
		},
		disableControl: function() {
			this.control.enabled = !1
		},
		toggleNextControl: function() {
			this.enableControl(this.getNextControlIndex())
		},
		getScreenVector: function(e) {
			e = e.clone();
			var t = this.container.clientWidth / 2,
				i = this.container.clientHeight / 2;
			return e.project(this.camera), e.x = e.x * t + t, e.y = -e.y * i + i, e.z = 0, e
		},
		checkSpriteInViewport: function(e) {
			return this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), this.cameraViewProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix), e.visible && this.cameraFrustum.intersectsSprite(e)
		},
		reverseDraggingDirection: function() {
			this.OrbitControls.rotateSpeed *= -1, this.OrbitControls.momentumScalingFactor *= -1
		},
		addReticle: function() {
			this.reticle = new n(16777215, !0, this.options.dwellTime), this.reticle.hide(), this.camera.add(this.reticle), this.sceneReticle.add(this.camera)
		},
		tweenControlCenter: function(e, i, n) {
			var r;
			if (this.control === this.OrbitControls) {
				e instanceof Array && (i = e[1], n = e[2], e = e[0]), i = void 0 !== i ? i : 1e3, n = n || C.Easing.Exponential.Out;
				var o = this,
					s = this.camera.getWorldDirection(new t.Vector3),
					a = s.clone(),
					l = this.panorama.getWorldPosition(new t.Vector3).sub(this.camera.getWorldPosition(new t.Vector3));
				(e = e.clone()).x *= -1, e.add(l).normalize();
				var c = e.clone();
				s.y = 0, e.y = 0, l = (l = (l = Math.atan2(e.z, e.x) - Math.atan2(s.z, s.x)) > Math.PI ? l - 2 * Math.PI : l) < -Math.PI ? l + 2 * Math.PI : l, s = Math.abs(a.angleTo(s) + (0 >= a.y * c.y ? c.angleTo(e) : -c.angleTo(e))), s *= c.y < a.y ? 1 : -1, a = {
					left: 0,
					up: 0
				};
				var h = r = 0;
				this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.tweenLeftAnimation = new C.Tween(a).to({
					left: l
				}, i).easing(n).onUpdate((function(e) {
					o.control.rotateLeft(e.left - r), r = e.left
				})).start(), this.tweenUpAnimation = new C.Tween(a).to({
					up: s
				}, i).easing(n).onUpdate((function(e) {
					o.control.rotateUp(e.up - h), h = e.up
				})).start()
			}
		},
		tweenControlCenterByObject: function(e, i, n) {
			var r = !1;
			if (e.traverseAncestors((function(e) {
					e.scalePlaceHolder && (r = !0)
				})), r) {
				var o = new t.Vector3(-1, 1, 1);
				this.tweenControlCenter(e.getWorldPosition(new t.Vector3).multiply(o), i, n)
			} else this.tweenControlCenter(e.getWorldPosition(new t.Vector3), i, n)
		},
		onWindowResize: function(e, t) {
			var i = this.container.classList.contains("panolens-container") || this.container.isFullscreen;
			if (void 0 !== e && void 0 !== t) {
				var n = e,
					r = t;
				this.container._width = e, this.container._height = t
			} else e = (t = /(android)/i.test(window.navigator.userAgent)) ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0), t = t ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientHeight, window.innerHeight || 0), n = i ? e : this.container.clientWidth, r = i ? t : this.container.clientHeight, this.container._width = n, this.container._height = r;
			this.camera.aspect = n / r, this.camera.updateProjectionMatrix(), this.renderer.setSize(n, r), (this.options.enableReticle || this.tempEnableReticle) && this.updateReticleEvent(), this.dispatchEvent({
				type: "window-resize",
				width: n,
				height: r
			}), this.scene.traverse((function(e) {
				e.dispatchEvent && e.dispatchEvent({
					type: "window-resize",
					width: n,
					height: r
				})
			}))
		},
		addOutputElement: function() {
			var e = document.createElement("div");
			e.style.position = "absolute", e.style.right = "10px", e.style.top = "10px", e.style.color = "#fff", this.container.appendChild(e), this.outputDivElement = e
		},
		outputPosition: function() {
			var e = this.raycaster.intersectObject(this.panorama, !0);
			if (0 < e.length) {
				e = e[0].point.clone();
				var i = new t.Vector3(-1, 1, 1),
					n = this.panorama.getWorldPosition(new t.Vector3);
				if (e.sub(n).multiply(i), i = e.x.toFixed(2) + ", " + e.y.toFixed(2) + ", " + e.z.toFixed(2), 0 !== e.length()) switch (this.options.output) {
					case "console":
						console.info(i);
						break;
					case "overlay":
						this.outputDivElement.textContent = i
				}
			}
		},
		onMouseDown: function(e) {
			e.preventDefault(), this.userMouse.x = 0 <= e.clientX ? e.clientX : e.touches[0].clientX, this.userMouse.y = 0 <= e.clientY ? e.clientY : e.touches[0].clientY, this.userMouse.type = "mousedown", this.onTap(e)
		},
		onMouseMove: function(e) {
			e.preventDefault(), this.userMouse.type = "mousemove", this.onTap(e)
		},
		onMouseUp: function(e) {
			this.userMouse.type = "mouseup";
			var t = this.userMouse.x >= e.clientX - this.options.clickTolerance && this.userMouse.x <= e.clientX + this.options.clickTolerance && this.userMouse.y >= e.clientY - this.options.clickTolerance && this.userMouse.y <= e.clientY + this.options.clickTolerance || e.changedTouches && this.userMouse.x >= e.changedTouches[0].clientX - this.options.clickTolerance && this.userMouse.x <= e.changedTouches[0].clientX + this.options.clickTolerance && this.userMouse.y >= e.changedTouches[0].clientY - this.options.clickTolerance && this.userMouse.y <= e.changedTouches[0].clientY + this.options.clickTolerance ? "click" : void 0;
			if ((!e || !e.target || e.target.classList.contains("panolens-canvas")) && (e.preventDefault(), e = e.changedTouches && 1 === e.changedTouches.length ? this.onTap({
					clientX: e.changedTouches[0].clientX,
					clientY: e.changedTouches[0].clientY
				}, t) : this.onTap(e, t), this.userMouse.type = "none", !e && "click" === t)) {
				e = (t = this.options).autoHideControlBar;
				var i = this.panorama,
					n = this.toggleControlBar;
				t.autoHideInfospot && i && i.toggleInfospotVisibility(), e && n()
			}
		},
		onTap: function(e, t) {
			var i = this.container.getBoundingClientRect(),
				n = i.top,
				o = this.container,
				s = o.clientHeight;
			if (this.raycasterPoint.x = (e.clientX - i.left) / o.clientWidth * 2 - 1, this.raycasterPoint.y = -(e.clientY - n) / s * 2 + 1, this.raycaster.setFromCamera(this.raycasterPoint, this.camera), this.panorama) {
				if (("mousedown" !== e.type && this.touchSupported || this.OUTPUT_INFOSPOT) && this.outputPosition(), i = this.raycaster.intersectObjects(this.panorama.children, !0), n = this.getConvertedIntersect(i), o = 0 < i.length ? i[0].object : void 0, "mouseup" === this.userMouse.type && (n && this.pressEntityObject === n && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
						type: "pressstop-entity",
						mouseEvent: e
					}), this.pressEntityObject = void 0), "mouseup" === this.userMouse.type && (o && this.pressObject === o && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
						type: "pressstop",
						mouseEvent: e
					}), this.pressObject = void 0), "click" === t ? (this.panorama.dispatchEvent({
						type: "click",
						intersects: i,
						mouseEvent: e
					}), n && n.dispatchEvent && n.dispatchEvent({
						type: "click-entity",
						mouseEvent: e
					}), o && o.dispatchEvent && o.dispatchEvent({
						type: "click",
						mouseEvent: e
					})) : (this.panorama.dispatchEvent({
						type: "hover",
						intersects: i,
						mouseEvent: e
					}), (this.hoverObject && 0 < i.length && this.hoverObject !== n || this.hoverObject && 0 === i.length) && (this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
						type: "hoverleave",
						mouseEvent: e
					}), this.reticle.end()), this.hoverObject = void 0), n && 0 < i.length && (this.hoverObject !== n && (this.hoverObject = n, this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({
						type: "hoverenter",
						mouseEvent: e
					}), (this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle) && this.reticle.start(this.onTap.bind(this, e, "click")))), "mousedown" === this.userMouse.type && this.pressEntityObject != n && (this.pressEntityObject = n, this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
						type: "pressstart-entity",
						mouseEvent: e
					})), "mousedown" === this.userMouse.type && this.pressObject != o && (this.pressObject = o, this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
						type: "pressstart",
						mouseEvent: e
					})), "mousemove" === this.userMouse.type || this.options.enableReticle) && (o && o.dispatchEvent && o.dispatchEvent({
						type: "hover",
						mouseEvent: e
					}), this.pressEntityObject && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({
						type: "pressmove-entity",
						mouseEvent: e
					}), this.pressObject && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({
						type: "pressmove",
						mouseEvent: e
					})), !n && this.pressEntityObject && this.pressEntityObject.dispatchEvent && (this.pressEntityObject.dispatchEvent({
						type: "pressstop-entity",
						mouseEvent: e
					}), this.pressEntityObject = void 0), !o && this.pressObject && this.pressObject.dispatchEvent && (this.pressObject.dispatchEvent({
						type: "pressstop",
						mouseEvent: e
					}), this.pressObject = void 0)), o && o instanceof r) {
					if (this.infospot = o, "click" === t) return !0
				} else this.infospot && this.hideInfospot();
				this.options.autoRotate && "mousemove" !== this.userMouse.type && (clearTimeout(this.autoRotateRequestId), this.control === this.OrbitControls && (this.OrbitControls.autoRotate = !1, this.autoRotateRequestId = window.setTimeout(this.enableAutoRate.bind(this), this.options.autoRotateActivationDuration)))
			}
		},
		getConvertedIntersect: function(e) {
			for (var t, i = 0; i < e.length; i++)
				if (0 <= e[i].distance && e[i].object && !e[i].object.passThrough && (!e[i].object.entity || !e[i].object.entity.passThrough)) {
					t = e[i].object.entity && !e[i].object.entity.passThrough ? e[i].object.entity : e[i].object;
					break
				} return t
		},
		hideInfospot: function() {
			this.infospot && (this.infospot.onHoverEnd(), this.infospot = void 0)
		},
		toggleControlBar: function() {
			var e = this.widget;
			e && e.dispatchEvent({
				type: "control-bar-toggle"
			})
		},
		onKeyDown: function(e) {
			this.options.output && "none" !== this.options.output && "Control" === e.key && (this.OUTPUT_INFOSPOT = !0)
		},
		onKeyUp: function() {
			this.OUTPUT_INFOSPOT = !1
		},
		update: function() {
			C.update(), this.updateCallbacks.forEach((function(e) {
				e()
			})), this.control.update(), this.scene.traverse(function(e) {
				if (e instanceof r && e.element && (this.hoverObject === e || "none" !== e.element.style.display || e.element.left && "none" !== e.element.left.style.display || e.element.right && "none" !== e.element.right.style.display))
					if (this.checkSpriteInViewport(e)) {
						var i = this.getScreenVector(e.getWorldPosition(new t.Vector3));
						e.translateElement(i.x, i.y)
					} else e.onDismiss()
			}.bind(this))
		},
		render: function() {
			this.mode === E.CARDBOARD || this.mode === E.STEREO ? (this.renderer.clear(), this.effect.render(this.scene, this.camera), this.effect.render(this.sceneReticle, this.camera)) : (this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderer.clearDepth(), this.renderer.render(this.sceneReticle, this.camera))
		},
		animate: function() {
			this.requestAnimationId = window.requestAnimationFrame(this.animate.bind(this)), this.onChange()
		},
		onChange: function() {
			this.update(), this.render()
		},
		registerMouseAndTouchEvents: function() {
			var e = {
				passive: !1
			};
			this.container.addEventListener("mousedown", this.HANDLER_MOUSE_DOWN, e), this.container.addEventListener("mousemove", this.HANDLER_MOUSE_MOVE, e), this.container.addEventListener("mouseup", this.HANDLER_MOUSE_UP, e), this.container.addEventListener("touchstart", this.HANDLER_MOUSE_DOWN, e), this.container.addEventListener("touchend", this.HANDLER_MOUSE_UP, e)
		},
		unregisterMouseAndTouchEvents: function() {
			this.container.removeEventListener("mousedown", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("mousemove", this.HANDLER_MOUSE_MOVE, !1), this.container.removeEventListener("mouseup", this.HANDLER_MOUSE_UP, !1), this.container.removeEventListener("touchstart", this.HANDLER_MOUSE_DOWN, !1), this.container.removeEventListener("touchend", this.HANDLER_MOUSE_UP, !1)
		},
		registerReticleEvent: function() {
			this.addUpdateCallback(this.HANDLER_TAP)
		},
		unregisterReticleEvent: function() {
			this.removeUpdateCallback(this.HANDLER_TAP)
		},
		updateReticleEvent: function() {
			var e = this.container.clientWidth / 2 + this.container.offsetLeft,
				t = this.container.clientHeight / 2;
			this.removeUpdateCallback(this.HANDLER_TAP), this.HANDLER_TAP = this.onTap.bind(this, {
				clientX: e,
				clientY: t
			}), this.addUpdateCallback(this.HANDLER_TAP)
		},
		registerEventListeners: function() {
			window.addEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.addEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.addEventListener("keyup", this.HANDLER_KEY_UP, !0)
		},
		unregisterEventListeners: function() {
			window.removeEventListener("resize", this.HANDLER_WINDOW_RESIZE, !0), window.removeEventListener("keydown", this.HANDLER_KEY_DOWN, !0), window.removeEventListener("keyup", this.HANDLER_KEY_UP, !0)
		},
		dispose: function() {
			this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.unregisterEventListeners(),
				function e(t) {
					for (var i = t.children.length - 1; 0 <= i; i--) e(t.children[i]), t.remove(t.children[i]);
					t instanceof s || t instanceof r ? t.dispose() : t.dispatchEvent && t.dispatchEvent("dispose")
				}(this.scene), this.widget && (this.widget.dispose(), this.widget = null), t.Cache && t.Cache.enabled && t.Cache.clear()
		},
		destroy: function() {
			this.dispose(), this.render(), window.cancelAnimationFrame(this.requestAnimationId)
		},
		onPanoramaDispose: function(e) {
			e instanceof u && this.hideVideoWidget(), e === this.panorama && (this.panorama = null)
		},
		loadAsyncRequest: function(e, t) {
			t = void 0 === t ? function() {} : t;
			var i = new window.XMLHttpRequest;
			i.onloadend = function(e) {
				t(e)
			}, i.open("GET", e, !0), i.send(null)
		},
		addViewIndicator: function() {
			var e = this;
			this.loadAsyncRequest(M.ViewIndicator, (function(i) {
				if (0 !== i.loaded) {
					(i = i.target.responseXML.documentElement).style.width = e.viewIndicatorSize + "px", i.style.height = e.viewIndicatorSize + "px", i.style.position = "absolute", i.style.top = "10px", i.style.left = "10px", i.style.opacity = "0.5", i.style.cursor = "pointer", i.id = "panolens-view-indicator-container", e.container.appendChild(i);
					var n = i.querySelector("#indicator");
					e.addUpdateCallback((function() {
						e.radius = .225 * e.viewIndicatorSize, e.currentPanoAngle = e.camera.rotation.y - t.Math.degToRad(90), e.fovAngle = t.Math.degToRad(e.camera.fov), e.leftAngle = -e.currentPanoAngle - e.fovAngle / 2, e.rightAngle = -e.currentPanoAngle + e.fovAngle / 2, e.leftX = e.radius * Math.cos(e.leftAngle), e.leftY = e.radius * Math.sin(e.leftAngle), e.rightX = e.radius * Math.cos(e.rightAngle), e.rightY = e.radius * Math.sin(e.rightAngle), e.indicatorD = "M " + e.leftX + " " + e.leftY + " A " + e.radius + " " + e.radius + " 0 0 1 " + e.rightX + " " + e.rightY, e.leftX && e.leftY && e.rightX && e.rightY && e.radius && n.setAttribute("d", e.indicatorD)
					})), i.addEventListener("mouseenter", (function() {
						this.style.opacity = "1"
					})), i.addEventListener("mouseleave", (function() {
						this.style.opacity = "0.5"
					}))
				}
			}))
		},
		appendControlItem: function(e) {
			var t = this.widget.createCustomItem(e);
			return "video" === e.group ? this.widget.videoElement.appendChild(t) : this.widget.barElement.appendChild(t), t
		},
		clearAllCache: function() {
			t.Cache.clear()
		}
	}), "105" != t.REVISION && console.warn("three.js version is not matched. Please consider use the target revision 105"), window.TWEEN = C, e.BasicPanorama = h, e.CONTROLS = _, e.CameraPanorama = g, e.CubePanorama = c, e.CubeTextureLoader = A, e.DataImage = M, e.EmptyPanorama = l, e.GoogleStreetviewPanorama = p, e.ImageLittlePlanet = m, e.ImageLoader = S, e.ImagePanorama = a, e.Infospot = r, e.LittlePlanet = f, e.MODES = E, e.Media = i, e.Panorama = s, e.REVISION = "11", e.Reticle = n, e.THREE_REVISION = "105", e.THREE_VERSION = x, e.TextureLoader = T, e.VERSION = "0.11.0", e.VideoPanorama = u, e.Viewer = w, e.Widget = o, Object.defineProperty(e, "__esModule", {
		value: !0
	})
}));
var Swiper = function() {
		"use strict";

		function e(e) {
			return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object
		}

		function t(i, n) {
			void 0 === i && (i = {}), void 0 === n && (n = {});
			const r = ["__proto__", "constructor", "prototype"];
			Object.keys(n).filter(e => r.indexOf(e) < 0).forEach(r => {
				void 0 === i[r] ? i[r] = n[r] : e(n[r]) && e(i[r]) && Object.keys(n[r]).length > 0 && t(i[r], n[r])
			})
		}
		const i = {
			body: {},
			addEventListener() {},
			removeEventListener() {},
			activeElement: {
				blur() {},
				nodeName: ""
			},
			querySelector: () => null,
			querySelectorAll: () => [],
			getElementById: () => null,
			createEvent: () => ({
				initEvent() {}
			}),
			createElement: () => ({
				children: [],
				childNodes: [],
				style: {},
				setAttribute() {},
				getElementsByTagName: () => []
			}),
			createElementNS: () => ({}),
			importNode: () => null,
			location: {
				hash: "",
				host: "",
				hostname: "",
				href: "",
				origin: "",
				pathname: "",
				protocol: "",
				search: ""
			}
		};

		function n() {
			const e = "undefined" != typeof document ? document : {};
			return t(e, i), e
		}
		const r = {
			document: i,
			navigator: {
				userAgent: ""
			},
			location: {
				hash: "",
				host: "",
				hostname: "",
				href: "",
				origin: "",
				pathname: "",
				protocol: "",
				search: ""
			},
			history: {
				replaceState() {},
				pushState() {},
				go() {},
				back() {}
			},
			CustomEvent: function() {
				return this
			},
			addEventListener() {},
			removeEventListener() {},
			getComputedStyle: () => ({
				getPropertyValue: () => ""
			}),
			Image() {},
			Date() {},
			screen: {},
			setTimeout() {},
			clearTimeout() {},
			matchMedia: () => ({}),
			requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
			cancelAnimationFrame(e) {
				"undefined" != typeof setTimeout && clearTimeout(e)
			}
		};

		function o() {
			const e = "undefined" != typeof window ? window : {};
			return t(e, r), e
		}

		function s(e) {
			return void 0 === e && (e = ""), e.trim().split(" ").filter(e => !!e.trim())
		}

		function a(e, t) {
			return void 0 === t && (t = 0), setTimeout(e, t)
		}

		function l() {
			return Date.now()
		}

		function c(e, t) {
			void 0 === t && (t = "x");
			const i = o();
			let n, r, s;
			const a = function(e) {
				const t = o();
				let i;
				return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i
			}(e);
			return i.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map(e => e.replace(",", ".")).join(", ")), s = new i.WebKitCSSMatrix("none" === r ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = s.toString().split(",")), "x" === t && (r = i.WebKitCSSMatrix ? s.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (r = i.WebKitCSSMatrix ? s.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), r || 0
		}

		function h(e) {
			return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
		}

		function u() {
			const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
				t = ["__proto__", "constructor", "prototype"];
			for (let n = 1; n < arguments.length; n += 1) {
				const r = n < 0 || arguments.length <= n ? void 0 : arguments[n];
				if (null != r && (i = r, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) {
					const i = Object.keys(Object(r)).filter(e => t.indexOf(e) < 0);
					for (let t = 0, n = i.length; t < n; t += 1) {
						const n = i[t],
							o = Object.getOwnPropertyDescriptor(r, n);
						void 0 !== o && o.enumerable && (h(e[n]) && h(r[n]) ? r[n].__swiper__ ? e[n] = r[n] : u(e[n], r[n]) : !h(e[n]) && h(r[n]) ? (e[n] = {}, r[n].__swiper__ ? e[n] = r[n] : u(e[n], r[n])) : e[n] = r[n])
					}
				}
			}
			var i;
			return e
		}

		function d(e, t, i) {
			e.style.setProperty(t, i)
		}

		function p(e) {
			let {
				swiper: t,
				targetPosition: i,
				side: n
			} = e;
			const r = o(),
				s = -t.translate;
			let a, l = null;
			const c = t.params.speed;
			t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID);
			const h = i > s ? "next" : "prev",
				u = (e, t) => "next" === h && e >= t || "prev" === h && e <= t,
				d = () => {
					a = (new Date).getTime(), null === l && (l = a);
					const e = Math.max(Math.min((a - l) / c, 1), 0),
						o = .5 - Math.cos(e * Math.PI) / 2;
					let h = s + o * (i - s);
					if (u(h, i) && (h = i), t.wrapperEl.scrollTo({
							[n]: h
						}), u(h, i)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
						t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
							[n]: h
						})
					}), void r.cancelAnimationFrame(t.cssModeFrameID);
					t.cssModeFrameID = r.requestAnimationFrame(d)
				};
			d()
		}

		function f(e) {
			return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
		}

		function m(e, t) {
			void 0 === t && (t = "");
			const i = o(),
				n = [...e.children];
			return i.HTMLSlotElement && e instanceof HTMLSlotElement && n.push(...e.assignedElements()), t ? n.filter(e => e.matches(t)) : n
		}

		function g(e) {
			try {
				return void console.warn(e)
			} catch (e) {}
		}

		function v(e, t) {
			void 0 === t && (t = []);
			const i = document.createElement(e);
			return i.classList.add(...Array.isArray(t) ? t : s(t)), i
		}

		function y(e) {
			const t = o(),
				i = n(),
				r = e.getBoundingClientRect(),
				s = i.body,
				a = e.clientTop || s.clientTop || 0,
				l = e.clientLeft || s.clientLeft || 0,
				c = e === t ? t.scrollY : e.scrollTop,
				h = e === t ? t.scrollX : e.scrollLeft;
			return {
				top: r.top + c - a,
				left: r.left + h - l
			}
		}

		function b(e, t) {
			return o().getComputedStyle(e, null).getPropertyValue(t)
		}

		function w(e) {
			let t, i = e;
			if (i) {
				for (t = 0; null !== (i = i.previousSibling);) 1 === i.nodeType && (t += 1);
				return t
			}
		}

		function x(e, t) {
			const i = [];
			let n = e.parentElement;
			for (; n;) t ? n.matches(t) && i.push(n) : i.push(n), n = n.parentElement;
			return i
		}

		function _(e, t) {
			t && e.addEventListener("transitionend", (function i(n) {
				n.target === e && (t.call(e, n), e.removeEventListener("transitionend", i))
			}))
		}

		function E(e, t, i) {
			const n = o();
			return i ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
		}

		function M(e) {
			return (Array.isArray(e) ? e : [e]).filter(e => !!e)
		}

		function S(e) {
			return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t
		}
		let T, A, L;

		function C() {
			return T || (T = function() {
				const e = o(),
					t = n();
				return {
					smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style,
					touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
				}
			}()), T
		}

		function P(e) {
			return void 0 === e && (e = {}), A || (A = function(e) {
				let {
					userAgent: t
				} = void 0 === e ? {} : e;
				const i = C(),
					n = o(),
					r = n.navigator.platform,
					s = t || n.navigator.userAgent,
					a = {
						ios: !1,
						android: !1
					},
					l = n.screen.width,
					c = n.screen.height,
					h = s.match(/(Android);?[\s\/]+([\d.]+)?/);
				let u = s.match(/(iPad).*OS\s([\d_]+)/);
				const d = s.match(/(iPod)(.*OS\s([\d_]+))?/),
					p = !u && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
					f = "Win32" === r;
				let m = "MacIntel" === r;
				return !u && m && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${l}x${c}`) >= 0 && (u = s.match(/(Version)\/([\d.]+)/), u || (u = [0, 1, "13_0_0"]), m = !1), h && !f && (a.os = "android", a.android = !0), (u || p || d) && (a.os = "ios", a.ios = !0), a
			}(e)), A
		}

		function I() {
			return L || (L = function() {
				const e = o(),
					t = P();
				let i = !1;

				function n() {
					const t = e.navigator.userAgent.toLowerCase();
					return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
				}
				if (n()) {
					const t = String(e.navigator.userAgent);
					if (t.includes("Version/")) {
						const [e, n] = t.split("Version/")[1].split(" ")[0].split(".").map(e => Number(e));
						i = e < 16 || 16 === e && n < 2
					}
				}
				const r = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent),
					s = n();
				return {
					isSafari: i || s,
					needPerspectiveFix: i,
					need3dFix: s || r && t.ios,
					isWebView: r
				}
			}()), L
		}
		const R = (e, t, i) => {
				t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
			},
			O = (e, t, i) => {
				t && !e.classList.contains(i) ? e.classList.add(i) : !t && e.classList.contains(i) && e.classList.remove(i)
			},
			D = (e, t) => {
				if (!e || e.destroyed || !e.params) return;
				const i = t.closest(e.isElement ? "swiper-slide" : "." + e.params.slideClass);
				if (i) {
					let t = i.querySelector("." + e.params.lazyPreloaderClass);
					!t && e.isElement && (i.shadowRoot ? t = i.shadowRoot.querySelector("." + e.params.lazyPreloaderClass) : requestAnimationFrame(() => {
						i.shadowRoot && (t = i.shadowRoot.querySelector("." + e.params.lazyPreloaderClass), t && t.remove())
					})), t && t.remove()
				}
			},
			z = (e, t) => {
				if (!e.slides[t]) return;
				const i = e.slides[t].querySelector('[loading="lazy"]');
				i && i.removeAttribute("loading")
			},
			k = e => {
				if (!e || e.destroyed || !e.params) return;
				let t = e.params.lazyPreloadPrevNext;
				const i = e.slides.length;
				if (!i || !t || t < 0) return;
				t = Math.min(t, i);
				const n = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView),
					r = e.activeIndex;
				if (e.params.grid && e.params.grid.rows > 1) {
					const i = r,
						o = [i - t];
					return o.push(...Array.from({
						length: t
					}).map((e, t) => i + n + t)), void e.slides.forEach((t, i) => {
						o.includes(t.column) && z(e, i)
					})
				}
				const o = r + n - 1;
				if (e.params.rewind || e.params.loop)
					for (let n = r - t; n <= o + t; n += 1) {
						const t = (n % i + i) % i;
						(t < r || t > o) && z(e, t)
					} else
						for (let n = Math.max(r - t, 0); n <= Math.min(o + t, i - 1); n += 1) n !== r && (n > o || n < r) && z(e, n)
			};

		function N(e) {
			let {
				swiper: t,
				runCallbacks: i,
				direction: n,
				step: r
			} = e;
			const {
				activeIndex: o,
				previousIndex: s
			} = t;
			let a = n;
			if (a || (a = o > s ? "next" : o < s ? "prev" : "reset"), t.emit("transition" + r), i && o !== s) {
				if ("reset" === a) return void t.emit("slideResetTransition" + r);
				t.emit("slideChangeTransition" + r), "next" === a ? t.emit("slideNextTransition" + r) : t.emit("slidePrevTransition" + r)
			}
		}

		function B(e, t, i) {
			const n = o(),
				{
					params: r
				} = e,
				s = r.edgeSwipeDetection,
				a = r.edgeSwipeThreshold;
			return !s || !(i <= a || i >= n.innerWidth - a) || "prevent" === s && (t.preventDefault(), !0)
		}

		function H(e) {
			const t = this,
				i = n();
			let r = e;
			r.originalEvent && (r = r.originalEvent);
			const s = t.touchEventsData;
			if ("pointerdown" === r.type) {
				if (null !== s.pointerId && s.pointerId !== r.pointerId) return;
				s.pointerId = r.pointerId
			} else "touchstart" === r.type && 1 === r.targetTouches.length && (s.touchId = r.targetTouches[0].identifier);
			if ("touchstart" === r.type) return void B(t, r, r.targetTouches[0].pageX);
			const {
				params: a,
				touches: c,
				enabled: h
			} = t;
			if (!h) return;
			if (!a.simulateTouch && "mouse" === r.pointerType) return;
			if (t.animating && a.preventInteractionOnTransition) return;
			!t.animating && a.cssMode && a.loop && t.loopFix();
			let u = r.target;
			if ("wrapper" === a.touchEventsTarget && ! function(e, t) {
					const i = o();
					let n = t.contains(e);
					return !n && i.HTMLSlotElement && t instanceof HTMLSlotElement && (n = [...t.assignedElements()].includes(e), n || (n = function(e, t) {
						const i = [t];
						for (; i.length > 0;) {
							const t = i.shift();
							if (e === t) return !0;
							i.push(...t.children, ...t.shadowRoot ? t.shadowRoot.children : [], ...t.assignedElements ? t.assignedElements() : [])
						}
					}(e, t))), n
				}(u, t.wrapperEl)) return;
			if ("which" in r && 3 === r.which) return;
			if ("button" in r && r.button > 0) return;
			if (s.isTouched && s.isMoved) return;
			const d = !!a.noSwipingClass && "" !== a.noSwipingClass,
				p = r.composedPath ? r.composedPath() : r.path;
			d && r.target && r.target.shadowRoot && p && (u = p[0]);
			const f = a.noSwipingSelector ? a.noSwipingSelector : "." + a.noSwipingClass,
				m = !(!r.target || !r.target.shadowRoot);
			if (a.noSwiping && (m ? function(e, t) {
					return void 0 === t && (t = this),
						function t(i) {
							if (!i || i === n() || i === o()) return null;
							i.assignedSlot && (i = i.assignedSlot);
							const r = i.closest(e);
							return r || i.getRootNode ? r || t(i.getRootNode().host) : null
						}(t)
				}(f, u) : u.closest(f))) return void(t.allowClick = !0);
			if (a.swipeHandler && !u.closest(a.swipeHandler)) return;
			c.currentX = r.pageX, c.currentY = r.pageY;
			const g = c.currentX,
				v = c.currentY;
			if (!B(t, r, g)) return;
			Object.assign(s, {
				isTouched: !0,
				isMoved: !1,
				allowTouchCallbacks: !0,
				isScrolling: void 0,
				startMoving: void 0
			}), c.startX = g, c.startY = v, s.touchStartTime = l(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, a.threshold > 0 && (s.allowThresholdMove = !1);
			let y = !0;
			u.matches(s.focusableElements) && (y = !1, "SELECT" === u.nodeName && (s.isTouched = !1)), i.activeElement && i.activeElement.matches(s.focusableElements) && i.activeElement !== u && ("mouse" === r.pointerType || "mouse" !== r.pointerType && !u.matches(s.focusableElements)) && i.activeElement.blur();
			const b = y && t.allowTouchMove && a.touchStartPreventDefault;
			!a.touchStartForcePreventDefault && !b || u.isContentEditable || r.preventDefault(), a.freeMode && a.freeMode.enabled && t.freeMode && t.animating && !a.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", r)
		}

		function F(e) {
			const t = n(),
				i = this,
				r = i.touchEventsData,
				{
					params: o,
					touches: s,
					rtlTranslate: a,
					enabled: c
				} = i;
			if (!c) return;
			if (!o.simulateTouch && "mouse" === e.pointerType) return;
			let h, u = e;
			if (u.originalEvent && (u = u.originalEvent), "pointermove" === u.type) {
				if (null !== r.touchId) return;
				if (u.pointerId !== r.pointerId) return
			}
			if ("touchmove" === u.type) {
				if (h = [...u.changedTouches].find(e => e.identifier === r.touchId), !h || h.identifier !== r.touchId) return
			} else h = u;
			if (!r.isTouched) return void(r.startMoving && r.isScrolling && i.emit("touchMoveOpposite", u));
			const d = h.pageX,
				p = h.pageY;
			if (u.preventedByNestedSwiper) return s.startX = d, void(s.startY = p);
			if (!i.allowTouchMove) return u.target.matches(r.focusableElements) || (i.allowClick = !1), void(r.isTouched && (Object.assign(s, {
				startX: d,
				startY: p,
				currentX: d,
				currentY: p
			}), r.touchStartTime = l()));
			if (o.touchReleaseOnEdges && !o.loop)
				if (i.isVertical()) {
					if (p < s.startY && i.translate <= i.maxTranslate() || p > s.startY && i.translate >= i.minTranslate()) return r.isTouched = !1, void(r.isMoved = !1)
				} else if (d < s.startX && i.translate <= i.maxTranslate() || d > s.startX && i.translate >= i.minTranslate()) return;
			if (t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== u.target && "mouse" !== u.pointerType && t.activeElement.blur(), t.activeElement && u.target === t.activeElement && u.target.matches(r.focusableElements)) return r.isMoved = !0, void(i.allowClick = !1);
			r.allowTouchCallbacks && i.emit("touchMove", u), s.previousX = s.currentX, s.previousY = s.currentY, s.currentX = d, s.currentY = p;
			const f = s.currentX - s.startX,
				m = s.currentY - s.startY;
			if (i.params.threshold && Math.sqrt(f ** 2 + m ** 2) < i.params.threshold) return;
			if (void 0 === r.isScrolling) {
				let e;
				i.isHorizontal() && s.currentY === s.startY || i.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : f * f + m * m >= 25 && (e = 180 * Math.atan2(Math.abs(m), Math.abs(f)) / Math.PI, r.isScrolling = i.isHorizontal() ? e > o.touchAngle : 90 - e > o.touchAngle)
			}
			if (r.isScrolling && i.emit("touchMoveOpposite", u), void 0 === r.startMoving && (s.currentX === s.startX && s.currentY === s.startY || (r.startMoving = !0)), r.isScrolling || "touchmove" === u.type && r.preventTouchMoveFromPointerMove) return void(r.isTouched = !1);
			if (!r.startMoving) return;
			i.allowClick = !1, !o.cssMode && u.cancelable && u.preventDefault(), o.touchMoveStopPropagation && !o.nested && u.stopPropagation();
			let g = i.isHorizontal() ? f : m,
				v = i.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY;
			o.oneWayMovement && (g = Math.abs(g) * (a ? 1 : -1), v = Math.abs(v) * (a ? 1 : -1)), s.diff = g, g *= o.touchRatio, a && (g = -g, v = -v);
			const y = i.touchesDirection;
			i.swipeDirection = g > 0 ? "prev" : "next", i.touchesDirection = v > 0 ? "prev" : "next";
			const b = i.params.loop && !o.cssMode,
				w = "next" === i.touchesDirection && i.allowSlideNext || "prev" === i.touchesDirection && i.allowSlidePrev;
			if (!r.isMoved) {
				if (b && w && i.loopFix({
						direction: i.swipeDirection
					}), r.startTranslate = i.getTranslate(), i.setTransition(0), i.animating) {
					const e = new window.CustomEvent("transitionend", {
						bubbles: !0,
						cancelable: !0,
						detail: {
							bySwiperTouchMove: !0
						}
					});
					i.wrapperEl.dispatchEvent(e)
				}
				r.allowMomentumBounce = !1, !o.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", u)
			}
			if ((new Date).getTime(), !1 !== o._loopSwapReset && r.isMoved && r.allowThresholdMove && y !== i.touchesDirection && b && w && Math.abs(g) >= 1) return Object.assign(s, {
				startX: d,
				startY: p,
				currentX: d,
				currentY: p,
				startTranslate: r.currentTranslate
			}), r.loopSwapReset = !0, void(r.startTranslate = r.currentTranslate);
			i.emit("sliderMove", u), r.isMoved = !0, r.currentTranslate = g + r.startTranslate;
			let x = !0,
				_ = o.resistanceRatio;
			if (o.touchReleaseOnEdges && (_ = 0), g > 0 ? (b && w && r.allowThresholdMove && r.currentTranslate > (o.centeredSlides ? i.minTranslate() - i.slidesSizesGrid[i.activeIndex + 1] - ("auto" !== o.slidesPerView && i.slides.length - o.slidesPerView >= 2 ? i.slidesSizesGrid[i.activeIndex + 1] + i.params.spaceBetween : 0) - i.params.spaceBetween : i.minTranslate()) && i.loopFix({
					direction: "prev",
					setTranslate: !0,
					activeSlideIndex: 0
				}), r.currentTranslate > i.minTranslate() && (x = !1, o.resistance && (r.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + r.startTranslate + g) ** _))) : g < 0 && (b && w && r.allowThresholdMove && r.currentTranslate < (o.centeredSlides ? i.maxTranslate() + i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween + ("auto" !== o.slidesPerView && i.slides.length - o.slidesPerView >= 2 ? i.slidesSizesGrid[i.slidesSizesGrid.length - 1] + i.params.spaceBetween : 0) : i.maxTranslate()) && i.loopFix({
					direction: "next",
					setTranslate: !0,
					activeSlideIndex: i.slides.length - ("auto" === o.slidesPerView ? i.slidesPerViewDynamic() : Math.ceil(parseFloat(o.slidesPerView, 10)))
				}), r.currentTranslate < i.maxTranslate() && (x = !1, o.resistance && (r.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - r.startTranslate - g) ** _))), x && (u.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), i.allowSlidePrev || i.allowSlideNext || (r.currentTranslate = r.startTranslate), o.threshold > 0) {
				if (!(Math.abs(g) > o.threshold || r.allowThresholdMove)) return void(r.currentTranslate = r.startTranslate);
				if (!r.allowThresholdMove) return r.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, r.currentTranslate = r.startTranslate, void(s.diff = i.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY)
			}
			o.followFinger && !o.cssMode && ((o.freeMode && o.freeMode.enabled && i.freeMode || o.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), o.freeMode && o.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(r.currentTranslate), i.setTranslate(r.currentTranslate))
		}

		function U(e) {
			const t = this,
				i = t.touchEventsData;
			let n, r = e;
			if (r.originalEvent && (r = r.originalEvent), "touchend" === r.type || "touchcancel" === r.type) {
				if (n = [...r.changedTouches].find(e => e.identifier === i.touchId), !n || n.identifier !== i.touchId) return
			} else {
				if (null !== i.touchId) return;
				if (r.pointerId !== i.pointerId) return;
				n = r
			}
			if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && (!["pointercancel", "contextmenu"].includes(r.type) || !t.browser.isSafari && !t.browser.isWebView)) return;
			i.pointerId = null, i.touchId = null;
			const {
				params: o,
				touches: s,
				rtlTranslate: c,
				slidesGrid: h,
				enabled: u
			} = t;
			if (!u) return;
			if (!o.simulateTouch && "mouse" === r.pointerType) return;
			if (i.allowTouchCallbacks && t.emit("touchEnd", r), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && o.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
			o.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
			const d = l(),
				p = d - i.touchStartTime;
			if (t.allowClick) {
				const e = r.path || r.composedPath && r.composedPath();
				t.updateClickedSlide(e && e[0] || r.target, e), t.emit("tap click", r), p < 300 && d - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", r)
			}
			if (i.lastClickTime = l(), a(() => {
					t.destroyed || (t.allowClick = !0)
				}), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === s.diff && !i.loopSwapReset || i.currentTranslate === i.startTranslate && !i.loopSwapReset) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
			let f;
			if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, f = o.followFinger ? c ? t.translate : -t.translate : -i.currentTranslate, o.cssMode) return;
			if (o.freeMode && o.freeMode.enabled) return void t.freeMode.onTouchEnd({
				currentPos: f
			});
			const m = f >= -t.maxTranslate() && !t.params.loop;
			let g = 0,
				v = t.slidesSizesGrid[0];
			for (let e = 0; e < h.length; e += e < o.slidesPerGroupSkip ? 1 : o.slidesPerGroup) {
				const t = e < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
				void 0 !== h[e + t] ? (m || f >= h[e] && f < h[e + t]) && (g = e, v = h[e + t] - h[e]) : (m || f >= h[e]) && (g = e, v = h[h.length - 1] - h[h.length - 2])
			}
			let y = null,
				b = null;
			o.rewind && (t.isBeginning ? b = o.virtual && o.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (y = 0));
			const w = (f - h[g]) / v,
				x = g < o.slidesPerGroupSkip - 1 ? 1 : o.slidesPerGroup;
			if (p > o.longSwipesMs) {
				if (!o.longSwipes) return void t.slideTo(t.activeIndex);
				"next" === t.swipeDirection && (w >= o.longSwipesRatio ? t.slideTo(o.rewind && t.isEnd ? y : g + x) : t.slideTo(g)), "prev" === t.swipeDirection && (w > 1 - o.longSwipesRatio ? t.slideTo(g + x) : null !== b && w < 0 && Math.abs(w) > o.longSwipesRatio ? t.slideTo(b) : t.slideTo(g))
			} else {
				if (!o.shortSwipes) return void t.slideTo(t.activeIndex);
				!t.navigation || r.target !== t.navigation.nextEl && r.target !== t.navigation.prevEl ? ("next" === t.swipeDirection && t.slideTo(null !== y ? y : g + x), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g)) : r.target === t.navigation.nextEl ? t.slideTo(g + x) : t.slideTo(g)
			}
		}

		function j() {
			const e = this,
				{
					params: t,
					el: i
				} = e;
			if (i && 0 === i.offsetWidth) return;
			t.breakpoints && e.setBreakpoint();
			const {
				allowSlideNext: n,
				allowSlidePrev: r,
				snapGrid: o
			} = e, s = e.virtual && e.params.virtual.enabled;
			e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
			const a = s && t.loop;
			!("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || a ? e.params.loop && !s ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout(() => {
				e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
			}, 500)), e.allowSlidePrev = r, e.allowSlideNext = n, e.params.watchOverflow && o !== e.snapGrid && e.checkOverflow()
		}

		function G(e) {
			const t = this;
			t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())))
		}

		function V() {
			const e = this,
				{
					wrapperEl: t,
					rtlTranslate: i,
					enabled: n
				} = e;
			if (!n) return;
			let r;
			e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
			const o = e.maxTranslate() - e.minTranslate();
			r = 0 === o ? 0 : (e.translate - e.minTranslate()) / o, r !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1)
		}

		function W(e) {
			const t = this;
			D(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update()
		}

		function q() {
			const e = this;
			e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"))
		}
		const X = (e, t) => {
				const i = n(),
					{
						params: r,
						el: o,
						wrapperEl: s,
						device: a
					} = e,
					l = !!r.nested,
					c = "on" === t ? "addEventListener" : "removeEventListener",
					h = t;
				o && "string" != typeof o && (i[c]("touchstart", e.onDocumentTouchStart, {
					passive: !1,
					capture: l
				}), o[c]("touchstart", e.onTouchStart, {
					passive: !1
				}), o[c]("pointerdown", e.onTouchStart, {
					passive: !1
				}), i[c]("touchmove", e.onTouchMove, {
					passive: !1,
					capture: l
				}), i[c]("pointermove", e.onTouchMove, {
					passive: !1,
					capture: l
				}), i[c]("touchend", e.onTouchEnd, {
					passive: !0
				}), i[c]("pointerup", e.onTouchEnd, {
					passive: !0
				}), i[c]("pointercancel", e.onTouchEnd, {
					passive: !0
				}), i[c]("touchcancel", e.onTouchEnd, {
					passive: !0
				}), i[c]("pointerout", e.onTouchEnd, {
					passive: !0
				}), i[c]("pointerleave", e.onTouchEnd, {
					passive: !0
				}), i[c]("contextmenu", e.onTouchEnd, {
					passive: !0
				}), (r.preventClicks || r.preventClicksPropagation) && o[c]("click", e.onClick, !0), r.cssMode && s[c]("scroll", e.onScroll), r.updateOnWindowResize ? e[h](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", j, !0) : e[h]("observerUpdate", j, !0), o[c]("load", e.onLoad, {
					capture: !0
				}))
			},
			Y = (e, t) => e.grid && t.grid && t.grid.rows > 1;
		var Z = {
			init: !0,
			direction: "horizontal",
			oneWayMovement: !1,
			swiperElementNodeName: "SWIPER-CONTAINER",
			touchEventsTarget: "wrapper",
			initialSlide: 0,
			speed: 300,
			cssMode: !1,
			updateOnWindowResize: !0,
			resizeObserver: !0,
			nested: !1,
			createElements: !1,
			eventsPrefix: "swiper",
			enabled: !0,
			focusableElements: "input, select, option, textarea, button, video, label",
			width: null,
			height: null,
			preventInteractionOnTransition: !1,
			userAgent: null,
			url: null,
			edgeSwipeDetection: !1,
			edgeSwipeThreshold: 20,
			autoHeight: !1,
			setWrapperSize: !1,
			virtualTranslate: !1,
			effect: "slide",
			breakpoints: void 0,
			breakpointsBase: "window",
			spaceBetween: 0,
			slidesPerView: 1,
			slidesPerGroup: 1,
			slidesPerGroupSkip: 0,
			slidesPerGroupAuto: !1,
			centeredSlides: !1,
			centeredSlidesBounds: !1,
			slidesOffsetBefore: 0,
			slidesOffsetAfter: 0,
			normalizeSlideIndex: !0,
			centerInsufficientSlides: !1,
			watchOverflow: !0,
			roundLengths: !1,
			touchRatio: 1,
			touchAngle: 45,
			simulateTouch: !0,
			shortSwipes: !0,
			longSwipes: !0,
			longSwipesRatio: .5,
			longSwipesMs: 300,
			followFinger: !0,
			allowTouchMove: !0,
			threshold: 5,
			touchMoveStopPropagation: !1,
			touchStartPreventDefault: !0,
			touchStartForcePreventDefault: !1,
			touchReleaseOnEdges: !1,
			uniqueNavElements: !0,
			resistance: !0,
			resistanceRatio: .85,
			watchSlidesProgress: !1,
			grabCursor: !1,
			preventClicks: !0,
			preventClicksPropagation: !0,
			slideToClickedSlide: !1,
			loop: !1,
			loopAddBlankSlides: !0,
			loopAdditionalSlides: 0,
			loopPreventsSliding: !0,
			rewind: !1,
			allowSlidePrev: !0,
			allowSlideNext: !0,
			swipeHandler: null,
			noSwiping: !0,
			noSwipingClass: "swiper-no-swiping",
			noSwipingSelector: null,
			passiveListeners: !0,
			maxBackfaceHiddenSlides: 10,
			containerModifierClass: "swiper-",
			slideClass: "swiper-slide",
			slideBlankClass: "swiper-slide-blank",
			slideActiveClass: "swiper-slide-active",
			slideVisibleClass: "swiper-slide-visible",
			slideFullyVisibleClass: "swiper-slide-fully-visible",
			slideNextClass: "swiper-slide-next",
			slidePrevClass: "swiper-slide-prev",
			wrapperClass: "swiper-wrapper",
			lazyPreloaderClass: "swiper-lazy-preloader",
			lazyPreloadPrevNext: 0,
			runCallbacksOnInit: !0,
			_emitClasses: !1
		};

		function Q(e, t) {
			return function(i) {
				void 0 === i && (i = {});
				const n = Object.keys(i)[0],
					r = i[n];
				"object" == typeof r && null !== r ? (!0 === e[n] && (e[n] = {
					enabled: !0
				}), "navigation" === n && e[n] && e[n].enabled && !e[n].prevEl && !e[n].nextEl && (e[n].auto = !0), ["pagination", "scrollbar"].indexOf(n) >= 0 && e[n] && e[n].enabled && !e[n].el && (e[n].auto = !0), n in e && "enabled" in r ? ("object" != typeof e[n] || "enabled" in e[n] || (e[n].enabled = !0), e[n] || (e[n] = {
					enabled: !1
				}), u(t, i)) : u(t, i)) : u(t, i)
			}
		}
		const J = {
				eventsEmitter: {
					on(e, t, i) {
						const n = this;
						if (!n.eventsListeners || n.destroyed) return n;
						if ("function" != typeof t) return n;
						const r = i ? "unshift" : "push";
						return e.split(" ").forEach(e => {
							n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][r](t)
						}), n
					},
					once(e, t, i) {
						const n = this;
						if (!n.eventsListeners || n.destroyed) return n;
						if ("function" != typeof t) return n;

						function r() {
							n.off(e, r), r.__emitterProxy && delete r.__emitterProxy;
							for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
							t.apply(n, o)
						}
						return r.__emitterProxy = t, n.on(e, r, i)
					},
					onAny(e, t) {
						const i = this;
						if (!i.eventsListeners || i.destroyed) return i;
						if ("function" != typeof e) return i;
						const n = t ? "unshift" : "push";
						return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[n](e), i
					},
					offAny(e) {
						const t = this;
						if (!t.eventsListeners || t.destroyed) return t;
						if (!t.eventsAnyListeners) return t;
						const i = t.eventsAnyListeners.indexOf(e);
						return i >= 0 && t.eventsAnyListeners.splice(i, 1), t
					},
					off(e, t) {
						const i = this;
						return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach(e => {
							void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach((n, r) => {
								(n === t || n.__emitterProxy && n.__emitterProxy === t) && i.eventsListeners[e].splice(r, 1)
							})
						}), i) : i
					},
					emit() {
						const e = this;
						if (!e.eventsListeners || e.destroyed) return e;
						if (!e.eventsListeners) return e;
						let t, i, n;
						for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
						return "string" == typeof o[0] || Array.isArray(o[0]) ? (t = o[0], i = o.slice(1, o.length), n = e) : (t = o[0].events, i = o[0].data, n = o[0].context || e), i.unshift(n), (Array.isArray(t) ? t : t.split(" ")).forEach(t => {
							e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => {
								e.apply(n, [t, ...i])
							}), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach(e => {
								e.apply(n, i)
							})
						}), e
					}
				},
				update: {
					updateSize: function() {
						const e = this;
						let t, i;
						const n = e.el;
						t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : n.clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : n.clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(b(n, "padding-left") || 0, 10) - parseInt(b(n, "padding-right") || 0, 10), i = i - parseInt(b(n, "padding-top") || 0, 10) - parseInt(b(n, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, {
							width: t,
							height: i,
							size: e.isHorizontal() ? t : i
						}))
					},
					updateSlides: function() {
						const e = this;

						function t(t, i) {
							return parseFloat(t.getPropertyValue(e.getDirectionLabel(i)) || 0)
						}
						const i = e.params,
							{
								wrapperEl: n,
								slidesEl: r,
								size: o,
								rtlTranslate: s,
								wrongRTL: a
							} = e,
							l = e.virtual && i.virtual.enabled,
							c = l ? e.virtual.slides.length : e.slides.length,
							h = m(r, `.${e.params.slideClass}, swiper-slide`),
							u = l ? e.virtual.slides.length : h.length;
						let p = [];
						const f = [],
							g = [];
						let v = i.slidesOffsetBefore;
						"function" == typeof v && (v = i.slidesOffsetBefore.call(e));
						let y = i.slidesOffsetAfter;
						"function" == typeof y && (y = i.slidesOffsetAfter.call(e));
						const w = e.snapGrid.length,
							x = e.slidesGrid.length;
						let _ = i.spaceBetween,
							M = -v,
							S = 0,
							T = 0;
						if (void 0 === o) return;
						"string" == typeof _ && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * o : "string" == typeof _ && (_ = parseFloat(_)), e.virtualSize = -_, h.forEach(e => {
							s ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = ""
						}), i.centeredSlides && i.cssMode && (d(n, "--swiper-centered-offset-before", ""), d(n, "--swiper-centered-offset-after", ""));
						const A = i.grid && i.grid.rows > 1 && e.grid;
						let L;
						A ? e.grid.initSlides(h) : e.grid && e.grid.unsetSlides();
						const C = "auto" === i.slidesPerView && i.breakpoints && Object.keys(i.breakpoints).filter(e => void 0 !== i.breakpoints[e].slidesPerView).length > 0;
						for (let n = 0; n < u; n += 1) {
							let r;
							if (L = 0, h[n] && (r = h[n]), A && e.grid.updateSlide(n, r, h), !h[n] || "none" !== b(r, "display")) {
								if ("auto" === i.slidesPerView) {
									C && (h[n].style[e.getDirectionLabel("width")] = "");
									const o = getComputedStyle(r),
										s = r.style.transform,
										a = r.style.webkitTransform;
									if (s && (r.style.transform = "none"), a && (r.style.webkitTransform = "none"), i.roundLengths) L = e.isHorizontal() ? E(r, "width", !0) : E(r, "height", !0);
									else {
										const e = t(o, "width"),
											i = t(o, "padding-left"),
											n = t(o, "padding-right"),
											s = t(o, "margin-left"),
											a = t(o, "margin-right"),
											l = o.getPropertyValue("box-sizing");
										if (l && "border-box" === l) L = e + s + a;
										else {
											const {
												clientWidth: t,
												offsetWidth: o
											} = r;
											L = e + i + n + s + a + (o - t)
										}
									}
									s && (r.style.transform = s), a && (r.style.webkitTransform = a), i.roundLengths && (L = Math.floor(L))
								} else L = (o - (i.slidesPerView - 1) * _) / i.slidesPerView, i.roundLengths && (L = Math.floor(L)), h[n] && (h[n].style[e.getDirectionLabel("width")] = L + "px");
								h[n] && (h[n].swiperSlideSize = L), g.push(L), i.centeredSlides ? (M = M + L / 2 + S / 2 + _, 0 === S && 0 !== n && (M = M - o / 2 - _), 0 === n && (M = M - o / 2 - _), Math.abs(M) < .001 && (M = 0), i.roundLengths && (M = Math.floor(M)), T % i.slidesPerGroup == 0 && p.push(M), f.push(M)) : (i.roundLengths && (M = Math.floor(M)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && p.push(M), f.push(M), M = M + L + _), e.virtualSize += L + _, S = L, T += 1
							}
						}
						if (e.virtualSize = Math.max(e.virtualSize, o) + y, s && a && ("slide" === i.effect || "coverflow" === i.effect) && (n.style.width = e.virtualSize + _ + "px"), i.setWrapperSize && (n.style[e.getDirectionLabel("width")] = e.virtualSize + _ + "px"), A && e.grid.updateWrapperSize(L, p), !i.centeredSlides) {
							const t = [];
							for (let n = 0; n < p.length; n += 1) {
								let r = p[n];
								i.roundLengths && (r = Math.floor(r)), p[n] <= e.virtualSize - o && t.push(r)
							}
							p = t, Math.floor(e.virtualSize - o) - Math.floor(p[p.length - 1]) > 1 && p.push(e.virtualSize - o)
						}
						if (l && i.loop) {
							const t = g[0] + _;
							if (i.slidesPerGroup > 1) {
								const n = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / i.slidesPerGroup),
									r = t * i.slidesPerGroup;
								for (let e = 0; e < n; e += 1) p.push(p[p.length - 1] + r)
							}
							for (let n = 0; n < e.virtual.slidesBefore + e.virtual.slidesAfter; n += 1) 1 === i.slidesPerGroup && p.push(p[p.length - 1] + t), f.push(f[f.length - 1] + t), e.virtualSize += t
						}
						if (0 === p.length && (p = [0]), 0 !== _) {
							const t = e.isHorizontal() && s ? "marginLeft" : e.getDirectionLabel("marginRight");
							h.filter((e, t) => !(i.cssMode && !i.loop) || t !== h.length - 1).forEach(e => {
								e.style[t] = _ + "px"
							})
						}
						if (i.centeredSlides && i.centeredSlidesBounds) {
							let e = 0;
							g.forEach(t => {
								e += t + (_ || 0)
							}), e -= _;
							const t = e > o ? e - o : 0;
							p = p.map(e => e <= 0 ? -v : e > t ? t + y : e)
						}
						if (i.centerInsufficientSlides) {
							let e = 0;
							g.forEach(t => {
								e += t + (_ || 0)
							}), e -= _;
							const t = (i.slidesOffsetBefore || 0) + (i.slidesOffsetAfter || 0);
							if (e + t < o) {
								const i = (o - e - t) / 2;
								p.forEach((e, t) => {
									p[t] = e - i
								}), f.forEach((e, t) => {
									f[t] = e + i
								})
							}
						}
						if (Object.assign(e, {
								slides: h,
								snapGrid: p,
								slidesGrid: f,
								slidesSizesGrid: g
							}), i.centeredSlides && i.cssMode && !i.centeredSlidesBounds) {
							d(n, "--swiper-centered-offset-before", -p[0] + "px"), d(n, "--swiper-centered-offset-after", e.size / 2 - g[g.length - 1] / 2 + "px");
							const t = -e.snapGrid[0],
								i = -e.slidesGrid[0];
							e.snapGrid = e.snapGrid.map(e => e + t), e.slidesGrid = e.slidesGrid.map(e => e + i)
						}
						if (u !== c && e.emit("slidesLengthChange"), p.length !== w && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), f.length !== x && e.emit("slidesGridLengthChange"), i.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !(l || i.cssMode || "slide" !== i.effect && "fade" !== i.effect)) {
							const t = i.containerModifierClass + "backface-hidden",
								n = e.el.classList.contains(t);
							u <= i.maxBackfaceHiddenSlides ? n || e.el.classList.add(t) : n && e.el.classList.remove(t)
						}
					},
					updateAutoHeight: function(e) {
						const t = this,
							i = [],
							n = t.virtual && t.params.virtual.enabled;
						let r, o = 0;
						"number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
						const s = e => n ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
						if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
							if (t.params.centeredSlides)(t.visibleSlides || []).forEach(e => {
								i.push(e)
							});
							else
								for (r = 0; r < Math.ceil(t.params.slidesPerView); r += 1) {
									const e = t.activeIndex + r;
									if (e > t.slides.length && !n) break;
									i.push(s(e))
								} else i.push(s(t.activeIndex));
						for (r = 0; r < i.length; r += 1)
							if (void 0 !== i[r]) {
								const e = i[r].offsetHeight;
								o = e > o ? e : o
							}(o || 0 === o) && (t.wrapperEl.style.height = o + "px")
					},
					updateSlidesOffset: function() {
						const e = this,
							t = e.slides,
							i = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
						for (let n = 0; n < t.length; n += 1) t[n].swiperSlideOffset = (e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop) - i - e.cssOverflowAdjustment()
					},
					updateSlidesProgress: function(e) {
						void 0 === e && (e = this && this.translate || 0);
						const t = this,
							i = t.params,
							{
								slides: n,
								rtlTranslate: r,
								snapGrid: o
							} = t;
						if (0 === n.length) return;
						void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset();
						let s = -e;
						r && (s = e), t.visibleSlidesIndexes = [], t.visibleSlides = [];
						let a = i.spaceBetween;
						"string" == typeof a && a.indexOf("%") >= 0 ? a = parseFloat(a.replace("%", "")) / 100 * t.size : "string" == typeof a && (a = parseFloat(a));
						for (let e = 0; e < n.length; e += 1) {
							const l = n[e];
							let c = l.swiperSlideOffset;
							i.cssMode && i.centeredSlides && (c -= n[0].swiperSlideOffset);
							const h = (s + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a),
								u = (s - o[0] + (i.centeredSlides ? t.minTranslate() : 0) - c) / (l.swiperSlideSize + a),
								d = -(s - c),
								p = d + t.slidesSizesGrid[e],
								f = d >= 0 && d <= t.size - t.slidesSizesGrid[e],
								m = d >= 0 && d < t.size - 1 || p > 1 && p <= t.size || d <= 0 && p >= t.size;
							m && (t.visibleSlides.push(l), t.visibleSlidesIndexes.push(e)), R(l, m, i.slideVisibleClass), R(l, f, i.slideFullyVisibleClass), l.progress = r ? -h : h, l.originalProgress = r ? -u : u
						}
					},
					updateProgress: function(e) {
						const t = this;
						if (void 0 === e) {
							const i = t.rtlTranslate ? -1 : 1;
							e = t && t.translate && t.translate * i || 0
						}
						const i = t.params,
							n = t.maxTranslate() - t.minTranslate();
						let {
							progress: r,
							isBeginning: o,
							isEnd: s,
							progressLoop: a
						} = t;
						const l = o,
							c = s;
						if (0 === n) r = 0, o = !0, s = !0;
						else {
							r = (e - t.minTranslate()) / n;
							const i = Math.abs(e - t.minTranslate()) < 1,
								a = Math.abs(e - t.maxTranslate()) < 1;
							o = i || r <= 0, s = a || r >= 1, i && (r = 0), a && (r = 1)
						}
						if (i.loop) {
							const i = t.getSlideIndexByData(0),
								n = t.getSlideIndexByData(t.slides.length - 1),
								r = t.slidesGrid[i],
								o = t.slidesGrid[n],
								s = t.slidesGrid[t.slidesGrid.length - 1],
								l = Math.abs(e);
							a = l >= r ? (l - r) / s : (l + s - o) / s, a > 1 && (a -= 1)
						}
						Object.assign(t, {
							progress: r,
							progressLoop: a,
							isBeginning: o,
							isEnd: s
						}), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), o && !l && t.emit("reachBeginning toEdge"), s && !c && t.emit("reachEnd toEdge"), (l && !o || c && !s) && t.emit("fromEdge"), t.emit("progress", r)
					},
					updateSlidesClasses: function() {
						const e = this,
							{
								slides: t,
								params: i,
								slidesEl: n,
								activeIndex: r
							} = e,
							o = e.virtual && i.virtual.enabled,
							s = e.grid && i.grid && i.grid.rows > 1,
							a = e => m(n, `.${i.slideClass}${e}, swiper-slide${e}`)[0];
						let l, c, h;
						if (o)
							if (i.loop) {
								let t = r - e.virtual.slidesBefore;
								t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), l = a(`[data-swiper-slide-index="${t}"]`)
							} else l = a(`[data-swiper-slide-index="${r}"]`);
						else s ? (l = t.find(e => e.column === r), h = t.find(e => e.column === r + 1), c = t.find(e => e.column === r - 1)) : l = t[r];
						l && (s || (h = function(e, t) {
							const i = [];
							for (; e.nextElementSibling;) {
								const n = e.nextElementSibling;
								t ? n.matches(t) && i.push(n) : i.push(n), e = n
							}
							return i
						}(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && !h && (h = t[0]), c = function(e, t) {
							const i = [];
							for (; e.previousElementSibling;) {
								const n = e.previousElementSibling;
								t ? n.matches(t) && i.push(n) : i.push(n), e = n
							}
							return i
						}(l, `.${i.slideClass}, swiper-slide`)[0], i.loop && 0 === !c && (c = t[t.length - 1]))), t.forEach(e => {
							O(e, e === l, i.slideActiveClass), O(e, e === h, i.slideNextClass), O(e, e === c, i.slidePrevClass)
						}), e.emitSlidesClasses()
					},
					updateActiveIndex: function(e) {
						const t = this,
							i = t.rtlTranslate ? t.translate : -t.translate,
							{
								snapGrid: n,
								params: r,
								activeIndex: o,
								realIndex: s,
								snapIndex: a
							} = t;
						let l, c = e;
						const h = e => {
							let i = e - t.virtual.slidesBefore;
							return i < 0 && (i = t.virtual.slides.length + i), i >= t.virtual.slides.length && (i -= t.virtual.slides.length), i
						};
						if (void 0 === c && (c = function(e) {
								const {
									slidesGrid: t,
									params: i
								} = e, n = e.rtlTranslate ? e.translate : -e.translate;
								let r;
								for (let e = 0; e < t.length; e += 1) void 0 !== t[e + 1] ? n >= t[e] && n < t[e + 1] - (t[e + 1] - t[e]) / 2 ? r = e : n >= t[e] && n < t[e + 1] && (r = e + 1) : n >= t[e] && (r = e);
								return i.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0), r
							}(t)), n.indexOf(i) >= 0) l = n.indexOf(i);
						else {
							const e = Math.min(r.slidesPerGroupSkip, c);
							l = e + Math.floor((c - e) / r.slidesPerGroup)
						}
						if (l >= n.length && (l = n.length - 1), c === o && !t.params.loop) return void(l !== a && (t.snapIndex = l, t.emit("snapIndexChange")));
						if (c === o && t.params.loop && t.virtual && t.params.virtual.enabled) return void(t.realIndex = h(c));
						const u = t.grid && r.grid && r.grid.rows > 1;
						let d;
						if (t.virtual && r.virtual.enabled && r.loop) d = h(c);
						else if (u) {
							const e = t.slides.find(e => e.column === c);
							let i = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
							Number.isNaN(i) && (i = Math.max(t.slides.indexOf(e), 0)), d = Math.floor(i / r.grid.rows)
						} else if (t.slides[c]) {
							const e = t.slides[c].getAttribute("data-swiper-slide-index");
							d = e ? parseInt(e, 10) : c
						} else d = c;
						Object.assign(t, {
							previousSnapIndex: a,
							snapIndex: l,
							previousRealIndex: s,
							realIndex: d,
							previousIndex: o,
							activeIndex: c
						}), t.initialized && k(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (s !== d && t.emit("realIndexChange"), t.emit("slideChange"))
					},
					updateClickedSlide: function(e, t) {
						const i = this,
							n = i.params;
						let r = e.closest(`.${n.slideClass}, swiper-slide`);
						!r && i.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(e => {
							!r && e.matches && e.matches(`.${n.slideClass}, swiper-slide`) && (r = e)
						});
						let o, s = !1;
						if (r)
							for (let e = 0; e < i.slides.length; e += 1)
								if (i.slides[e] === r) {
									s = !0, o = e;
									break
								} if (!r || !s) return i.clickedSlide = void 0, void(i.clickedIndex = void 0);
						i.clickedSlide = r, i.virtual && i.params.virtual.enabled ? i.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : i.clickedIndex = o, n.slideToClickedSlide && void 0 !== i.clickedIndex && i.clickedIndex !== i.activeIndex && i.slideToClickedSlide()
					}
				},
				translate: {
					getTranslate: function(e) {
						void 0 === e && (e = this.isHorizontal() ? "x" : "y");
						const {
							params: t,
							rtlTranslate: i,
							translate: n,
							wrapperEl: r
						} = this;
						if (t.virtualTranslate) return i ? -n : n;
						if (t.cssMode) return n;
						let o = c(r, e);
						return o += this.cssOverflowAdjustment(), i && (o = -o), o || 0
					},
					setTranslate: function(e, t) {
						const i = this,
							{
								rtlTranslate: n,
								params: r,
								wrapperEl: o,
								progress: s
							} = i;
						let a, l = 0,
							c = 0;
						i.isHorizontal() ? l = n ? -e : e : c = e, r.roundLengths && (l = Math.floor(l), c = Math.floor(c)), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? l : c, r.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : r.virtualTranslate || (i.isHorizontal() ? l -= i.cssOverflowAdjustment() : c -= i.cssOverflowAdjustment(), o.style.transform = `translate3d(${l}px, ${c}px, 0px)`);
						const h = i.maxTranslate() - i.minTranslate();
						a = 0 === h ? 0 : (e - i.minTranslate()) / h, a !== s && i.updateProgress(e), i.emit("setTranslate", i.translate, t)
					},
					minTranslate: function() {
						return -this.snapGrid[0]
					},
					maxTranslate: function() {
						return -this.snapGrid[this.snapGrid.length - 1]
					},
					translateTo: function(e, t, i, n, r) {
						void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === n && (n = !0);
						const o = this,
							{
								params: s,
								wrapperEl: a
							} = o;
						if (o.animating && s.preventInteractionOnTransition) return !1;
						const l = o.minTranslate(),
							c = o.maxTranslate();
						let h;
						if (h = n && e > l ? l : n && e < c ? c : e, o.updateProgress(h), s.cssMode) {
							const e = o.isHorizontal();
							if (0 === t) a[e ? "scrollLeft" : "scrollTop"] = -h;
							else {
								if (!o.support.smoothScroll) return p({
									swiper: o,
									targetPosition: -h,
									side: e ? "left" : "top"
								}), !0;
								a.scrollTo({
									[e ? "left" : "top"]: -h,
									behavior: "smooth"
								})
							}
							return !0
						}
						return 0 === t ? (o.setTransition(0), o.setTranslate(h), i && (o.emit("beforeTransitionStart", t, r), o.emit("transitionEnd"))) : (o.setTransition(t), o.setTranslate(h), i && (o.emit("beforeTransitionStart", t, r), o.emit("transitionStart")), o.animating || (o.animating = !0, o.onTranslateToWrapperTransitionEnd || (o.onTranslateToWrapperTransitionEnd = function(e) {
							o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onTranslateToWrapperTransitionEnd), o.onTranslateToWrapperTransitionEnd = null, delete o.onTranslateToWrapperTransitionEnd, o.animating = !1, i && o.emit("transitionEnd"))
						}), o.wrapperEl.addEventListener("transitionend", o.onTranslateToWrapperTransitionEnd))), !0
					}
				},
				transition: {
					setTransition: function(e, t) {
						const i = this;
						i.params.cssMode || (i.wrapperEl.style.transitionDuration = e + "ms", i.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), i.emit("setTransition", e, t)
					},
					transitionStart: function(e, t) {
						void 0 === e && (e = !0);
						const i = this,
							{
								params: n
							} = i;
						n.cssMode || (n.autoHeight && i.updateAutoHeight(), N({
							swiper: i,
							runCallbacks: e,
							direction: t,
							step: "Start"
						}))
					},
					transitionEnd: function(e, t) {
						void 0 === e && (e = !0);
						const i = this,
							{
								params: n
							} = i;
						i.animating = !1, n.cssMode || (i.setTransition(0), N({
							swiper: i,
							runCallbacks: e,
							direction: t,
							step: "End"
						}))
					}
				},
				slide: {
					slideTo: function(e, t, i, n, r) {
						void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10));
						const o = this;
						let s = e;
						s < 0 && (s = 0);
						const {
							params: a,
							snapGrid: l,
							slidesGrid: c,
							previousIndex: h,
							activeIndex: u,
							rtlTranslate: d,
							wrapperEl: f,
							enabled: m
						} = o;
						if (!m && !n && !r || o.destroyed || o.animating && a.preventInteractionOnTransition) return !1;
						void 0 === t && (t = o.params.speed);
						const g = Math.min(o.params.slidesPerGroupSkip, s);
						let v = g + Math.floor((s - g) / o.params.slidesPerGroup);
						v >= l.length && (v = l.length - 1);
						const y = -l[v];
						if (a.normalizeSlideIndex)
							for (let e = 0; e < c.length; e += 1) {
								const t = -Math.floor(100 * y),
									i = Math.floor(100 * c[e]),
									n = Math.floor(100 * c[e + 1]);
								void 0 !== c[e + 1] ? t >= i && t < n - (n - i) / 2 ? s = e : t >= i && t < n && (s = e + 1) : t >= i && (s = e)
							}
						if (o.initialized && s !== u) {
							if (!o.allowSlideNext && (d ? y > o.translate && y > o.minTranslate() : y < o.translate && y < o.minTranslate())) return !1;
							if (!o.allowSlidePrev && y > o.translate && y > o.maxTranslate() && (u || 0) !== s) return !1
						}
						let b;
						s !== (h || 0) && i && o.emit("beforeSlideChangeStart"), o.updateProgress(y), b = s > u ? "next" : s < u ? "prev" : "reset";
						const w = o.virtual && o.params.virtual.enabled;
						if ((!w || !r) && (d && -y === o.translate || !d && y === o.translate)) return o.updateActiveIndex(s), a.autoHeight && o.updateAutoHeight(), o.updateSlidesClasses(), "slide" !== a.effect && o.setTranslate(y), "reset" !== b && (o.transitionStart(i, b), o.transitionEnd(i, b)), !1;
						if (a.cssMode) {
							const e = o.isHorizontal(),
								i = d ? y : -y;
							if (0 === t) w && (o.wrapperEl.style.scrollSnapType = "none", o._immediateVirtual = !0), w && !o._cssModeVirtualInitialSet && o.params.initialSlide > 0 ? (o._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
								f[e ? "scrollLeft" : "scrollTop"] = i
							})) : f[e ? "scrollLeft" : "scrollTop"] = i, w && requestAnimationFrame(() => {
								o.wrapperEl.style.scrollSnapType = "", o._immediateVirtual = !1
							});
							else {
								if (!o.support.smoothScroll) return p({
									swiper: o,
									targetPosition: i,
									side: e ? "left" : "top"
								}), !0;
								f.scrollTo({
									[e ? "left" : "top"]: i,
									behavior: "smooth"
								})
							}
							return !0
						}
						const x = I().isSafari;
						return w && !r && x && o.isElement && o.virtual.update(!1, !1, s), o.setTransition(t), o.setTranslate(y), o.updateActiveIndex(s), o.updateSlidesClasses(), o.emit("beforeTransitionStart", t, n), o.transitionStart(i, b), 0 === t ? o.transitionEnd(i, b) : o.animating || (o.animating = !0, o.onSlideToWrapperTransitionEnd || (o.onSlideToWrapperTransitionEnd = function(e) {
							o && !o.destroyed && e.target === this && (o.wrapperEl.removeEventListener("transitionend", o.onSlideToWrapperTransitionEnd), o.onSlideToWrapperTransitionEnd = null, delete o.onSlideToWrapperTransitionEnd, o.transitionEnd(i, b))
						}), o.wrapperEl.addEventListener("transitionend", o.onSlideToWrapperTransitionEnd)), !0
					},
					slideToLoop: function(e, t, i, n) {
						void 0 === e && (e = 0), void 0 === i && (i = !0), "string" == typeof e && (e = parseInt(e, 10));
						const r = this;
						if (r.destroyed) return;
						void 0 === t && (t = r.params.speed);
						const o = r.grid && r.params.grid && r.params.grid.rows > 1;
						let s = e;
						if (r.params.loop)
							if (r.virtual && r.params.virtual.enabled) s += r.virtual.slidesBefore;
							else {
								let e;
								if (o) {
									const t = s * r.params.grid.rows;
									e = r.slides.find(e => 1 * e.getAttribute("data-swiper-slide-index") === t).column
								} else e = r.getSlideIndexByData(s);
								const t = o ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length,
									{
										centeredSlides: i
									} = r.params;
								let a = r.params.slidesPerView;
								"auto" === a ? a = r.slidesPerViewDynamic() : (a = Math.ceil(parseFloat(r.params.slidesPerView, 10)), i && a % 2 == 0 && (a += 1));
								let l = t - e < a;
								if (i && (l = l || e < Math.ceil(a / 2)), n && i && "auto" !== r.params.slidesPerView && !o && (l = !1), l) {
									const n = i ? e < r.activeIndex ? "prev" : "next" : e - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev";
									r.loopFix({
										direction: n,
										slideTo: !0,
										activeSlideIndex: "next" === n ? e + 1 : e - t + 1,
										slideRealIndex: "next" === n ? r.realIndex : void 0
									})
								}
								if (o) {
									const e = s * r.params.grid.rows;
									s = r.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e).column
								} else s = r.getSlideIndexByData(s)
							} return requestAnimationFrame(() => {
							r.slideTo(s, t, i, n)
						}), r
					},
					slideNext: function(e, t, i) {
						void 0 === t && (t = !0);
						const n = this,
							{
								enabled: r,
								params: o,
								animating: s
							} = n;
						if (!r || n.destroyed) return n;
						void 0 === e && (e = n.params.speed);
						let a = o.slidesPerGroup;
						"auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (a = Math.max(n.slidesPerViewDynamic("current", !0), 1));
						const l = n.activeIndex < o.slidesPerGroupSkip ? 1 : a,
							c = n.virtual && o.virtual.enabled;
						if (o.loop) {
							if (s && !c && o.loopPreventsSliding) return !1;
							if (n.loopFix({
									direction: "next"
								}), n._clientLeft = n.wrapperEl.clientLeft, n.activeIndex === n.slides.length - 1 && o.cssMode) return requestAnimationFrame(() => {
								n.slideTo(n.activeIndex + l, e, t, i)
							}), !0
						}
						return o.rewind && n.isEnd ? n.slideTo(0, e, t, i) : n.slideTo(n.activeIndex + l, e, t, i)
					},
					slidePrev: function(e, t, i) {
						void 0 === t && (t = !0);
						const n = this,
							{
								params: r,
								snapGrid: o,
								slidesGrid: s,
								rtlTranslate: a,
								enabled: l,
								animating: c
							} = n;
						if (!l || n.destroyed) return n;
						void 0 === e && (e = n.params.speed);
						const h = n.virtual && r.virtual.enabled;
						if (r.loop) {
							if (c && !h && r.loopPreventsSliding) return !1;
							n.loopFix({
								direction: "prev"
							}), n._clientLeft = n.wrapperEl.clientLeft
						}

						function u(e) {
							return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
						}
						const d = u(a ? n.translate : -n.translate),
							p = o.map(e => u(e)),
							f = r.freeMode && r.freeMode.enabled;
						let m = o[p.indexOf(d) - 1];
						if (void 0 === m && (r.cssMode || f)) {
							let e;
							o.forEach((t, i) => {
								d >= t && (e = i)
							}), void 0 !== e && (m = f ? o[e] : o[e > 0 ? e - 1 : e])
						}
						let g = 0;
						if (void 0 !== m && (g = s.indexOf(m), g < 0 && (g = n.activeIndex - 1), "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (g = g - n.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), r.rewind && n.isBeginning) {
							const r = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
							return n.slideTo(r, e, t, i)
						}
						return r.loop && 0 === n.activeIndex && r.cssMode ? (requestAnimationFrame(() => {
							n.slideTo(g, e, t, i)
						}), !0) : n.slideTo(g, e, t, i)
					},
					slideReset: function(e, t, i) {
						void 0 === t && (t = !0);
						const n = this;
						if (!n.destroyed) return void 0 === e && (e = n.params.speed), n.slideTo(n.activeIndex, e, t, i)
					},
					slideToClosest: function(e, t, i, n) {
						void 0 === t && (t = !0), void 0 === n && (n = .5);
						const r = this;
						if (r.destroyed) return;
						void 0 === e && (e = r.params.speed);
						let o = r.activeIndex;
						const s = Math.min(r.params.slidesPerGroupSkip, o),
							a = s + Math.floor((o - s) / r.params.slidesPerGroup),
							l = r.rtlTranslate ? r.translate : -r.translate;
						if (l >= r.snapGrid[a]) {
							const e = r.snapGrid[a];
							l - e > (r.snapGrid[a + 1] - e) * n && (o += r.params.slidesPerGroup)
						} else {
							const e = r.snapGrid[a - 1];
							l - e <= (r.snapGrid[a] - e) * n && (o -= r.params.slidesPerGroup)
						}
						return o = Math.max(o, 0), o = Math.min(o, r.slidesGrid.length - 1), r.slideTo(o, e, t, i)
					},
					slideToClickedSlide: function() {
						const e = this;
						if (e.destroyed) return;
						const {
							params: t,
							slidesEl: i
						} = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
						let r, o = e.clickedIndex;
						const s = e.isElement ? "swiper-slide" : "." + t.slideClass;
						if (t.loop) {
							if (e.animating) return;
							r = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? o < e.loopedSlides - n / 2 || o > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), o = e.getSlideIndex(m(i, `${s}[data-swiper-slide-index="${r}"]`)[0]), a(() => {
								e.slideTo(o)
							})) : e.slideTo(o) : o > e.slides.length - n ? (e.loopFix(), o = e.getSlideIndex(m(i, `${s}[data-swiper-slide-index="${r}"]`)[0]), a(() => {
								e.slideTo(o)
							})) : e.slideTo(o)
						} else e.slideTo(o)
					}
				},
				loop: {
					loopCreate: function(e) {
						const t = this,
							{
								params: i,
								slidesEl: n
							} = t;
						if (!i.loop || t.virtual && t.params.virtual.enabled) return;
						const r = () => {
								m(n, `.${i.slideClass}, swiper-slide`).forEach((e, t) => {
									e.setAttribute("data-swiper-slide-index", t)
								})
							},
							o = t.grid && i.grid && i.grid.rows > 1,
							s = i.slidesPerGroup * (o ? i.grid.rows : 1),
							a = t.slides.length % s != 0,
							l = o && t.slides.length % i.grid.rows != 0,
							c = e => {
								for (let n = 0; n < e; n += 1) {
									const e = t.isElement ? v("swiper-slide", [i.slideBlankClass]) : v("div", [i.slideClass, i.slideBlankClass]);
									t.slidesEl.append(e)
								}
							};
						a ? (i.loopAddBlankSlides ? (c(s - t.slides.length % s), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), r()) : l ? (i.loopAddBlankSlides ? (c(i.grid.rows - t.slides.length % i.grid.rows), t.recalcSlides(), t.updateSlides()) : g("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"), r()) : r(), t.loopFix({
							slideRealIndex: e,
							direction: i.centeredSlides ? void 0 : "next"
						})
					},
					loopFix: function(e) {
						let {
							slideRealIndex: t,
							slideTo: i = !0,
							direction: n,
							setTranslate: r,
							activeSlideIndex: o,
							byController: s,
							byMousewheel: a
						} = void 0 === e ? {} : e;
						const l = this;
						if (!l.params.loop) return;
						l.emit("beforeLoopFix");
						const {
							slides: c,
							allowSlidePrev: h,
							allowSlideNext: u,
							slidesEl: d,
							params: p
						} = l, {
							centeredSlides: f
						} = p;
						if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && p.virtual.enabled) return i && (p.centeredSlides || 0 !== l.snapIndex ? p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0) : l.slideTo(l.virtual.slides.length, 0, !1, !0)), l.allowSlidePrev = h, l.allowSlideNext = u, void l.emit("loopFix");
						let m = p.slidesPerView;
						"auto" === m ? m = l.slidesPerViewDynamic() : (m = Math.ceil(parseFloat(p.slidesPerView, 10)), f && m % 2 == 0 && (m += 1));
						const v = p.slidesPerGroupAuto ? m : p.slidesPerGroup;
						let y = v;
						y % v != 0 && (y += v - y % v), y += p.loopAdditionalSlides, l.loopedSlides = y;
						const b = l.grid && p.grid && p.grid.rows > 1;
						c.length < m + y ? g("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : b && "row" === p.grid.fill && g("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
						const w = [],
							x = [];
						let _ = l.activeIndex;
						void 0 === o ? o = l.getSlideIndex(c.find(e => e.classList.contains(p.slideActiveClass))) : _ = o;
						const E = "next" === n || !n,
							M = "prev" === n || !n;
						let S = 0,
							T = 0;
						const A = b ? Math.ceil(c.length / p.grid.rows) : c.length,
							L = (b ? c[o].column : o) + (f && void 0 === r ? -m / 2 + .5 : 0);
						if (L < y) {
							S = Math.max(y - L, v);
							for (let e = 0; e < y - L; e += 1) {
								const t = e - Math.floor(e / A) * A;
								if (b) {
									const e = A - t - 1;
									for (let t = c.length - 1; t >= 0; t -= 1) c[t].column === e && w.push(t)
								} else w.push(A - t - 1)
							}
						} else if (L + m > A - y) {
							T = Math.max(L - (A - 2 * y), v);
							for (let e = 0; e < T; e += 1) {
								const t = e - Math.floor(e / A) * A;
								b ? c.forEach((e, i) => {
									e.column === t && x.push(i)
								}) : x.push(t)
							}
						}
						if (l.__preventObserver__ = !0, requestAnimationFrame(() => {
								l.__preventObserver__ = !1
							}), M && w.forEach(e => {
								c[e].swiperLoopMoveDOM = !0, d.prepend(c[e]), c[e].swiperLoopMoveDOM = !1
							}), E && x.forEach(e => {
								c[e].swiperLoopMoveDOM = !0, d.append(c[e]), c[e].swiperLoopMoveDOM = !1
							}), l.recalcSlides(), "auto" === p.slidesPerView ? l.updateSlides() : b && (w.length > 0 && M || x.length > 0 && E) && l.slides.forEach((e, t) => {
								l.grid.updateSlide(t, e, l.slides)
							}), p.watchSlidesProgress && l.updateSlidesOffset(), i)
							if (w.length > 0 && M) {
								if (void 0 === t) {
									const e = l.slidesGrid[_],
										t = l.slidesGrid[_ + S] - e;
									a ? l.setTranslate(l.translate - t) : (l.slideTo(_ + Math.ceil(S), 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
								} else if (r) {
									const e = b ? w.length / p.grid.rows : w.length;
									l.slideTo(l.activeIndex + e, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate
								}
							} else if (x.length > 0 && E)
							if (void 0 === t) {
								const e = l.slidesGrid[_],
									t = l.slidesGrid[_ - T] - e;
								a ? l.setTranslate(l.translate - t) : (l.slideTo(_ - T, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - t, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - t))
							} else {
								const e = b ? x.length / p.grid.rows : x.length;
								l.slideTo(l.activeIndex - e, 0, !1, !0)
							} if (l.allowSlidePrev = h, l.allowSlideNext = u, l.controller && l.controller.control && !s) {
							const e = {
								slideRealIndex: t,
								direction: n,
								setTranslate: r,
								activeSlideIndex: o,
								byController: !0
							};
							Array.isArray(l.controller.control) ? l.controller.control.forEach(t => {
								!t.destroyed && t.params.loop && t.loopFix({
									...e,
									slideTo: t.params.slidesPerView === p.slidesPerView && i
								})
							}) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({
								...e,
								slideTo: l.controller.control.params.slidesPerView === p.slidesPerView && i
							})
						}
						l.emit("loopFix")
					},
					loopDestroy: function() {
						const e = this,
							{
								params: t,
								slidesEl: i
							} = e;
						if (!t.loop || e.virtual && e.params.virtual.enabled) return;
						e.recalcSlides();
						const n = [];
						e.slides.forEach(e => {
							const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
							n[t] = e
						}), e.slides.forEach(e => {
							e.removeAttribute("data-swiper-slide-index")
						}), n.forEach(e => {
							i.append(e)
						}), e.recalcSlides(), e.slideTo(e.realIndex, 0)
					}
				},
				grabCursor: {
					setGrabCursor: function(e) {
						const t = this;
						if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
						const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
						t.isElement && (t.__preventObserver__ = !0), i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame(() => {
							t.__preventObserver__ = !1
						})
					},
					unsetGrabCursor: function() {
						const e = this;
						e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame(() => {
							e.__preventObserver__ = !1
						}))
					}
				},
				events: {
					attachEvents: function() {
						const e = this,
							{
								params: t
							} = e;
						e.onTouchStart = H.bind(e), e.onTouchMove = F.bind(e), e.onTouchEnd = U.bind(e), e.onDocumentTouchStart = q.bind(e), t.cssMode && (e.onScroll = V.bind(e)), e.onClick = G.bind(e), e.onLoad = W.bind(e), X(e, "on")
					},
					detachEvents: function() {
						X(this, "off")
					}
				},
				breakpoints: {
					setBreakpoint: function() {
						const e = this,
							{
								realIndex: t,
								initialized: i,
								params: r,
								el: o
							} = e,
							s = r.breakpoints;
						if (!s || s && 0 === Object.keys(s).length) return;
						const a = n(),
							l = "window" !== r.breakpointsBase && r.breakpointsBase ? "container" : r.breakpointsBase,
							c = ["window", "container"].includes(r.breakpointsBase) || !r.breakpointsBase ? e.el : a.querySelector(r.breakpointsBase),
							h = e.getBreakpoint(s, l, c);
						if (!h || e.currentBreakpoint === h) return;
						const d = (h in s ? s[h] : void 0) || e.originalParams,
							p = Y(e, r),
							f = Y(e, d),
							m = e.params.grabCursor,
							g = d.grabCursor,
							v = r.enabled;
						p && !f ? (o.classList.remove(r.containerModifierClass + "grid", r.containerModifierClass + "grid-column"), e.emitContainerClasses()) : !p && f && (o.classList.add(r.containerModifierClass + "grid"), (d.grid.fill && "column" === d.grid.fill || !d.grid.fill && "column" === r.grid.fill) && o.classList.add(r.containerModifierClass + "grid-column"), e.emitContainerClasses()), m && !g ? e.unsetGrabCursor() : !m && g && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(t => {
							if (void 0 === d[t]) return;
							const i = r[t] && r[t].enabled,
								n = d[t] && d[t].enabled;
							i && !n && e[t].disable(), !i && n && e[t].enable()
						});
						const y = d.direction && d.direction !== r.direction,
							b = r.loop && (d.slidesPerView !== r.slidesPerView || y),
							w = r.loop;
						y && i && e.changeDirection(), u(e.params, d);
						const x = e.params.enabled,
							_ = e.params.loop;
						Object.assign(e, {
							allowTouchMove: e.params.allowTouchMove,
							allowSlideNext: e.params.allowSlideNext,
							allowSlidePrev: e.params.allowSlidePrev
						}), v && !x ? e.disable() : !v && x && e.enable(), e.currentBreakpoint = h, e.emit("_beforeBreakpoint", d), i && (b ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !w && _ ? (e.loopCreate(t), e.updateSlides()) : w && !_ && e.loopDestroy()), e.emit("breakpoint", d)
					},
					getBreakpoint: function(e, t, i) {
						if (void 0 === t && (t = "window"), !e || "container" === t && !i) return;
						let n = !1;
						const r = o(),
							s = "window" === t ? r.innerHeight : i.clientHeight,
							a = Object.keys(e).map(e => {
								if ("string" == typeof e && 0 === e.indexOf("@")) {
									const t = parseFloat(e.substr(1));
									return {
										value: s * t,
										point: e
									}
								}
								return {
									value: e,
									point: e
								}
							});
						a.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
						for (let e = 0; e < a.length; e += 1) {
							const {
								point: o,
								value: s
							} = a[e];
							"window" === t ? r.matchMedia(`(min-width: ${s}px)`).matches && (n = o) : s <= i.clientWidth && (n = o)
						}
						return n || "max"
					}
				},
				checkOverflow: {
					checkOverflow: function() {
						const e = this,
							{
								isLocked: t,
								params: i
							} = e,
							{
								slidesOffsetBefore: n
							} = i;
						if (n) {
							const t = e.slides.length - 1,
								i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * n;
							e.isLocked = e.size > i
						} else e.isLocked = 1 === e.snapGrid.length;
						!0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
					}
				},
				classes: {
					addClasses: function() {
						const e = this,
							{
								classNames: t,
								params: i,
								rtl: n,
								el: r,
								device: o
							} = e,
							s = function(e, t) {
								const i = [];
								return e.forEach(e => {
									"object" == typeof e ? Object.keys(e).forEach(n => {
										e[n] && i.push(t + n)
									}) : "string" == typeof e && i.push(t + e)
								}), i
							}(["initialized", i.direction, {
								"free-mode": e.params.freeMode && i.freeMode.enabled
							}, {
								autoheight: i.autoHeight
							}, {
								rtl: n
							}, {
								grid: i.grid && i.grid.rows > 1
							}, {
								"grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
							}, {
								android: o.android
							}, {
								ios: o.ios
							}, {
								"css-mode": i.cssMode
							}, {
								centered: i.cssMode && i.centeredSlides
							}, {
								"watch-progress": i.watchSlidesProgress
							}], i.containerModifierClass);
						t.push(...s), r.classList.add(...t), e.emitContainerClasses()
					},
					removeClasses: function() {
						const {
							el: e,
							classNames: t
						} = this;
						e && "string" != typeof e && (e.classList.remove(...t), this.emitContainerClasses())
					}
				}
			},
			K = {};
		class $ {
			constructor() {
				let e, t;
				for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++) r[o] = arguments[o];
				1 === r.length && r[0].constructor && "Object" === Object.prototype.toString.call(r[0]).slice(8, -1) ? t = r[0] : [e, t] = r, t || (t = {}), t = u({}, t), e && !t.el && (t.el = e);
				const s = n();
				if (t.el && "string" == typeof t.el && s.querySelectorAll(t.el).length > 1) {
					const e = [];
					return s.querySelectorAll(t.el).forEach(i => {
						const n = u({}, t, {
							el: i
						});
						e.push(new $(n))
					}), e
				}
				const a = this;
				a.__swiper__ = !0, a.support = C(), a.device = P({
					userAgent: t.userAgent
				}), a.browser = I(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], t.modules && Array.isArray(t.modules) && a.modules.push(...t.modules);
				const l = {};
				a.modules.forEach(e => {
					e({
						params: t,
						swiper: a,
						extendParams: Q(t, l),
						on: a.on.bind(a),
						once: a.once.bind(a),
						off: a.off.bind(a),
						emit: a.emit.bind(a)
					})
				});
				const c = u({}, Z, l);
				return a.params = u({}, c, K, t), a.originalParams = u({}, a.params), a.passedParams = u({}, t), a.params && a.params.on && Object.keys(a.params.on).forEach(e => {
					a.on(e, a.params.on[e])
				}), a.params && a.params.onAny && a.onAny(a.params.onAny), Object.assign(a, {
					enabled: a.params.enabled,
					el: e,
					classNames: [],
					slides: [],
					slidesGrid: [],
					snapGrid: [],
					slidesSizesGrid: [],
					isHorizontal: () => "horizontal" === a.params.direction,
					isVertical: () => "vertical" === a.params.direction,
					activeIndex: 0,
					realIndex: 0,
					isBeginning: !0,
					isEnd: !1,
					translate: 0,
					previousTranslate: 0,
					progress: 0,
					velocity: 0,
					animating: !1,
					cssOverflowAdjustment() {
						return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
					},
					allowSlideNext: a.params.allowSlideNext,
					allowSlidePrev: a.params.allowSlidePrev,
					touchEventsData: {
						isTouched: void 0,
						isMoved: void 0,
						allowTouchCallbacks: void 0,
						touchStartTime: void 0,
						isScrolling: void 0,
						currentTranslate: void 0,
						startTranslate: void 0,
						allowThresholdMove: void 0,
						focusableElements: a.params.focusableElements,
						lastClickTime: 0,
						clickTimeout: void 0,
						velocities: [],
						allowMomentumBounce: void 0,
						startMoving: void 0,
						pointerId: null,
						touchId: null
					},
					allowClick: !0,
					allowTouchMove: a.params.allowTouchMove,
					touches: {
						startX: 0,
						startY: 0,
						currentX: 0,
						currentY: 0,
						diff: 0
					},
					imagesToLoad: [],
					imagesLoaded: 0
				}), a.emit("_swiper"), a.params.init && a.init(), a
			}
			getDirectionLabel(e) {
				return this.isHorizontal() ? e : {
					width: "height",
					"margin-top": "margin-left",
					"margin-bottom ": "margin-right",
					"margin-left": "margin-top",
					"margin-right": "margin-bottom",
					"padding-left": "padding-top",
					"padding-right": "padding-bottom",
					marginRight: "marginBottom"
				} [e]
			}
			getSlideIndex(e) {
				const {
					slidesEl: t,
					params: i
				} = this, n = w(m(t, `.${i.slideClass}, swiper-slide`)[0]);
				return w(e) - n
			}
			getSlideIndexByData(e) {
				return this.getSlideIndex(this.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e))
			}
			recalcSlides() {
				const {
					slidesEl: e,
					params: t
				} = this;
				this.slides = m(e, `.${t.slideClass}, swiper-slide`)
			}
			enable() {
				const e = this;
				e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
			}
			disable() {
				const e = this;
				e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
			}
			setProgress(e, t) {
				const i = this;
				e = Math.min(Math.max(e, 0), 1);
				const n = i.minTranslate(),
					r = (i.maxTranslate() - n) * e + n;
				i.translateTo(r, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
			}
			emitContainerClasses() {
				const e = this;
				if (!e.params._emitClasses || !e.el) return;
				const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass));
				e.emit("_containerClasses", t.join(" "))
			}
			getSlideClasses(e) {
				const t = this;
				return t.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ")
			}
			emitSlidesClasses() {
				const e = this;
				if (!e.params._emitClasses || !e.el) return;
				const t = [];
				e.slides.forEach(i => {
					const n = e.getSlideClasses(i);
					t.push({
						slideEl: i,
						classNames: n
					}), e.emit("_slideClass", i, n)
				}), e.emit("_slideClasses", t)
			}
			slidesPerViewDynamic(e, t) {
				void 0 === e && (e = "current"), void 0 === t && (t = !1);
				const {
					params: i,
					slides: n,
					slidesGrid: r,
					slidesSizesGrid: o,
					size: s,
					activeIndex: a
				} = this;
				let l = 1;
				if ("number" == typeof i.slidesPerView) return i.slidesPerView;
				if (i.centeredSlides) {
					let e, t = n[a] ? Math.ceil(n[a].swiperSlideSize) : 0;
					for (let i = a + 1; i < n.length; i += 1) n[i] && !e && (t += Math.ceil(n[i].swiperSlideSize), l += 1, t > s && (e = !0));
					for (let i = a - 1; i >= 0; i -= 1) n[i] && !e && (t += n[i].swiperSlideSize, l += 1, t > s && (e = !0))
				} else if ("current" === e)
					for (let e = a + 1; e < n.length; e += 1)(t ? r[e] + o[e] - r[a] < s : r[e] - r[a] < s) && (l += 1);
				else
					for (let e = a - 1; e >= 0; e -= 1) r[a] - r[e] < s && (l += 1);
				return l
			}
			update() {
				const e = this;
				if (!e || e.destroyed) return;
				const {
					snapGrid: t,
					params: i
				} = e;

				function n() {
					const t = e.rtlTranslate ? -1 * e.translate : e.translate,
						i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
					e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
				}
				let r;
				if (i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(t => {
						t.complete && D(e, t)
					}), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), i.freeMode && i.freeMode.enabled && !i.cssMode) n(), i.autoHeight && e.updateAutoHeight();
				else {
					if (("auto" === i.slidesPerView || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) {
						const t = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides;
						r = e.slideTo(t.length - 1, 0, !1, !0)
					} else r = e.slideTo(e.activeIndex, 0, !1, !0);
					r || n()
				}
				i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
			}
			changeDirection(e, t) {
				void 0 === t && (t = !0);
				const i = this,
					n = i.params.direction;
				return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.el.classList.remove(`${i.params.containerModifierClass}${n}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach(t => {
					"vertical" === e ? t.style.width = "" : t.style.height = ""
				}), i.emit("changeDirection"), t && i.update()), i
			}
			changeLanguageDirection(e) {
				const t = this;
				t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(t.params.containerModifierClass + "rtl"), t.el.dir = "rtl") : (t.el.classList.remove(t.params.containerModifierClass + "rtl"), t.el.dir = "ltr"), t.update())
			}
			mount(e) {
				const t = this;
				if (t.mounted) return !0;
				let i = e || t.params.el;
				if ("string" == typeof i && (i = document.querySelector(i)), !i) return !1;
				i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
				const n = () => "." + (t.params.wrapperClass || "").trim().split(" ").join(".");
				let r = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(n()) : m(i, n())[0];
				return !r && t.params.createElements && (r = v("div", t.params.wrapperClass), i.append(r), m(i, "." + t.params.slideClass).forEach(e => {
					r.append(e)
				})), Object.assign(t, {
					el: i,
					wrapperEl: r,
					slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : r,
					hostEl: t.isElement ? i.parentNode.host : i,
					mounted: !0,
					rtl: "rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction"),
					rtlTranslate: "horizontal" === t.params.direction && ("rtl" === i.dir.toLowerCase() || "rtl" === b(i, "direction")),
					wrongRTL: "-webkit-box" === b(r, "display")
				}), !0
			}
			init(e) {
				const t = this;
				if (t.initialized) return t;
				if (!1 === t.mount(e)) return t;
				t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
				const i = [...t.el.querySelectorAll('[loading="lazy"]')];
				return t.isElement && i.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach(e => {
					e.complete ? D(t, e) : e.addEventListener("load", e => {
						D(t, e.target)
					})
				}), k(t), t.initialized = !0, k(t), t.emit("init"), t.emit("afterInit"), t
			}
			destroy(e, t) {
				void 0 === e && (e = !0), void 0 === t && (t = !0);
				const i = this,
					{
						params: n,
						el: r,
						wrapperEl: o,
						slides: s
					} = i;
				return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), r && "string" != typeof r && r.removeAttribute("style"), o && o.removeAttribute("style"), s && s.length && s.forEach(e => {
					e.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index")
				})), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(e => {
					i.off(e)
				}), !1 !== e && (i.el && "string" != typeof i.el && (i.el.swiper = null), function(e) {
					const t = e;
					Object.keys(t).forEach(e => {
						try {
							t[e] = null
						} catch (e) {}
						try {
							delete t[e]
						} catch (e) {}
					})
				}(i)), i.destroyed = !0), null
			}
			static extendDefaults(e) {
				u(K, e)
			}
			static get extendedDefaults() {
				return K
			}
			static get defaults() {
				return Z
			}
			static installModule(e) {
				$.prototype.__modules__ || ($.prototype.__modules__ = []);
				const t = $.prototype.__modules__;
				"function" == typeof e && t.indexOf(e) < 0 && t.push(e)
			}
			static use(e) {
				return Array.isArray(e) ? (e.forEach(e => $.installModule(e)), $) : ($.installModule(e), $)
			}
		}

		function ee(e, t, i, n) {
			return e.params.createElements && Object.keys(n).forEach(r => {
				if (!i[r] && !0 === i.auto) {
					let o = m(e.el, "." + n[r])[0];
					o || (o = v("div", n[r]), o.className = n[r], e.el.append(o)), i[r] = o, t[r] = o
				}
			}), i
		}

		function te(e) {
			return void 0 === e && (e = ""), "." + e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")
		}

		function ie(e) {
			const t = this,
				{
					params: i,
					slidesEl: n
				} = t;
			i.loop && t.loopDestroy();
			const r = e => {
				if ("string" == typeof e) {
					const t = document.createElement("div");
					t.innerHTML = e, n.append(t.children[0]), t.innerHTML = ""
				} else n.append(e)
			};
			if ("object" == typeof e && "length" in e)
				for (let t = 0; t < e.length; t += 1) e[t] && r(e[t]);
			else r(e);
			t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update()
		}

		function ne(e) {
			const t = this,
				{
					params: i,
					activeIndex: n,
					slidesEl: r
				} = t;
			i.loop && t.loopDestroy();
			let o = n + 1;
			const s = e => {
				if ("string" == typeof e) {
					const t = document.createElement("div");
					t.innerHTML = e, r.prepend(t.children[0]), t.innerHTML = ""
				} else r.prepend(e)
			};
			if ("object" == typeof e && "length" in e) {
				for (let t = 0; t < e.length; t += 1) e[t] && s(e[t]);
				o = n + e.length
			} else s(e);
			t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), t.slideTo(o, 0, !1)
		}

		function re(e, t) {
			const i = this,
				{
					params: n,
					activeIndex: r,
					slidesEl: o
				} = i;
			let s = r;
			n.loop && (s -= i.loopedSlides, i.loopDestroy(), i.recalcSlides());
			const a = i.slides.length;
			if (e <= 0) return void i.prependSlide(t);
			if (e >= a) return void i.appendSlide(t);
			let l = s > e ? s + 1 : s;
			const c = [];
			for (let t = a - 1; t >= e; t -= 1) {
				const e = i.slides[t];
				e.remove(), c.unshift(e)
			}
			if ("object" == typeof t && "length" in t) {
				for (let e = 0; e < t.length; e += 1) t[e] && o.append(t[e]);
				l = s > e ? s + t.length : s
			} else o.append(t);
			for (let e = 0; e < c.length; e += 1) o.append(c[e]);
			i.recalcSlides(), n.loop && i.loopCreate(), n.observer && !i.isElement || i.update(), n.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1)
		}

		function oe(e) {
			const t = this,
				{
					params: i,
					activeIndex: n
				} = t;
			let r = n;
			i.loop && (r -= t.loopedSlides, t.loopDestroy());
			let o, s = r;
			if ("object" == typeof e && "length" in e) {
				for (let i = 0; i < e.length; i += 1) o = e[i], t.slides[o] && t.slides[o].remove(), o < s && (s -= 1);
				s = Math.max(s, 0)
			} else o = e, t.slides[o] && t.slides[o].remove(), o < s && (s -= 1), s = Math.max(s, 0);
			t.recalcSlides(), i.loop && t.loopCreate(), i.observer && !t.isElement || t.update(), i.loop ? t.slideTo(s + t.loopedSlides, 0, !1) : t.slideTo(s, 0, !1)
		}

		function se() {
			const e = this,
				t = [];
			for (let i = 0; i < e.slides.length; i += 1) t.push(i);
			e.removeSlide(t)
		}

		function ae(e) {
			const {
				effect: t,
				swiper: i,
				on: n,
				setTranslate: r,
				setTransition: o,
				overwriteParams: s,
				perspective: a,
				recreateShadows: l,
				getEffectParams: c
			} = e;
			let h;
			n("beforeInit", () => {
				if (i.params.effect !== t) return;
				i.classNames.push(`${i.params.containerModifierClass}${t}`), a && a() && i.classNames.push(i.params.containerModifierClass + "3d");
				const e = s ? s() : {};
				Object.assign(i.params, e), Object.assign(i.originalParams, e)
			}), n("setTranslate", () => {
				i.params.effect === t && r()
			}), n("setTransition", (e, n) => {
				i.params.effect === t && o(n)
			}), n("transitionEnd", () => {
				if (i.params.effect === t && l) {
					if (!c || !c().slideShadows) return;
					i.slides.forEach(e => {
						e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(e => e.remove())
					}), l()
				}
			}), n("virtualUpdate", () => {
				i.params.effect === t && (i.slides.length || (h = !0), requestAnimationFrame(() => {
					h && i.slides && i.slides.length && (r(), h = !1)
				}))
			})
		}

		function le(e, t) {
			const i = f(t);
			return i !== t && (i.style.backfaceVisibility = "hidden", i.style["-webkit-backface-visibility"] = "hidden"), i
		}

		function ce(e) {
			let {
				swiper: t,
				duration: i,
				transformElements: n,
				allSlides: r
			} = e;
			const {
				activeIndex: o
			} = t;
			if (t.params.virtualTranslate && 0 !== i) {
				let e, i = !1;
				e = r ? n : n.filter(e => {
					const i = e.classList.contains("swiper-slide-transform") ? (e => e.parentElement ? e.parentElement : t.slides.find(t => t.shadowRoot && t.shadowRoot === e.parentNode))(e) : e;
					return t.getSlideIndex(i) === o
				}), e.forEach(e => {
					_(e, () => {
						if (i) return;
						if (!t || t.destroyed) return;
						i = !0, t.animating = !1;
						const e = new window.CustomEvent("transitionend", {
							bubbles: !0,
							cancelable: !0
						});
						t.wrapperEl.dispatchEvent(e)
					})
				})
			}
		}

		function he(e, t, i) {
			const n = `swiper-slide-shadow${i?"-"+i:""}${e?" swiper-slide-shadow-"+e:""}`,
				r = f(t);
			let o = r.querySelector("." + n.split(" ").join("."));
			return o || (o = v("div", n.split(" ")), r.append(o)), o
		}
		Object.keys(J).forEach(e => {
			Object.keys(J[e]).forEach(t => {
				$.prototype[t] = J[e][t]
			})
		}), $.use([function(e) {
			let {
				swiper: t,
				on: i,
				emit: n
			} = e;
			const r = o();
			let s = null,
				a = null;
			const l = () => {
					t && !t.destroyed && t.initialized && (n("beforeResize"), n("resize"))
				},
				c = () => {
					t && !t.destroyed && t.initialized && n("orientationchange")
				};
			i("init", () => {
				t.params.resizeObserver && void 0 !== r.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver(e => {
					a = r.requestAnimationFrame(() => {
						const {
							width: i,
							height: n
						} = t;
						let r = i,
							o = n;
						e.forEach(e => {
							let {
								contentBoxSize: i,
								contentRect: n,
								target: s
							} = e;
							s && s !== t.el || (r = n ? n.width : (i[0] || i).inlineSize, o = n ? n.height : (i[0] || i).blockSize)
						}), r === i && o === n || l()
					})
				}), s.observe(t.el)) : (r.addEventListener("resize", l), r.addEventListener("orientationchange", c))
			}), i("destroy", () => {
				a && r.cancelAnimationFrame(a), s && s.unobserve && t.el && (s.unobserve(t.el), s = null), r.removeEventListener("resize", l), r.removeEventListener("orientationchange", c)
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n,
				emit: r
			} = e;
			const s = [],
				a = o(),
				l = function(e, i) {
					void 0 === i && (i = {});
					const n = new(a.MutationObserver || a.WebkitMutationObserver)(e => {
						if (t.__preventObserver__) return;
						if (1 === e.length) return void r("observerUpdate", e[0]);
						const i = function() {
							r("observerUpdate", e[0])
						};
						a.requestAnimationFrame ? a.requestAnimationFrame(i) : a.setTimeout(i, 0)
					});
					n.observe(e, {
						attributes: void 0 === i.attributes || i.attributes,
						childList: t.isElement || (void 0 === i.childList || i).childList,
						characterData: void 0 === i.characterData || i.characterData
					}), s.push(n)
				};
			i({
				observer: !1,
				observeParents: !1,
				observeSlideChildren: !1
			}), n("init", () => {
				if (t.params.observer) {
					if (t.params.observeParents) {
						const e = x(t.hostEl);
						for (let t = 0; t < e.length; t += 1) l(e[t])
					}
					l(t.hostEl, {
						childList: t.params.observeSlideChildren
					}), l(t.wrapperEl, {
						attributes: !1
					})
				}
			}), n("destroy", () => {
				s.forEach(e => {
					e.disconnect()
				}), s.splice(0, s.length)
			})
		}]);
		const ue = [function(e) {
			let t, {
				swiper: i,
				extendParams: r,
				on: o,
				emit: s
			} = e;
			r({
				virtual: {
					enabled: !1,
					slides: [],
					cache: !0,
					renderSlide: null,
					renderExternal: null,
					renderExternalUpdate: !0,
					addSlidesBefore: 0,
					addSlidesAfter: 0
				}
			});
			const a = n();
			i.virtual = {
				cache: {},
				from: void 0,
				to: void 0,
				slides: [],
				offset: 0,
				slidesGrid: []
			};
			const l = a.createElement("div");

			function c(e, t) {
				const n = i.params.virtual;
				if (n.cache && i.virtual.cache[t]) return i.virtual.cache[t];
				let r;
				return n.renderSlide ? (r = n.renderSlide.call(i, e, t), "string" == typeof r && (l.innerHTML = r, r = l.children[0])) : r = i.isElement ? v("swiper-slide") : v("div", i.params.slideClass), r.setAttribute("data-swiper-slide-index", t), n.renderSlide || (r.innerHTML = e), n.cache && (i.virtual.cache[t] = r), r
			}

			function h(e, t, n) {
				const {
					slidesPerView: r,
					slidesPerGroup: o,
					centeredSlides: a,
					loop: l,
					initialSlide: h
				} = i.params;
				if (t && !l && h > 0) return;
				const {
					addSlidesBefore: u,
					addSlidesAfter: d
				} = i.params.virtual, {
					from: p,
					to: f,
					slides: g,
					slidesGrid: v,
					offset: y
				} = i.virtual;
				i.params.cssMode || i.updateActiveIndex();
				const b = void 0 === n ? i.activeIndex || 0 : n;
				let w, x, _;
				w = i.rtlTranslate ? "right" : i.isHorizontal() ? "left" : "top", a ? (x = Math.floor(r / 2) + o + d, _ = Math.floor(r / 2) + o + u) : (x = r + (o - 1) + d, _ = (l ? r : o) + u);
				let E = b - _,
					M = b + x;
				l || (E = Math.max(E, 0), M = Math.min(M, g.length - 1));
				let S = (i.slidesGrid[E] || 0) - (i.slidesGrid[0] || 0);

				function T() {
					i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), s("virtualUpdate")
				}
				if (l && b >= _ ? (E -= _, a || (S += i.slidesGrid[0])) : l && b < _ && (E = -_, a && (S += i.slidesGrid[0])), Object.assign(i.virtual, {
						from: E,
						to: M,
						offset: S,
						slidesGrid: i.slidesGrid,
						slidesBefore: _,
						slidesAfter: x
					}), p === E && f === M && !e) return i.slidesGrid !== v && S !== y && i.slides.forEach(e => {
					e.style[w] = S - Math.abs(i.cssOverflowAdjustment()) + "px"
				}), i.updateProgress(), void s("virtualUpdate");
				if (i.params.virtual.renderExternal) return i.params.virtual.renderExternal.call(i, {
					offset: S,
					from: E,
					to: M,
					slides: function() {
						const e = [];
						for (let t = E; t <= M; t += 1) e.push(g[t]);
						return e
					}()
				}), void(i.params.virtual.renderExternalUpdate ? T() : s("virtualUpdate"));
				const A = [],
					L = [],
					C = e => {
						let t = e;
						return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t
					};
				if (e) i.slides.filter(e => e.matches(`.${i.params.slideClass}, swiper-slide`)).forEach(e => {
					e.remove()
				});
				else
					for (let e = p; e <= f; e += 1)
						if (e < E || e > M) {
							const t = C(e);
							i.slides.filter(e => e.matches(`.${i.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`)).forEach(e => {
								e.remove()
							})
						} const P = l ? -g.length : 0,
					I = l ? 2 * g.length : g.length;
				for (let t = P; t < I; t += 1)
					if (t >= E && t <= M) {
						const i = C(t);
						void 0 === f || e ? L.push(i) : (t > f && L.push(i), t < p && A.push(i))
					} if (L.forEach(e => {
						i.slidesEl.append(c(g[e], e))
					}), l)
					for (let e = A.length - 1; e >= 0; e -= 1) {
						const t = A[e];
						i.slidesEl.prepend(c(g[t], t))
					} else A.sort((e, t) => t - e), A.forEach(e => {
						i.slidesEl.prepend(c(g[e], e))
					});
				m(i.slidesEl, ".swiper-slide, swiper-slide").forEach(e => {
					e.style[w] = S - Math.abs(i.cssOverflowAdjustment()) + "px"
				}), T()
			}
			o("beforeInit", () => {
				if (!i.params.virtual.enabled) return;
				let e;
				if (void 0 === i.passedParams.virtual.slides) {
					const t = [...i.slidesEl.children].filter(e => e.matches(`.${i.params.slideClass}, swiper-slide`));
					t && t.length && (i.virtual.slides = [...t], e = !0, t.forEach((e, t) => {
						e.setAttribute("data-swiper-slide-index", t), i.virtual.cache[t] = e, e.remove()
					}))
				}
				e || (i.virtual.slides = i.params.virtual.slides), i.classNames.push(i.params.containerModifierClass + "virtual"), i.params.watchSlidesProgress = !0, i.originalParams.watchSlidesProgress = !0, h(!1, !0)
			}), o("setTranslate", () => {
				i.params.virtual.enabled && (i.params.cssMode && !i._immediateVirtual ? (clearTimeout(t), t = setTimeout(() => {
					h()
				}, 100)) : h())
			}), o("init update resize", () => {
				i.params.virtual.enabled && i.params.cssMode && d(i.wrapperEl, "--swiper-virtual-size", i.virtualSize + "px")
			}), Object.assign(i.virtual, {
				appendSlide: function(e) {
					if ("object" == typeof e && "length" in e)
						for (let t = 0; t < e.length; t += 1) e[t] && i.virtual.slides.push(e[t]);
					else i.virtual.slides.push(e);
					h(!0)
				},
				prependSlide: function(e) {
					const t = i.activeIndex;
					let n = t + 1,
						r = 1;
					if (Array.isArray(e)) {
						for (let t = 0; t < e.length; t += 1) e[t] && i.virtual.slides.unshift(e[t]);
						n = t + e.length, r = e.length
					} else i.virtual.slides.unshift(e);
					if (i.params.virtual.cache) {
						const e = i.virtual.cache,
							t = {};
						Object.keys(e).forEach(i => {
							const n = e[i],
								o = n.getAttribute("data-swiper-slide-index");
							o && n.setAttribute("data-swiper-slide-index", parseInt(o, 10) + r), t[parseInt(i, 10) + r] = n
						}), i.virtual.cache = t
					}
					h(!0), i.slideTo(n, 0)
				},
				removeSlide: function(e) {
					if (null == e) return;
					let t = i.activeIndex;
					if (Array.isArray(e))
						for (let n = e.length - 1; n >= 0; n -= 1) i.params.virtual.cache && (delete i.virtual.cache[e[n]], Object.keys(i.virtual.cache).forEach(t => {
							t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t])
						})), i.virtual.slides.splice(e[n], 1), e[n] < t && (t -= 1), t = Math.max(t, 0);
					else i.params.virtual.cache && (delete i.virtual.cache[e], Object.keys(i.virtual.cache).forEach(t => {
						t > e && (i.virtual.cache[t - 1] = i.virtual.cache[t], i.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete i.virtual.cache[t])
					})), i.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0);
					h(!0), i.slideTo(t, 0)
				},
				removeAllSlides: function() {
					i.virtual.slides = [], i.params.virtual.cache && (i.virtual.cache = {}), h(!0), i.slideTo(0, 0)
				},
				update: h
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: r,
				emit: s
			} = e;
			const a = n(),
				l = o();

			function c(e) {
				if (!t.enabled) return;
				const {
					rtlTranslate: i
				} = t;
				let n = e;
				n.originalEvent && (n = n.originalEvent);
				const r = n.keyCode || n.charCode,
					o = t.params.keyboard.pageUpDown,
					c = o && 33 === r,
					h = o && 34 === r,
					u = 37 === r,
					d = 39 === r,
					p = 38 === r,
					f = 40 === r;
				if (!t.allowSlideNext && (t.isHorizontal() && d || t.isVertical() && f || h)) return !1;
				if (!t.allowSlidePrev && (t.isHorizontal() && u || t.isVertical() && p || c)) return !1;
				if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || a.activeElement && a.activeElement.nodeName && ("input" === a.activeElement.nodeName.toLowerCase() || "textarea" === a.activeElement.nodeName.toLowerCase()))) {
					if (t.params.keyboard.onlyInViewport && (c || h || u || d || p || f)) {
						let e = !1;
						if (x(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === x(t.el, "." + t.params.slideActiveClass).length) return;
						const n = t.el,
							r = n.clientWidth,
							o = n.clientHeight,
							s = l.innerWidth,
							a = l.innerHeight,
							c = y(n);
						i && (c.left -= n.scrollLeft);
						const h = [
							[c.left, c.top],
							[c.left + r, c.top],
							[c.left, c.top + o],
							[c.left + r, c.top + o]
						];
						for (let t = 0; t < h.length; t += 1) {
							const i = h[t];
							if (i[0] >= 0 && i[0] <= s && i[1] >= 0 && i[1] <= a) {
								if (0 === i[0] && 0 === i[1]) continue;
								e = !0
							}
						}
						if (!e) return
					}
					t.isHorizontal() ? ((c || h || u || d) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((h || d) && !i || (c || u) && i) && t.slideNext(), ((c || u) && !i || (h || d) && i) && t.slidePrev()) : ((c || h || p || f) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (h || f) && t.slideNext(), (c || p) && t.slidePrev()), s("keyPress", r)
				}
			}

			function h() {
				t.keyboard.enabled || (a.addEventListener("keydown", c), t.keyboard.enabled = !0)
			}

			function u() {
				t.keyboard.enabled && (a.removeEventListener("keydown", c), t.keyboard.enabled = !1)
			}
			t.keyboard = {
				enabled: !1
			}, i({
				keyboard: {
					enabled: !1,
					onlyInViewport: !0,
					pageUpDown: !0
				}
			}), r("init", () => {
				t.params.keyboard.enabled && h()
			}), r("destroy", () => {
				t.keyboard.enabled && u()
			}), Object.assign(t.keyboard, {
				enable: h,
				disable: u
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n,
				emit: r
			} = e;
			const s = o();
			let c;
			i({
				mousewheel: {
					enabled: !1,
					releaseOnEdges: !1,
					invert: !1,
					forceToAxis: !1,
					sensitivity: 1,
					eventsTarget: "container",
					thresholdDelta: null,
					thresholdTime: null,
					noMousewheelClass: "swiper-no-mousewheel"
				}
			}), t.mousewheel = {
				enabled: !1
			};
			let h, u = l();
			const d = [];

			function p() {
				t.enabled && (t.mouseEntered = !0)
			}

			function f() {
				t.enabled && (t.mouseEntered = !1)
			}

			function m(e) {
				return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta || t.params.mousewheel.thresholdTime && l() - u < t.params.mousewheel.thresholdTime || !(e.delta >= 6 && l() - u < 60) && (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), r("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), r("scroll", e.raw)), u = (new s.Date).getTime(), 1))
			}

			function g(e) {
				let i = e,
					n = !0;
				if (!t.enabled) return;
				if (e.target.closest("." + t.params.mousewheel.noMousewheelClass)) return;
				const o = t.params.mousewheel;
				t.params.cssMode && i.preventDefault();
				let s = t.el;
				"container" !== t.params.mousewheel.eventsTarget && (s = document.querySelector(t.params.mousewheel.eventsTarget));
				const u = s && s.contains(i.target);
				if (!t.mouseEntered && !u && !o.releaseOnEdges) return !0;
				i.originalEvent && (i = i.originalEvent);
				let p = 0;
				const f = t.rtlTranslate ? -1 : 1,
					g = function(e) {
						let t = 0,
							i = 0,
							n = 0,
							r = 0;
						return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, r = 10 * i, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = r, r = 0), (n || r) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, r *= 40) : (n *= 800, r *= 800)), n && !t && (t = n < 1 ? -1 : 1), r && !i && (i = r < 1 ? -1 : 1), {
							spinX: t,
							spinY: i,
							pixelX: n,
							pixelY: r
						}
					}(i);
				if (o.forceToAxis)
					if (t.isHorizontal()) {
						if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
						p = -g.pixelX * f
					} else {
						if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
						p = -g.pixelY
					}
				else p = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * f : -g.pixelY;
				if (0 === p) return !0;
				o.invert && (p = -p);
				let v = t.getTranslate() + p * o.sensitivity;
				if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), n = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), n && t.params.nested && i.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
					const e = {
							time: l(),
							delta: Math.abs(p),
							direction: Math.sign(p)
						},
						n = h && e.time < h.time + 500 && e.delta <= h.delta && e.direction === h.direction;
					if (!n) {
						h = void 0;
						let s = t.getTranslate() + p * o.sensitivity;
						const l = t.isBeginning,
							u = t.isEnd;
						if (s >= t.minTranslate() && (s = t.minTranslate()), s <= t.maxTranslate() && (s = t.maxTranslate()), t.setTransition(0), t.setTranslate(s), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!l && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({
								direction: e.direction < 0 ? "next" : "prev",
								byMousewheel: !0
							}), t.params.freeMode.sticky) {
							clearTimeout(c), c = void 0, d.length >= 15 && d.shift();
							const i = d.length ? d[d.length - 1] : void 0,
								n = d[0];
							if (d.push(e), i && (e.delta > i.delta || e.direction !== i.direction)) d.splice(0);
							else if (d.length >= 15 && e.time - n.time < 500 && n.delta - e.delta >= 1 && e.delta <= 6) {
								const i = p > 0 ? .8 : .2;
								h = e, d.splice(0), c = a(() => {
									!t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, i)
								}, 0)
							}
							c || (c = a(() => {
								!t.destroyed && t.params && (h = e, d.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5))
							}, 500))
						}
						if (n || r("scroll", i), t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(), o.releaseOnEdges && (s === t.minTranslate() || s === t.maxTranslate())) return !0
					}
				} else {
					const i = {
						time: l(),
						delta: Math.abs(p),
						direction: Math.sign(p),
						raw: e
					};
					d.length >= 2 && d.shift();
					const n = d.length ? d[d.length - 1] : void 0;
					if (d.push(i), n ? (i.direction !== n.direction || i.delta > n.delta || i.time > n.time + 150) && m(i) : m(i), function(e) {
							const i = t.params.mousewheel;
							if (e.direction < 0) {
								if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0
							} else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0;
							return !1
						}(i)) return !0
				}
				return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1
			}

			function v(e) {
				let i = t.el;
				"container" !== t.params.mousewheel.eventsTarget && (i = document.querySelector(t.params.mousewheel.eventsTarget)), i[e]("mouseenter", p), i[e]("mouseleave", f), i[e]("wheel", g)
			}

			function y() {
				return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0)
			}

			function b() {
				return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0)
			}
			n("init", () => {
				!t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && y()
			}), n("destroy", () => {
				t.params.cssMode && y(), t.mousewheel.enabled && b()
			}), Object.assign(t.mousewheel, {
				enable: y,
				disable: b
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n,
				emit: r
			} = e;

			function o(e) {
				let i;
				return e && "string" == typeof e && t.isElement && (i = t.el.querySelector(e) || t.hostEl.querySelector(e), i) ? i : (e && ("string" == typeof e && (i = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && i && i.length > 1 && 1 === t.el.querySelectorAll(e).length ? i = t.el.querySelector(e) : i && 1 === i.length && (i = i[0])), e && !i ? e : i)
			}

			function s(e, i) {
				const n = t.params.navigation;
				(e = M(e)).forEach(e => {
					e && (e.classList[i ? "add" : "remove"](...n.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = i), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](n.lockClass))
				})
			}

			function a() {
				const {
					nextEl: e,
					prevEl: i
				} = t.navigation;
				if (t.params.loop) return s(i, !1), void s(e, !1);
				s(i, t.isBeginning && !t.params.rewind), s(e, t.isEnd && !t.params.rewind)
			}

			function l(e) {
				e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), r("navigationPrev"))
			}

			function c(e) {
				e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), r("navigationNext"))
			}

			function h() {
				const e = t.params.navigation;
				if (t.params.navigation = ee(t, t.originalParams.navigation, t.params.navigation, {
						nextEl: "swiper-button-next",
						prevEl: "swiper-button-prev"
					}), !e.nextEl && !e.prevEl) return;
				let i = o(e.nextEl),
					n = o(e.prevEl);
				Object.assign(t.navigation, {
					nextEl: i,
					prevEl: n
				}), i = M(i), n = M(n);
				const r = (i, n) => {
					i && i.addEventListener("click", "next" === n ? c : l), !t.enabled && i && i.classList.add(...e.lockClass.split(" "))
				};
				i.forEach(e => r(e, "next")), n.forEach(e => r(e, "prev"))
			}

			function u() {
				let {
					nextEl: e,
					prevEl: i
				} = t.navigation;
				e = M(e), i = M(i);
				const n = (e, i) => {
					e.removeEventListener("click", "next" === i ? c : l), e.classList.remove(...t.params.navigation.disabledClass.split(" "))
				};
				e.forEach(e => n(e, "next")), i.forEach(e => n(e, "prev"))
			}
			i({
				navigation: {
					nextEl: null,
					prevEl: null,
					hideOnClick: !1,
					disabledClass: "swiper-button-disabled",
					hiddenClass: "swiper-button-hidden",
					lockClass: "swiper-button-lock",
					navigationDisabledClass: "swiper-navigation-disabled"
				}
			}), t.navigation = {
				nextEl: null,
				prevEl: null
			}, n("init", () => {
				!1 === t.params.navigation.enabled ? d() : (h(), a())
			}), n("toEdge fromEdge lock unlock", () => {
				a()
			}), n("destroy", () => {
				u()
			}), n("enable disable", () => {
				let {
					nextEl: e,
					prevEl: i
				} = t.navigation;
				e = M(e), i = M(i), t.enabled ? a() : [...e, ...i].filter(e => !!e).forEach(e => e.classList.add(t.params.navigation.lockClass))
			}), n("click", (e, i) => {
				let {
					nextEl: n,
					prevEl: o
				} = t.navigation;
				n = M(n), o = M(o);
				const s = i.target;
				let a = o.includes(s) || n.includes(s);
				if (t.isElement && !a) {
					const e = i.path || i.composedPath && i.composedPath();
					e && (a = e.find(e => n.includes(e) || o.includes(e)))
				}
				if (t.params.navigation.hideOnClick && !a) {
					if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === s || t.pagination.el.contains(s))) return;
					let e;
					n.length ? e = n[0].classList.contains(t.params.navigation.hiddenClass) : o.length && (e = o[0].classList.contains(t.params.navigation.hiddenClass)), r(!0 === e ? "navigationShow" : "navigationHide"), [...n, ...o].filter(e => !!e).forEach(e => e.classList.toggle(t.params.navigation.hiddenClass))
				}
			});
			const d = () => {
				t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), u()
			};
			Object.assign(t.navigation, {
				enable: () => {
					t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), h(), a()
				},
				disable: d,
				update: a,
				init: h,
				destroy: u
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n,
				emit: r
			} = e;
			const o = "swiper-pagination";
			let s;
			i({
				pagination: {
					el: null,
					bulletElement: "span",
					clickable: !1,
					hideOnClick: !1,
					renderBullet: null,
					renderProgressbar: null,
					renderFraction: null,
					renderCustom: null,
					progressbarOpposite: !1,
					type: "bullets",
					dynamicBullets: !1,
					dynamicMainBullets: 1,
					formatFractionCurrent: e => e,
					formatFractionTotal: e => e,
					bulletClass: o + "-bullet",
					bulletActiveClass: o + "-bullet-active",
					modifierClass: o + "-",
					currentClass: o + "-current",
					totalClass: o + "-total",
					hiddenClass: o + "-hidden",
					progressbarFillClass: o + "-progressbar-fill",
					progressbarOppositeClass: o + "-progressbar-opposite",
					clickableClass: o + "-clickable",
					lockClass: o + "-lock",
					horizontalClass: o + "-horizontal",
					verticalClass: o + "-vertical",
					paginationDisabledClass: o + "-disabled"
				}
			}), t.pagination = {
				el: null,
				bullets: []
			};
			let a = 0;

			function l() {
				return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
			}

			function c(e, i) {
				const {
					bulletActiveClass: n
				} = t.params.pagination;
				e && (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${n}-${i}`), (e = e[("prev" === i ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${n}-${i}-${i}`))
			}

			function h(e) {
				const i = e.target.closest(te(t.params.pagination.bulletClass));
				if (!i) return;
				e.preventDefault();
				const n = w(i) * t.params.slidesPerGroup;
				if (t.params.loop) {
					if (t.realIndex === n) return;
					const e = (r = t.realIndex, o = n, (o %= s = t.slides.length) == 1 + (r %= s) ? "next" : o === r - 1 ? "previous" : void 0);
					"next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(n)
				} else t.slideTo(n);
				var r, o, s
			}

			function u() {
				const e = t.rtl,
					i = t.params.pagination;
				if (l()) return;
				let n, o, h = t.pagination.el;
				h = M(h);
				const u = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
					d = t.params.loop ? Math.ceil(u / t.params.slidesPerGroup) : t.snapGrid.length;
				if (t.params.loop ? (o = t.previousRealIndex || 0, n = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (n = t.snapIndex, o = t.previousSnapIndex) : (o = t.previousIndex || 0, n = t.activeIndex || 0), "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
					const r = t.pagination.bullets;
					let l, u, d;
					if (i.dynamicBullets && (s = E(r[0], t.isHorizontal() ? "width" : "height", !0), h.forEach(e => {
							e.style[t.isHorizontal() ? "width" : "height"] = s * (i.dynamicMainBullets + 4) + "px"
						}), i.dynamicMainBullets > 1 && void 0 !== o && (a += n - (o || 0), a > i.dynamicMainBullets - 1 ? a = i.dynamicMainBullets - 1 : a < 0 && (a = 0)), l = Math.max(n - a, 0), u = l + (Math.min(r.length, i.dynamicMainBullets) - 1), d = (u + l) / 2), r.forEach(e => {
							const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${i.bulletActiveClass}${e}`)].map(e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e).flat();
							e.classList.remove(...t)
						}), h.length > 1) r.forEach(e => {
						const r = w(e);
						r === n ? e.classList.add(...i.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), i.dynamicBullets && (r >= l && r <= u && e.classList.add(...(i.bulletActiveClass + "-main").split(" ")), r === l && c(e, "prev"), r === u && c(e, "next"))
					});
					else {
						const e = r[n];
						if (e && e.classList.add(...i.bulletActiveClass.split(" ")), t.isElement && r.forEach((e, t) => {
								e.setAttribute("part", t === n ? "bullet-active" : "bullet")
							}), i.dynamicBullets) {
							const e = r[l],
								t = r[u];
							for (let e = l; e <= u; e += 1) r[e] && r[e].classList.add(...(i.bulletActiveClass + "-main").split(" "));
							c(e, "prev"), c(t, "next")
						}
					}
					if (i.dynamicBullets) {
						const n = Math.min(r.length, i.dynamicMainBullets + 4),
							o = (s * n - s) / 2 - d * s,
							a = e ? "right" : "left";
						r.forEach(e => {
							e.style[t.isHorizontal() ? a : "top"] = o + "px"
						})
					}
				}
				h.forEach((e, o) => {
					if ("fraction" === i.type && (e.querySelectorAll(te(i.currentClass)).forEach(e => {
							e.textContent = i.formatFractionCurrent(n + 1)
						}), e.querySelectorAll(te(i.totalClass)).forEach(e => {
							e.textContent = i.formatFractionTotal(d)
						})), "progressbar" === i.type) {
						let r;
						r = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
						const o = (n + 1) / d;
						let s = 1,
							a = 1;
						"horizontal" === r ? s = o : a = o, e.querySelectorAll(te(i.progressbarFillClass)).forEach(e => {
							e.style.transform = `translate3d(0,0,0) scaleX(${s}) scaleY(${a})`, e.style.transitionDuration = t.params.speed + "ms"
						})
					}
					"custom" === i.type && i.renderCustom ? (e.innerHTML = i.renderCustom(t, n + 1, d), 0 === o && r("paginationRender", e)) : (0 === o && r("paginationRender", e), r("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](i.lockClass)
				})
			}

			function d() {
				const e = t.params.pagination;
				if (l()) return;
				const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length;
				let n = t.pagination.el;
				n = M(n);
				let o = "";
				if ("bullets" === e.type) {
					let n = t.params.loop ? Math.ceil(i / t.params.slidesPerGroup) : t.snapGrid.length;
					t.params.freeMode && t.params.freeMode.enabled && n > i && (n = i);
					for (let i = 0; i < n; i += 1) e.renderBullet ? o += e.renderBullet.call(t, i, e.bulletClass) : o += `<${e.bulletElement} ${t.isElement?'part="bullet"':""} class="${e.bulletClass}"></${e.bulletElement}>`
				}
				"fraction" === e.type && (o = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (o = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], n.forEach(i => {
					"custom" !== e.type && (i.innerHTML = o || ""), "bullets" === e.type && t.pagination.bullets.push(...i.querySelectorAll(te(e.bulletClass)))
				}), "custom" !== e.type && r("paginationRender", n[0])
			}

			function p() {
				t.params.pagination = ee(t, t.originalParams.pagination, t.params.pagination, {
					el: "swiper-pagination"
				});
				const e = t.params.pagination;
				if (!e.el) return;
				let i;
				"string" == typeof e.el && t.isElement && (i = t.el.querySelector(e.el)), i || "string" != typeof e.el || (i = [...document.querySelectorAll(e.el)]), i || (i = e.el), i && 0 !== i.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(i) && i.length > 1 && (i = [...t.el.querySelectorAll(e.el)], i.length > 1 && (i = i.find(e => x(e, ".swiper")[0] === t.el))), Array.isArray(i) && 1 === i.length && (i = i[0]), Object.assign(t.pagination, {
					el: i
				}), i = M(i), i.forEach(i => {
					"bullets" === e.type && e.clickable && i.classList.add(...(e.clickableClass || "").split(" ")), i.classList.add(e.modifierClass + e.type), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (i.classList.add(`${e.modifierClass}${e.type}-dynamic`), a = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && i.classList.add(e.progressbarOppositeClass), e.clickable && i.addEventListener("click", h), t.enabled || i.classList.add(e.lockClass)
				}))
			}

			function f() {
				const e = t.params.pagination;
				if (l()) return;
				let i = t.pagination.el;
				i && (i = M(i), i.forEach(i => {
					i.classList.remove(e.hiddenClass), i.classList.remove(e.modifierClass + e.type), i.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (i.classList.remove(...(e.clickableClass || "").split(" ")), i.removeEventListener("click", h))
				})), t.pagination.bullets && t.pagination.bullets.forEach(t => t.classList.remove(...e.bulletActiveClass.split(" ")))
			}
			n("changeDirection", () => {
				if (!t.pagination || !t.pagination.el) return;
				const e = t.params.pagination;
				let {
					el: i
				} = t.pagination;
				i = M(i), i.forEach(i => {
					i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
				})
			}), n("init", () => {
				!1 === t.params.pagination.enabled ? m() : (p(), d(), u())
			}), n("activeIndexChange", () => {
				void 0 === t.snapIndex && u()
			}), n("snapIndexChange", () => {
				u()
			}), n("snapGridLengthChange", () => {
				d(), u()
			}), n("destroy", () => {
				f()
			}), n("enable disable", () => {
				let {
					el: e
				} = t.pagination;
				e && (e = M(e), e.forEach(e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)))
			}), n("lock unlock", () => {
				u()
			}), n("click", (e, i) => {
				const n = i.target,
					o = M(t.pagination.el);
				if (t.params.pagination.el && t.params.pagination.hideOnClick && o && o.length > 0 && !n.classList.contains(t.params.pagination.bulletClass)) {
					if (t.navigation && (t.navigation.nextEl && n === t.navigation.nextEl || t.navigation.prevEl && n === t.navigation.prevEl)) return;
					const e = o[0].classList.contains(t.params.pagination.hiddenClass);
					r(!0 === e ? "paginationShow" : "paginationHide"), o.forEach(e => e.classList.toggle(t.params.pagination.hiddenClass))
				}
			});
			const m = () => {
				t.el.classList.add(t.params.pagination.paginationDisabledClass);
				let {
					el: e
				} = t.pagination;
				e && (e = M(e), e.forEach(e => e.classList.add(t.params.pagination.paginationDisabledClass))), f()
			};
			Object.assign(t.pagination, {
				enable: () => {
					t.el.classList.remove(t.params.pagination.paginationDisabledClass);
					let {
						el: e
					} = t.pagination;
					e && (e = M(e), e.forEach(e => e.classList.remove(t.params.pagination.paginationDisabledClass))), p(), d(), u()
				},
				disable: m,
				render: d,
				update: u,
				init: p,
				destroy: f
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: r,
				emit: o
			} = e;
			const l = n();
			let c, h, u, d, p = !1,
				f = null,
				m = null;

			function g() {
				if (!t.params.scrollbar.el || !t.scrollbar.el) return;
				const {
					scrollbar: e,
					rtlTranslate: i
				} = t, {
					dragEl: n,
					el: r
				} = e, o = t.params.scrollbar, s = t.params.loop ? t.progressLoop : t.progress;
				let a = h,
					l = (u - h) * s;
				i ? (l = -l, l > 0 ? (a = h - l, l = 0) : -l + h > u && (a = u + l)) : l < 0 ? (a = h + l, l = 0) : l + h > u && (a = u - l), t.isHorizontal() ? (n.style.transform = `translate3d(${l}px, 0, 0)`, n.style.width = a + "px") : (n.style.transform = `translate3d(0px, ${l}px, 0)`, n.style.height = a + "px"), o.hide && (clearTimeout(f), r.style.opacity = 1, f = setTimeout(() => {
					r.style.opacity = 0, r.style.transitionDuration = "400ms"
				}, 1e3))
			}

			function b() {
				if (!t.params.scrollbar.el || !t.scrollbar.el) return;
				const {
					scrollbar: e
				} = t, {
					dragEl: i,
					el: n
				} = e;
				i.style.width = "", i.style.height = "", u = t.isHorizontal() ? n.offsetWidth : n.offsetHeight, d = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), h = "auto" === t.params.scrollbar.dragSize ? u * d : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? i.style.width = h + "px" : i.style.height = h + "px", n.style.display = d >= 1 ? "none" : "", t.params.scrollbar.hide && (n.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
			}

			function w(e) {
				return t.isHorizontal() ? e.clientX : e.clientY
			}

			function x(e) {
				const {
					scrollbar: i,
					rtlTranslate: n
				} = t, {
					el: r
				} = i;
				let o;
				o = (w(e) - y(r)[t.isHorizontal() ? "left" : "top"] - (null !== c ? c : h / 2)) / (u - h), o = Math.max(Math.min(o, 1), 0), n && (o = 1 - o);
				const s = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * o;
				t.updateProgress(s), t.setTranslate(s), t.updateActiveIndex(), t.updateSlidesClasses()
			}

			function _(e) {
				const i = t.params.scrollbar,
					{
						scrollbar: n,
						wrapperEl: r
					} = t,
					{
						el: s,
						dragEl: a
					} = n;
				p = !0, c = e.target === a ? w(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), r.style.transitionDuration = "100ms", a.style.transitionDuration = "100ms", x(e), clearTimeout(m), s.style.transitionDuration = "0ms", i.hide && (s.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), o("scrollbarDragStart", e)
			}

			function E(e) {
				const {
					scrollbar: i,
					wrapperEl: n
				} = t, {
					el: r,
					dragEl: s
				} = i;
				p && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, x(e), n.style.transitionDuration = "0ms", r.style.transitionDuration = "0ms", s.style.transitionDuration = "0ms", o("scrollbarDragMove", e))
			}

			function S(e) {
				const i = t.params.scrollbar,
					{
						scrollbar: n,
						wrapperEl: r
					} = t,
					{
						el: s
					} = n;
				p && (p = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", r.style.transitionDuration = ""), i.hide && (clearTimeout(m), m = a(() => {
					s.style.opacity = 0, s.style.transitionDuration = "400ms"
				}, 1e3)), o("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest())
			}

			function T(e) {
				const {
					scrollbar: i,
					params: n
				} = t, r = i.el;
				if (!r) return;
				const o = r,
					s = !!n.passiveListeners && {
						passive: !1,
						capture: !1
					},
					a = !!n.passiveListeners && {
						passive: !0,
						capture: !1
					};
				if (!o) return;
				const c = "on" === e ? "addEventListener" : "removeEventListener";
				o[c]("pointerdown", _, s), l[c]("pointermove", E, s), l[c]("pointerup", S, a)
			}

			function A() {
				const {
					scrollbar: e,
					el: i
				} = t;
				t.params.scrollbar = ee(t, t.originalParams.scrollbar, t.params.scrollbar, {
					el: "swiper-scrollbar"
				});
				const n = t.params.scrollbar;
				if (!n.el) return;
				let r, o;
				if ("string" == typeof n.el && t.isElement && (r = t.el.querySelector(n.el)), r || "string" != typeof n.el) r || (r = n.el);
				else if (r = l.querySelectorAll(n.el), !r.length) return;
				t.params.uniqueNavElements && "string" == typeof n.el && r.length > 1 && 1 === i.querySelectorAll(n.el).length && (r = i.querySelector(n.el)), r.length > 0 && (r = r[0]), r.classList.add(t.isHorizontal() ? n.horizontalClass : n.verticalClass), r && (o = r.querySelector(te(t.params.scrollbar.dragClass)), o || (o = v("div", t.params.scrollbar.dragClass), r.append(o))), Object.assign(e, {
					el: r,
					dragEl: o
				}), n.draggable && t.params.scrollbar.el && t.scrollbar.el && T("on"), r && r.classList[t.enabled ? "remove" : "add"](...s(t.params.scrollbar.lockClass))
			}

			function L() {
				const e = t.params.scrollbar,
					i = t.scrollbar.el;
				i && i.classList.remove(...s(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && T("off")
			}
			i({
				scrollbar: {
					el: null,
					dragSize: "auto",
					hide: !1,
					draggable: !1,
					snapOnRelease: !0,
					lockClass: "swiper-scrollbar-lock",
					dragClass: "swiper-scrollbar-drag",
					scrollbarDisabledClass: "swiper-scrollbar-disabled",
					horizontalClass: "swiper-scrollbar-horizontal",
					verticalClass: "swiper-scrollbar-vertical"
				}
			}), t.scrollbar = {
				el: null,
				dragEl: null
			}, r("changeDirection", () => {
				if (!t.scrollbar || !t.scrollbar.el) return;
				const e = t.params.scrollbar;
				let {
					el: i
				} = t.scrollbar;
				i = M(i), i.forEach(i => {
					i.classList.remove(e.horizontalClass, e.verticalClass), i.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
				})
			}), r("init", () => {
				!1 === t.params.scrollbar.enabled ? C() : (A(), b(), g())
			}), r("update resize observerUpdate lock unlock changeDirection", () => {
				b()
			}), r("setTranslate", () => {
				g()
			}), r("setTransition", (e, i) => {
				! function(e) {
					t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = e + "ms")
				}(i)
			}), r("enable disable", () => {
				const {
					el: e
				} = t.scrollbar;
				e && e.classList[t.enabled ? "remove" : "add"](...s(t.params.scrollbar.lockClass))
			}), r("destroy", () => {
				L()
			});
			const C = () => {
				t.el.classList.add(...s(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...s(t.params.scrollbar.scrollbarDisabledClass)), L()
			};
			Object.assign(t.scrollbar, {
				enable: () => {
					t.el.classList.remove(...s(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...s(t.params.scrollbar.scrollbarDisabledClass)), A(), b(), g()
				},
				disable: C,
				updateSize: b,
				setTranslate: g,
				init: A,
				destroy: L
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				parallax: {
					enabled: !1
				}
			});
			const r = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]",
				o = (e, i) => {
					const {
						rtl: n
					} = t, r = n ? -1 : 1, o = e.getAttribute("data-swiper-parallax") || "0";
					let s = e.getAttribute("data-swiper-parallax-x"),
						a = e.getAttribute("data-swiper-parallax-y");
					const l = e.getAttribute("data-swiper-parallax-scale"),
						c = e.getAttribute("data-swiper-parallax-opacity"),
						h = e.getAttribute("data-swiper-parallax-rotate");
					if (s || a ? (s = s || "0", a = a || "0") : t.isHorizontal() ? (s = o, a = "0") : (a = o, s = "0"), s = s.indexOf("%") >= 0 ? parseInt(s, 10) * i * r + "%" : s * i * r + "px", a = a.indexOf("%") >= 0 ? parseInt(a, 10) * i + "%" : a * i + "px", null != c) {
						const t = c - (c - 1) * (1 - Math.abs(i));
						e.style.opacity = t
					}
					let u = `translate3d(${s}, ${a}, 0px)`;
					null != l && (u += ` scale(${l-(l-1)*(1-Math.abs(i))})`), h && null != h && (u += ` rotate(${h*i*-1}deg)`), e.style.transform = u
				},
				s = () => {
					const {
						el: e,
						slides: i,
						progress: n,
						snapGrid: s,
						isElement: a
					} = t, l = m(e, r);
					t.isElement && l.push(...m(t.hostEl, r)), l.forEach(e => {
						o(e, n)
					}), i.forEach((e, i) => {
						let a = e.progress;
						t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (a += Math.ceil(i / 2) - n * (s.length - 1)), a = Math.min(Math.max(a, -1), 1), e.querySelectorAll(r + ", [data-swiper-parallax-rotate]").forEach(e => {
							o(e, a)
						})
					})
				};
			n("beforeInit", () => {
				t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
			}), n("init", () => {
				t.params.parallax.enabled && s()
			}), n("setTranslate", () => {
				t.params.parallax.enabled && s()
			}), n("setTransition", (e, i) => {
				t.params.parallax.enabled && function(e) {
					void 0 === e && (e = t.params.speed);
					const {
						el: i,
						hostEl: n
					} = t, o = [...i.querySelectorAll(r)];
					t.isElement && o.push(...n.querySelectorAll(r)), o.forEach(t => {
						let i = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
						0 === e && (i = 0), t.style.transitionDuration = i + "ms"
					})
				}(i)
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n,
				emit: r
			} = e;
			const s = o();
			i({
				zoom: {
					enabled: !1,
					limitToOriginalSize: !1,
					maxRatio: 3,
					minRatio: 1,
					panOnMouseMove: !1,
					toggle: !0,
					containerClass: "swiper-zoom-container",
					zoomedSlideClass: "swiper-slide-zoomed"
				}
			}), t.zoom = {
				enabled: !1
			};
			let a = 1,
				l = !1,
				h = !1,
				u = {
					x: 0,
					y: 0
				};
			let d, p;
			const f = [],
				g = {
					originX: 0,
					originY: 0,
					slideEl: void 0,
					slideWidth: void 0,
					slideHeight: void 0,
					imageEl: void 0,
					imageWrapEl: void 0,
					maxRatio: 3
				},
				v = {
					isTouched: void 0,
					isMoved: void 0,
					currentX: void 0,
					currentY: void 0,
					minX: void 0,
					minY: void 0,
					maxX: void 0,
					maxY: void 0,
					width: void 0,
					height: void 0,
					startX: void 0,
					startY: void 0,
					touchesStart: {},
					touchesCurrent: {}
				},
				b = {
					x: void 0,
					y: void 0,
					prevPositionX: void 0,
					prevPositionY: void 0,
					prevTime: void 0
				};
			let w, _ = 1;

			function E() {
				if (f.length < 2) return 1;
				const e = f[0].pageX,
					t = f[0].pageY,
					i = f[1].pageX,
					n = f[1].pageY;
				return Math.sqrt((i - e) ** 2 + (n - t) ** 2)
			}

			function M() {
				const e = t.params.zoom,
					i = g.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio;
				if (e.limitToOriginalSize && g.imageEl && g.imageEl.naturalWidth) {
					const e = g.imageEl.naturalWidth / g.imageEl.offsetWidth;
					return Math.min(e, i)
				}
				return i
			}

			function S(e) {
				const i = t.isElement ? "swiper-slide" : "." + t.params.slideClass;
				return !!e.target.matches(i) || t.slides.filter(t => t.contains(e.target)).length > 0
			}

			function T(e) {
				const i = "." + t.params.zoom.containerClass;
				return !!e.target.matches(i) || [...t.hostEl.querySelectorAll(i)].filter(t => t.contains(e.target)).length > 0
			}

			function A(e) {
				if ("mouse" === e.pointerType && f.splice(0, f.length), !S(e)) return;
				const i = t.params.zoom;
				if (d = !1, p = !1, f.push(e), !(f.length < 2)) {
					if (d = !0, g.scaleStart = E(), !g.slideEl) {
						g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), g.slideEl || (g.slideEl = t.slides[t.activeIndex]);
						let n = g.slideEl.querySelector("." + i.containerClass);
						if (n && (n = n.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = n, g.imageWrapEl = n ? x(g.imageEl, "." + i.containerClass)[0] : void 0, !g.imageWrapEl) return void(g.imageEl = void 0);
						g.maxRatio = M()
					}
					if (g.imageEl) {
						const [e, t] = function() {
							if (f.length < 2) return {
								x: null,
								y: null
							};
							const e = g.imageEl.getBoundingClientRect();
							return [(f[0].pageX + (f[1].pageX - f[0].pageX) / 2 - e.x - s.scrollX) / a, (f[0].pageY + (f[1].pageY - f[0].pageY) / 2 - e.y - s.scrollY) / a]
						}();
						g.originX = e, g.originY = t, g.imageEl.style.transitionDuration = "0ms"
					}
					l = !0
				}
			}

			function L(e) {
				if (!S(e)) return;
				const i = t.params.zoom,
					n = t.zoom,
					r = f.findIndex(t => t.pointerId === e.pointerId);
				r >= 0 && (f[r] = e), f.length < 2 || (p = !0, g.scaleMove = E(), g.imageEl && (n.scale = g.scaleMove / g.scaleStart * a, n.scale > g.maxRatio && (n.scale = g.maxRatio - 1 + (n.scale - g.maxRatio + 1) ** .5), n.scale < i.minRatio && (n.scale = i.minRatio + 1 - (i.minRatio - n.scale + 1) ** .5), g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`))
			}

			function C(e) {
				if (!S(e)) return;
				if ("mouse" === e.pointerType && "pointerout" === e.type) return;
				const i = t.params.zoom,
					n = t.zoom,
					r = f.findIndex(t => t.pointerId === e.pointerId);
				r >= 0 && f.splice(r, 1), d && p && (d = !1, p = !1, g.imageEl && (n.scale = Math.max(Math.min(n.scale, g.maxRatio), i.minRatio), g.imageEl.style.transitionDuration = t.params.speed + "ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${n.scale})`, a = n.scale, l = !1, n.scale > 1 && g.slideEl ? g.slideEl.classList.add("" + i.zoomedSlideClass) : n.scale <= 1 && g.slideEl && g.slideEl.classList.remove("" + i.zoomedSlideClass), 1 === n.scale && (g.originX = 0, g.originY = 0, g.slideEl = void 0)))
			}

			function P() {
				t.touchEventsData.preventTouchMoveFromPointerMove = !1
			}

			function I(e) {
				const i = "mouse" === e.pointerType && t.params.zoom.panOnMouseMove;
				if (!S(e) || !T(e)) return;
				const n = t.zoom;
				if (!g.imageEl) return;
				if (!v.isTouched || !g.slideEl) return void(i && O(e));
				if (i) return void O(e);
				v.isMoved || (v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, v.startX = c(g.imageWrapEl, "x") || 0, v.startY = c(g.imageWrapEl, "y") || 0, g.slideWidth = g.slideEl.offsetWidth, g.slideHeight = g.slideEl.offsetHeight, g.imageWrapEl.style.transitionDuration = "0ms");
				const r = v.width * n.scale,
					o = v.height * n.scale;
				if (v.minX = Math.min(g.slideWidth / 2 - r / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - o / 2, 0), v.maxY = -v.minY, v.touchesCurrent.x = f.length > 0 ? f[0].pageX : e.pageX, v.touchesCurrent.y = f.length > 0 ? f[0].pageY : e.pageY, Math.max(Math.abs(v.touchesCurrent.x - v.touchesStart.x), Math.abs(v.touchesCurrent.y - v.touchesStart.y)) > 5 && (t.allowClick = !1), !v.isMoved && !l) {
					if (t.isHorizontal() && (Math.floor(v.minX) === Math.floor(v.startX) && v.touchesCurrent.x < v.touchesStart.x || Math.floor(v.maxX) === Math.floor(v.startX) && v.touchesCurrent.x > v.touchesStart.x)) return v.isTouched = !1, void P();
					if (!t.isHorizontal() && (Math.floor(v.minY) === Math.floor(v.startY) && v.touchesCurrent.y < v.touchesStart.y || Math.floor(v.maxY) === Math.floor(v.startY) && v.touchesCurrent.y > v.touchesStart.y)) return v.isTouched = !1, void P()
				}
				e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(w), t.touchEventsData.preventTouchMoveFromPointerMove = !0, w = setTimeout(() => {
					t.destroyed || P()
				}), v.isMoved = !0;
				const s = (n.scale - a) / (g.maxRatio - t.params.zoom.minRatio),
					{
						originX: h,
						originY: u
					} = g;
				v.currentX = v.touchesCurrent.x - v.touchesStart.x + v.startX + s * (v.width - 2 * h), v.currentY = v.touchesCurrent.y - v.touchesStart.y + v.startY + s * (v.height - 2 * u), v.currentX < v.minX && (v.currentX = v.minX + 1 - (v.minX - v.currentX + 1) ** .8), v.currentX > v.maxX && (v.currentX = v.maxX - 1 + (v.currentX - v.maxX + 1) ** .8), v.currentY < v.minY && (v.currentY = v.minY + 1 - (v.minY - v.currentY + 1) ** .8), v.currentY > v.maxY && (v.currentY = v.maxY - 1 + (v.currentY - v.maxY + 1) ** .8), b.prevPositionX || (b.prevPositionX = v.touchesCurrent.x), b.prevPositionY || (b.prevPositionY = v.touchesCurrent.y), b.prevTime || (b.prevTime = Date.now()), b.x = (v.touchesCurrent.x - b.prevPositionX) / (Date.now() - b.prevTime) / 2, b.y = (v.touchesCurrent.y - b.prevPositionY) / (Date.now() - b.prevTime) / 2, Math.abs(v.touchesCurrent.x - b.prevPositionX) < 2 && (b.x = 0), Math.abs(v.touchesCurrent.y - b.prevPositionY) < 2 && (b.y = 0), b.prevPositionX = v.touchesCurrent.x, b.prevPositionY = v.touchesCurrent.y, b.prevTime = Date.now(), g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)`
			}

			function R() {
				const e = t.zoom;
				g.slideEl && t.activeIndex !== t.slides.indexOf(g.slideEl) && (g.imageEl && (g.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), g.imageWrapEl && (g.imageWrapEl.style.transform = "translate3d(0,0,0)"), g.slideEl.classList.remove("" + t.params.zoom.zoomedSlideClass), e.scale = 1, a = 1, g.slideEl = void 0, g.imageEl = void 0, g.imageWrapEl = void 0, g.originX = 0, g.originY = 0)
			}

			function O(e) {
				if (a <= 1 || !g.imageWrapEl) return;
				if (!S(e) || !T(e)) return;
				const t = s.getComputedStyle(g.imageWrapEl).transform,
					i = new s.DOMMatrix(t);
				if (!h) return h = !0, u.x = e.clientX, u.y = e.clientY, v.startX = i.e, v.startY = i.f, v.width = g.imageEl.offsetWidth || g.imageEl.clientWidth, v.height = g.imageEl.offsetHeight || g.imageEl.clientHeight, g.slideWidth = g.slideEl.offsetWidth, void(g.slideHeight = g.slideEl.offsetHeight);
				const n = -3 * (e.clientX - u.x),
					r = -3 * (e.clientY - u.y),
					o = v.width * a,
					l = v.height * a,
					c = g.slideWidth,
					d = g.slideHeight,
					p = Math.min(c / 2 - o / 2, 0),
					f = -p,
					m = Math.min(d / 2 - l / 2, 0),
					y = -m,
					b = Math.max(Math.min(v.startX + n, f), p),
					w = Math.max(Math.min(v.startY + r, y), m);
				g.imageWrapEl.style.transitionDuration = "0ms", g.imageWrapEl.style.transform = `translate3d(${b}px, ${w}px, 0)`, u.x = e.clientX, u.y = e.clientY, v.startX = b, v.startY = w
			}

			function D(e) {
				const i = t.zoom,
					n = t.params.zoom;
				if (!g.slideEl) {
					e && e.target && (g.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), g.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, "." + t.params.slideActiveClass)[0] : g.slideEl = t.slides[t.activeIndex]);
					let i = g.slideEl.querySelector("." + n.containerClass);
					i && (i = i.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = i, g.imageWrapEl = i ? x(g.imageEl, "." + n.containerClass)[0] : void 0
				}
				if (!g.imageEl || !g.imageWrapEl) return;
				let r, o, l, c, h, u, d, p, f, b, w, _, E, S, T, A, L, C;
				t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), g.slideEl.classList.add("" + n.zoomedSlideClass), void 0 === v.touchesStart.x && e ? (r = e.pageX, o = e.pageY) : (r = v.touchesStart.x, o = v.touchesStart.y);
				const P = "number" == typeof e ? e : null;
				1 === a && P && (r = void 0, o = void 0, v.touchesStart.x = void 0, v.touchesStart.y = void 0);
				const I = M();
				i.scale = P || I, a = P || I, !e || 1 === a && P ? (d = 0, p = 0) : (L = g.slideEl.offsetWidth, C = g.slideEl.offsetHeight, l = y(g.slideEl).left + s.scrollX, c = y(g.slideEl).top + s.scrollY, h = l + L / 2 - r, u = c + C / 2 - o, f = g.imageEl.offsetWidth || g.imageEl.clientWidth, b = g.imageEl.offsetHeight || g.imageEl.clientHeight, w = f * i.scale, _ = b * i.scale, E = Math.min(L / 2 - w / 2, 0), S = Math.min(C / 2 - _ / 2, 0), T = -E, A = -S, d = h * i.scale, p = u * i.scale, d < E && (d = E), d > T && (d = T), p < S && (p = S), p > A && (p = A)), P && 1 === i.scale && (g.originX = 0, g.originY = 0), g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = `translate3d(${d}px, ${p}px,0)`, g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = `translate3d(0,0,0) scale(${i.scale})`
			}

			function z() {
				const e = t.zoom,
					i = t.params.zoom;
				if (!g.slideEl) {
					t.params.virtual && t.params.virtual.enabled && t.virtual ? g.slideEl = m(t.slidesEl, "." + t.params.slideActiveClass)[0] : g.slideEl = t.slides[t.activeIndex];
					let e = g.slideEl.querySelector("." + i.containerClass);
					e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), g.imageEl = e, g.imageWrapEl = e ? x(g.imageEl, "." + i.containerClass)[0] : void 0
				}
				g.imageEl && g.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, a = 1, v.touchesStart.x = void 0, v.touchesStart.y = void 0, g.imageWrapEl.style.transitionDuration = "300ms", g.imageWrapEl.style.transform = "translate3d(0,0,0)", g.imageEl.style.transitionDuration = "300ms", g.imageEl.style.transform = "translate3d(0,0,0) scale(1)", g.slideEl.classList.remove("" + i.zoomedSlideClass), g.slideEl = void 0, g.originX = 0, g.originY = 0, t.params.zoom.panOnMouseMove && (u = {
					x: 0,
					y: 0
				}, h && (h = !1, v.startX = 0, v.startY = 0)))
			}

			function k(e) {
				const i = t.zoom;
				i.scale && 1 !== i.scale ? z() : D(e)
			}

			function N() {
				return {
					passiveListener: !!t.params.passiveListeners && {
						passive: !0,
						capture: !1
					},
					activeListenerWithCapture: !t.params.passiveListeners || {
						passive: !1,
						capture: !0
					}
				}
			}

			function B() {
				const e = t.zoom;
				if (e.enabled) return;
				e.enabled = !0;
				const {
					passiveListener: i,
					activeListenerWithCapture: n
				} = N();
				t.wrapperEl.addEventListener("pointerdown", A, i), t.wrapperEl.addEventListener("pointermove", L, n), ["pointerup", "pointercancel", "pointerout"].forEach(e => {
					t.wrapperEl.addEventListener(e, C, i)
				}), t.wrapperEl.addEventListener("pointermove", I, n)
			}

			function H() {
				const e = t.zoom;
				if (!e.enabled) return;
				e.enabled = !1;
				const {
					passiveListener: i,
					activeListenerWithCapture: n
				} = N();
				t.wrapperEl.removeEventListener("pointerdown", A, i), t.wrapperEl.removeEventListener("pointermove", L, n), ["pointerup", "pointercancel", "pointerout"].forEach(e => {
					t.wrapperEl.removeEventListener(e, C, i)
				}), t.wrapperEl.removeEventListener("pointermove", I, n)
			}
			Object.defineProperty(t.zoom, "scale", {
				get: () => _,
				set(e) {
					if (_ !== e) {
						const t = g.imageEl,
							i = g.slideEl;
						r("zoomChange", e, t, i)
					}
					_ = e
				}
			}), n("init", () => {
				t.params.zoom.enabled && B()
			}), n("destroy", () => {
				H()
			}), n("touchStart", (e, i) => {
				t.zoom.enabled && function(e) {
					const i = t.device;
					if (!g.imageEl) return;
					if (v.isTouched) return;
					i.android && e.cancelable && e.preventDefault(), v.isTouched = !0;
					const n = f.length > 0 ? f[0] : e;
					v.touchesStart.x = n.pageX, v.touchesStart.y = n.pageY
				}(i)
			}), n("touchEnd", (e, i) => {
				t.zoom.enabled && function() {
					const e = t.zoom;
					if (f.length = 0, !g.imageEl) return;
					if (!v.isTouched || !v.isMoved) return v.isTouched = !1, void(v.isMoved = !1);
					v.isTouched = !1, v.isMoved = !1;
					let i = 300,
						n = 300;
					const r = b.x * i,
						o = v.currentX + r,
						s = b.y * n,
						a = v.currentY + s;
					0 !== b.x && (i = Math.abs((o - v.currentX) / b.x)), 0 !== b.y && (n = Math.abs((a - v.currentY) / b.y));
					const l = Math.max(i, n);
					v.currentX = o, v.currentY = a;
					const c = v.width * e.scale,
						h = v.height * e.scale;
					v.minX = Math.min(g.slideWidth / 2 - c / 2, 0), v.maxX = -v.minX, v.minY = Math.min(g.slideHeight / 2 - h / 2, 0), v.maxY = -v.minY, v.currentX = Math.max(Math.min(v.currentX, v.maxX), v.minX), v.currentY = Math.max(Math.min(v.currentY, v.maxY), v.minY), g.imageWrapEl.style.transitionDuration = l + "ms", g.imageWrapEl.style.transform = `translate3d(${v.currentX}px, ${v.currentY}px,0)`
				}()
			}), n("doubleTap", (e, i) => {
				!t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && k(i)
			}), n("transitionEnd", () => {
				t.zoom.enabled && t.params.zoom.enabled && R()
			}), n("slideChange", () => {
				t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && R()
			}), Object.assign(t.zoom, {
				enable: B,
				disable: H,
				in: D,
				out: z,
				toggle: k
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;

			function r(e, t) {
				const i = function() {
					let e, t, i;
					return (n, r) => {
						for (t = -1, e = n.length; e - t > 1;) i = e + t >> 1, n[i] <= r ? t = i : e = i;
						return e
					}
				}();
				let n, r;
				return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function(e) {
					return e ? (r = i(this.x, e), n = r - 1, (e - this.x[n]) * (this.y[r] - this.y[n]) / (this.x[r] - this.x[n]) + this.y[n]) : 0
				}, this
			}

			function o() {
				t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
			}
			i({
				controller: {
					control: void 0,
					inverse: !1,
					by: "slide"
				}
			}), t.controller = {
				control: void 0
			}, n("beforeInit", () => {
				"undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement) ? ("string" == typeof t.params.controller.control ? [...document.querySelectorAll(t.params.controller.control)] : [t.params.controller.control]).forEach(e => {
					if (t.controller.control || (t.controller.control = []), e && e.swiper) t.controller.control.push(e.swiper);
					else if (e) {
						const i = t.params.eventsPrefix + "init",
							n = r => {
								t.controller.control.push(r.detail[0]), t.update(), e.removeEventListener(i, n)
							};
						e.addEventListener(i, n)
					}
				}) : t.controller.control = t.params.controller.control
			}), n("update", () => {
				o()
			}), n("resize", () => {
				o()
			}), n("observerUpdate", () => {
				o()
			}), n("setTranslate", (e, i, n) => {
				t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(i, n)
			}), n("setTransition", (e, i, n) => {
				t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(i, n)
			}), Object.assign(t.controller, {
				setTranslate: function(e, i) {
					const n = t.controller.control;
					let o, s;
					const a = t.constructor;

					function l(e) {
						if (e.destroyed) return;
						const i = t.rtlTranslate ? -t.translate : t.translate;
						"slide" === t.params.controller.by && (function(e) {
							t.controller.spline = t.params.loop ? new r(t.slidesGrid, e.slidesGrid) : new r(t.snapGrid, e.snapGrid)
						}(e), s = -t.controller.spline.interpolate(-i)), s && "container" !== t.params.controller.by || (o = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(o) && Number.isFinite(o) || (o = 1), s = (i - t.minTranslate()) * o + e.minTranslate()), t.params.controller.inverse && (s = e.maxTranslate() - s), e.updateProgress(s), e.setTranslate(s, t), e.updateActiveIndex(), e.updateSlidesClasses()
					}
					if (Array.isArray(n))
						for (let e = 0; e < n.length; e += 1) n[e] !== i && n[e] instanceof a && l(n[e]);
					else n instanceof a && i !== n && l(n)
				},
				setTransition: function(e, i) {
					const n = t.constructor,
						r = t.controller.control;
					let o;

					function s(i) {
						i.destroyed || (i.setTransition(e, t), 0 !== e && (i.transitionStart(), i.params.autoHeight && a(() => {
							i.updateAutoHeight()
						}), _(i.wrapperEl, () => {
							r && i.transitionEnd()
						})))
					}
					if (Array.isArray(r))
						for (o = 0; o < r.length; o += 1) r[o] !== i && r[o] instanceof n && s(r[o]);
					else r instanceof n && i !== r && s(r)
				}
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: r
			} = e;
			i({
				a11y: {
					enabled: !0,
					notificationClass: "swiper-notification",
					prevSlideMessage: "Previous slide",
					nextSlideMessage: "Next slide",
					firstSlideMessage: "This is the first slide",
					lastSlideMessage: "This is the last slide",
					paginationBulletMessage: "Go to slide {{index}}",
					slideLabelMessage: "{{index}} / {{slidesLength}}",
					containerMessage: null,
					containerRoleDescriptionMessage: null,
					containerRole: null,
					itemRoleDescriptionMessage: null,
					slideRole: "group",
					id: null,
					scrollOnFocus: !0
				}
			}), t.a11y = {
				clicked: !1
			};
			let o, s, a = null,
				l = (new Date).getTime();

			function c(e) {
				const t = a;
				0 !== t.length && (t.innerHTML = "", t.innerHTML = e)
			}

			function h(e) {
				(e = M(e)).forEach(e => {
					e.setAttribute("tabIndex", "0")
				})
			}

			function u(e) {
				(e = M(e)).forEach(e => {
					e.setAttribute("tabIndex", "-1")
				})
			}

			function d(e, t) {
				(e = M(e)).forEach(e => {
					e.setAttribute("role", t)
				})
			}

			function p(e, t) {
				(e = M(e)).forEach(e => {
					e.setAttribute("aria-roledescription", t)
				})
			}

			function f(e, t) {
				(e = M(e)).forEach(e => {
					e.setAttribute("aria-label", t)
				})
			}

			function m(e) {
				(e = M(e)).forEach(e => {
					e.setAttribute("aria-disabled", !0)
				})
			}

			function g(e) {
				(e = M(e)).forEach(e => {
					e.setAttribute("aria-disabled", !1)
				})
			}

			function y(e) {
				if (13 !== e.keyCode && 32 !== e.keyCode) return;
				const i = t.params.a11y,
					n = e.target;
				if (!t.pagination || !t.pagination.el || n !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(te(t.params.pagination.bulletClass))) {
					if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) {
						const e = M(t.navigation.prevEl);
						M(t.navigation.nextEl).includes(n) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? c(i.lastSlideMessage) : c(i.nextSlideMessage)), e.includes(n) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? c(i.firstSlideMessage) : c(i.prevSlideMessage))
					}
					t.pagination && n.matches(te(t.params.pagination.bulletClass)) && n.click()
				}
			}

			function b() {
				return t.pagination && t.pagination.bullets && t.pagination.bullets.length
			}

			function x() {
				return b() && t.params.pagination.clickable
			}
			const _ = (e, t, i) => {
					h(e), "BUTTON" !== e.tagName && (d(e, "button"), e.addEventListener("keydown", y)), f(e, i),
						function(e, t) {
							(e = M(e)).forEach(e => {
								e.setAttribute("aria-controls", t)
							})
						}(e, t)
				},
				E = e => {
					s && s !== e.target && !s.contains(e.target) && (o = !0), t.a11y.clicked = !0
				},
				S = () => {
					o = !1, requestAnimationFrame(() => {
						requestAnimationFrame(() => {
							t.destroyed || (t.a11y.clicked = !1)
						})
					})
				},
				T = e => {
					l = (new Date).getTime()
				},
				A = e => {
					if (t.a11y.clicked || !t.params.a11y.scrollOnFocus) return;
					if ((new Date).getTime() - l < 100) return;
					const i = e.target.closest(`.${t.params.slideClass}, swiper-slide`);
					if (!i || !t.slides.includes(i)) return;
					s = i;
					const n = t.slides.indexOf(i) === t.activeIndex,
						r = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(i);
					n || r || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame(() => {
						o || (t.params.loop ? t.slideToLoop(parseInt(i.getAttribute("data-swiper-slide-index")), 0) : t.slideTo(t.slides.indexOf(i), 0), o = !1)
					}))
				},
				L = () => {
					const e = t.params.a11y;
					e.itemRoleDescriptionMessage && p(t.slides, e.itemRoleDescriptionMessage), e.slideRole && d(t.slides, e.slideRole);
					const i = t.slides.length;
					e.slideLabelMessage && t.slides.forEach((n, r) => {
						const o = t.params.loop ? parseInt(n.getAttribute("data-swiper-slide-index"), 10) : r;
						f(n, e.slideLabelMessage.replace(/\{\{index\}\}/, o + 1).replace(/\{\{slidesLength\}\}/, i))
					})
				};
			r("beforeInit", () => {
				a = v("span", t.params.a11y.notificationClass), a.setAttribute("aria-live", "assertive"), a.setAttribute("aria-atomic", "true")
			}), r("afterInit", () => {
				t.params.a11y.enabled && (() => {
					const e = t.params.a11y;
					t.el.append(a);
					const i = t.el;
					e.containerRoleDescriptionMessage && p(i, e.containerRoleDescriptionMessage), e.containerMessage && f(i, e.containerMessage), e.containerRole && d(i, e.containerRole);
					const r = t.wrapperEl,
						o = e.id || r.getAttribute("id") || "swiper-wrapper-" + (void 0 === (s = 16) && (s = 16), "x".repeat(s).replace(/x/g, () => Math.round(16 * Math.random()).toString(16)));
					var s;
					const l = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
					var c;
					c = o, M(r).forEach(e => {
							e.setAttribute("id", c)
						}),
						function(e, t) {
							(e = M(e)).forEach(e => {
								e.setAttribute("aria-live", t)
							})
						}(r, l), L();
					let {
						nextEl: h,
						prevEl: u
					} = t.navigation ? t.navigation : {};
					h = M(h), u = M(u), h && h.forEach(t => _(t, o, e.nextSlideMessage)), u && u.forEach(t => _(t, o, e.prevSlideMessage)), x() && M(t.pagination.el).forEach(e => {
						e.addEventListener("keydown", y)
					}), n().addEventListener("visibilitychange", T), t.el.addEventListener("focus", A, !0), t.el.addEventListener("focus", A, !0), t.el.addEventListener("pointerdown", E, !0), t.el.addEventListener("pointerup", S, !0)
				})()
			}), r("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
				t.params.a11y.enabled && L()
			}), r("fromEdge toEdge afterInit lock unlock", () => {
				t.params.a11y.enabled && function() {
					if (t.params.loop || t.params.rewind || !t.navigation) return;
					const {
						nextEl: e,
						prevEl: i
					} = t.navigation;
					i && (t.isBeginning ? (m(i), u(i)) : (g(i), h(i))), e && (t.isEnd ? (m(e), u(e)) : (g(e), h(e)))
				}()
			}), r("paginationUpdate", () => {
				t.params.a11y.enabled && function() {
					const e = t.params.a11y;
					b() && t.pagination.bullets.forEach(i => {
						t.params.pagination.clickable && (h(i), t.params.pagination.renderBullet || (d(i, "button"), f(i, e.paginationBulletMessage.replace(/\{\{index\}\}/, w(i) + 1)))), i.matches(te(t.params.pagination.bulletActiveClass)) ? i.setAttribute("aria-current", "true") : i.removeAttribute("aria-current")
					})
				}()
			}), r("destroy", () => {
				t.params.a11y.enabled && function() {
					a && a.remove();
					let {
						nextEl: e,
						prevEl: i
					} = t.navigation ? t.navigation : {};
					e = M(e), i = M(i), e && e.forEach(e => e.removeEventListener("keydown", y)), i && i.forEach(e => e.removeEventListener("keydown", y)), x() && M(t.pagination.el).forEach(e => {
						e.removeEventListener("keydown", y)
					}), n().removeEventListener("visibilitychange", T), t.el && "string" != typeof t.el && (t.el.removeEventListener("focus", A, !0), t.el.removeEventListener("pointerdown", E, !0), t.el.removeEventListener("pointerup", S, !0))
				}()
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				history: {
					enabled: !1,
					root: "",
					replaceState: !1,
					key: "slides",
					keepQuery: !1
				}
			});
			let r = !1,
				s = {};
			const a = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
				l = e => {
					const t = o();
					let i;
					i = e ? new URL(e) : t.location;
					const n = i.pathname.slice(1).split("/").filter(e => "" !== e),
						r = n.length;
					return {
						key: n[r - 2],
						value: n[r - 1]
					}
				},
				c = (e, i) => {
					const n = o();
					if (!r || !t.params.history.enabled) return;
					let s;
					s = t.params.url ? new URL(t.params.url) : n.location;
					const l = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${i}"]`) : t.slides[i];
					let c = a(l.getAttribute("data-history"));
					if (t.params.history.root.length > 0) {
						let i = t.params.history.root;
						"/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${e?e+"/":""}${c}`
					} else s.pathname.includes(e) || (c = `${e?e+"/":""}${c}`);
					t.params.history.keepQuery && (c += s.search);
					const h = n.history.state;
					h && h.value === c || (t.params.history.replaceState ? n.history.replaceState({
						value: c
					}, null, c) : n.history.pushState({
						value: c
					}, null, c))
				},
				h = (e, i, n) => {
					if (i)
						for (let r = 0, o = t.slides.length; r < o; r += 1) {
							const o = t.slides[r];
							if (a(o.getAttribute("data-history")) === i) {
								const i = t.getSlideIndex(o);
								t.slideTo(i, e, n)
							}
						} else t.slideTo(0, e, n)
				},
				u = () => {
					s = l(t.params.url), h(t.params.speed, s.value, !1)
				};
			n("init", () => {
				t.params.history.enabled && (() => {
					const e = o();
					if (t.params.history) {
						if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void(t.params.hashNavigation.enabled = !0);
						r = !0, s = l(t.params.url), s.key || s.value ? (h(0, s.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", u)) : t.params.history.replaceState || e.addEventListener("popstate", u)
					}
				})()
			}), n("destroy", () => {
				t.params.history.enabled && (() => {
					const e = o();
					t.params.history.replaceState || e.removeEventListener("popstate", u)
				})()
			}), n("transitionEnd _freeModeNoMomentumRelease", () => {
				r && c(t.params.history.key, t.activeIndex)
			}), n("slideChange", () => {
				r && t.params.cssMode && c(t.params.history.key, t.activeIndex)
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				emit: r,
				on: s
			} = e, a = !1;
			const l = n(),
				c = o();
			i({
				hashNavigation: {
					enabled: !1,
					replaceState: !1,
					watchState: !1,
					getSlideIndex(e, i) {
						if (t.virtual && t.params.virtual.enabled) {
							const e = t.slides.find(e => e.getAttribute("data-hash") === i);
							return e ? parseInt(e.getAttribute("data-swiper-slide-index"), 10) : 0
						}
						return t.getSlideIndex(m(t.slidesEl, `.${t.params.slideClass}[data-hash="${i}"], swiper-slide[data-hash="${i}"]`)[0])
					}
				}
			});
			const h = () => {
					r("hashChange");
					const e = l.location.hash.replace("#", ""),
						i = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex];
					if (e !== (i ? i.getAttribute("data-hash") : "")) {
						const i = t.params.hashNavigation.getSlideIndex(t, e);
						if (void 0 === i || Number.isNaN(i)) return;
						t.slideTo(i)
					}
				},
				u = () => {
					if (!a || !t.params.hashNavigation.enabled) return;
					const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex],
						i = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : "";
					t.params.hashNavigation.replaceState && c.history && c.history.replaceState ? (c.history.replaceState(null, null, "#" + i || ""), r("hashSet")) : (l.location.hash = i || "", r("hashSet"))
				};
			s("init", () => {
				t.params.hashNavigation.enabled && (() => {
					if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
					a = !0;
					const e = l.location.hash.replace("#", "");
					if (e) {
						const i = 0,
							n = t.params.hashNavigation.getSlideIndex(t, e);
						t.slideTo(n || 0, i, t.params.runCallbacksOnInit, !0)
					}
					t.params.hashNavigation.watchState && c.addEventListener("hashchange", h)
				})()
			}), s("destroy", () => {
				t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && c.removeEventListener("hashchange", h)
			}), s("transitionEnd _freeModeNoMomentumRelease", () => {
				a && u()
			}), s("slideChange", () => {
				a && t.params.cssMode && u()
			})
		}, function(e) {
			let t, i, {
				swiper: r,
				extendParams: o,
				on: s,
				emit: a,
				params: l
			} = e;
			r.autoplay = {
				running: !1,
				paused: !1,
				timeLeft: 0
			}, o({
				autoplay: {
					enabled: !1,
					delay: 3e3,
					waitForTransition: !0,
					disableOnInteraction: !1,
					stopOnLastSlide: !1,
					reverseDirection: !1,
					pauseOnMouseEnter: !1
				}
			});
			let c, h, u, d, p, f, m, g, v = l && l.autoplay ? l.autoplay.delay : 3e3,
				y = l && l.autoplay ? l.autoplay.delay : 3e3,
				b = (new Date).getTime();

			function w(e) {
				r && !r.destroyed && r.wrapperEl && e.target === r.wrapperEl && (r.wrapperEl.removeEventListener("transitionend", w), g || e.detail && e.detail.bySwiperTouchMove || T())
			}
			const x = () => {
					if (r.destroyed || !r.autoplay.running) return;
					r.autoplay.paused ? h = !0 : h && (y = c, h = !1);
					const e = r.autoplay.paused ? c : b + y - (new Date).getTime();
					r.autoplay.timeLeft = e, a("autoplayTimeLeft", e, e / v), i = requestAnimationFrame(() => {
						x()
					})
				},
				_ = e => {
					if (r.destroyed || !r.autoplay.running) return;
					cancelAnimationFrame(i), x();
					let n = void 0 === e ? r.params.autoplay.delay : e;
					v = r.params.autoplay.delay, y = r.params.autoplay.delay;
					const o = (() => {
						let e;
						if (e = r.virtual && r.params.virtual.enabled ? r.slides.find(e => e.classList.contains("swiper-slide-active")) : r.slides[r.activeIndex], e) return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
					})();
					!Number.isNaN(o) && o > 0 && void 0 === e && (n = o, v = o, y = o), c = n;
					const s = r.params.speed,
						l = () => {
							r && !r.destroyed && (r.params.autoplay.reverseDirection ? !r.isBeginning || r.params.loop || r.params.rewind ? (r.slidePrev(s, !0, !0), a("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(r.slides.length - 1, s, !0, !0), a("autoplay")) : !r.isEnd || r.params.loop || r.params.rewind ? (r.slideNext(s, !0, !0), a("autoplay")) : r.params.autoplay.stopOnLastSlide || (r.slideTo(0, s, !0, !0), a("autoplay")), r.params.cssMode && (b = (new Date).getTime(), requestAnimationFrame(() => {
								_()
							})))
						};
					return n > 0 ? (clearTimeout(t), t = setTimeout(() => {
						l()
					}, n)) : requestAnimationFrame(() => {
						l()
					}), n
				},
				E = () => {
					b = (new Date).getTime(), r.autoplay.running = !0, _(), a("autoplayStart")
				},
				M = () => {
					r.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(i), a("autoplayStop")
				},
				S = (e, i) => {
					if (r.destroyed || !r.autoplay.running) return;
					clearTimeout(t), e || (m = !0);
					const n = () => {
						a("autoplayPause"), r.params.autoplay.waitForTransition ? r.wrapperEl.addEventListener("transitionend", w) : T()
					};
					if (r.autoplay.paused = !0, i) return f && (c = r.params.autoplay.delay), f = !1, void n();
					const o = c || r.params.autoplay.delay;
					c = o - ((new Date).getTime() - b), r.isEnd && c < 0 && !r.params.loop || (c < 0 && (c = 0), n())
				},
				T = () => {
					r.isEnd && c < 0 && !r.params.loop || r.destroyed || !r.autoplay.running || (b = (new Date).getTime(), m ? (m = !1, _(c)) : _(), r.autoplay.paused = !1, a("autoplayResume"))
				},
				A = () => {
					if (r.destroyed || !r.autoplay.running) return;
					const e = n();
					"hidden" === e.visibilityState && (m = !0, S(!0)), "visible" === e.visibilityState && T()
				},
				L = e => {
					"mouse" === e.pointerType && (m = !0, g = !0, r.animating || r.autoplay.paused || S(!0))
				},
				C = e => {
					"mouse" === e.pointerType && (g = !1, r.autoplay.paused && T())
				};
			s("init", () => {
				r.params.autoplay.enabled && (r.params.autoplay.pauseOnMouseEnter && (r.el.addEventListener("pointerenter", L), r.el.addEventListener("pointerleave", C)), n().addEventListener("visibilitychange", A), E())
			}), s("destroy", () => {
				r.el && "string" != typeof r.el && (r.el.removeEventListener("pointerenter", L), r.el.removeEventListener("pointerleave", C)), n().removeEventListener("visibilitychange", A), r.autoplay.running && M()
			}), s("_freeModeStaticRelease", () => {
				(d || m) && T()
			}), s("_freeModeNoMomentumRelease", () => {
				r.params.autoplay.disableOnInteraction ? M() : S(!0, !0)
			}), s("beforeTransitionStart", (e, t, i) => {
				!r.destroyed && r.autoplay.running && (i || !r.params.autoplay.disableOnInteraction ? S(!0, !0) : M())
			}), s("sliderFirstMove", () => {
				!r.destroyed && r.autoplay.running && (r.params.autoplay.disableOnInteraction ? M() : (u = !0, d = !1, m = !1, p = setTimeout(() => {
					m = !0, d = !0, S(!0)
				}, 200)))
			}), s("touchEnd", () => {
				if (!r.destroyed && r.autoplay.running && u) {
					if (clearTimeout(p), clearTimeout(t), r.params.autoplay.disableOnInteraction) return d = !1, void(u = !1);
					d && r.params.cssMode && T(), d = !1, u = !1
				}
			}), s("slideChange", () => {
				!r.destroyed && r.autoplay.running && (f = !0)
			}), Object.assign(r.autoplay, {
				start: E,
				stop: M,
				pause: S,
				resume: T
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: r
			} = e;
			i({
				thumbs: {
					swiper: null,
					multipleActiveThumbs: !0,
					autoScrollOffset: 0,
					slideThumbActiveClass: "swiper-slide-thumb-active",
					thumbsContainerClass: "swiper-thumbs"
				}
			});
			let o = !1,
				s = !1;

			function a() {
				const e = t.thumbs.swiper;
				if (!e || e.destroyed) return;
				const i = e.clickedIndex,
					n = e.clickedSlide;
				if (n && n.classList.contains(t.params.thumbs.slideThumbActiveClass)) return;
				if (null == i) return;
				let r;
				r = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : i, t.params.loop ? t.slideToLoop(r) : t.slideTo(r)
			}

			function l() {
				const {
					thumbs: e
				} = t.params;
				if (o) return !1;
				o = !0;
				const i = t.constructor;
				if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
					watchSlidesProgress: !0,
					slideToClickedSlide: !1
				}), Object.assign(t.thumbs.swiper.params, {
					watchSlidesProgress: !0,
					slideToClickedSlide: !1
				}), t.thumbs.swiper.update();
				else if (h(e.swiper)) {
					const n = Object.assign({}, e.swiper);
					Object.assign(n, {
						watchSlidesProgress: !0,
						slideToClickedSlide: !1
					}), t.thumbs.swiper = new i(n), s = !0
				}
				return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", a), !0
			}

			function c(e) {
				const i = t.thumbs.swiper;
				if (!i || i.destroyed) return;
				const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView;
				let r = 1;
				const o = t.params.thumbs.slideThumbActiveClass;
				if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (r = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (r = 1), r = Math.floor(r), i.slides.forEach(e => e.classList.remove(o)), i.params.loop || i.params.virtual && i.params.virtual.enabled)
					for (let e = 0; e < r; e += 1) m(i.slidesEl, `[data-swiper-slide-index="${t.realIndex+e}"]`).forEach(e => {
						e.classList.add(o)
					});
				else
					for (let e = 0; e < r; e += 1) i.slides[t.realIndex + e] && i.slides[t.realIndex + e].classList.add(o);
				const s = t.params.thumbs.autoScrollOffset,
					a = s && !i.params.loop;
				if (t.realIndex !== i.realIndex || a) {
					const r = i.activeIndex;
					let o, l;
					if (i.params.loop) {
						const e = i.slides.find(e => e.getAttribute("data-swiper-slide-index") === "" + t.realIndex);
						o = i.slides.indexOf(e), l = t.activeIndex > t.previousIndex ? "next" : "prev"
					} else o = t.realIndex, l = o > t.previousIndex ? "next" : "prev";
					a && (o += "next" === l ? s : -1 * s), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(o) < 0 && (i.params.centeredSlides ? o = o > r ? o - Math.floor(n / 2) + 1 : o + Math.floor(n / 2) - 1 : o > r && i.params.slidesPerGroup, i.slideTo(o, e ? 0 : void 0))
				}
			}
			t.thumbs = {
				swiper: null
			}, r("beforeInit", () => {
				const {
					thumbs: e
				} = t.params;
				if (e && e.swiper)
					if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
						const i = n(),
							r = () => {
								const n = "string" == typeof e.swiper ? i.querySelector(e.swiper) : e.swiper;
								if (n && n.swiper) e.swiper = n.swiper, l(), c(!0);
								else if (n) {
									const i = t.params.eventsPrefix + "init",
										r = o => {
											e.swiper = o.detail[0], n.removeEventListener(i, r), l(), c(!0), e.swiper.update(), t.update()
										};
									n.addEventListener(i, r)
								}
								return n
							},
							o = () => {
								t.destroyed || r() || requestAnimationFrame(o)
							};
						requestAnimationFrame(o)
					} else l(), c(!0)
			}), r("slideChange update resize observerUpdate", () => {
				c()
			}), r("setTransition", (e, i) => {
				const n = t.thumbs.swiper;
				n && !n.destroyed && n.setTransition(i)
			}), r("beforeDestroy", () => {
				const e = t.thumbs.swiper;
				e && !e.destroyed && s && e.destroy()
			}), Object.assign(t.thumbs, {
				init: l,
				update: c
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				emit: n,
				once: r
			} = e;
			i({
				freeMode: {
					enabled: !1,
					momentum: !0,
					momentumRatio: 1,
					momentumBounce: !0,
					momentumBounceRatio: 1,
					momentumVelocityRatio: 1,
					sticky: !1,
					minimumVelocity: .02
				}
			}), Object.assign(t, {
				freeMode: {
					onTouchStart: function() {
						if (t.params.cssMode) return;
						const e = t.getTranslate();
						t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
							currentPos: t.rtl ? t.translate : -t.translate
						})
					},
					onTouchMove: function() {
						if (t.params.cssMode) return;
						const {
							touchEventsData: e,
							touches: i
						} = t;
						0 === e.velocities.length && e.velocities.push({
							position: i[t.isHorizontal() ? "startX" : "startY"],
							time: e.touchStartTime
						}), e.velocities.push({
							position: i[t.isHorizontal() ? "currentX" : "currentY"],
							time: l()
						})
					},
					onTouchEnd: function(e) {
						let {
							currentPos: i
						} = e;
						if (t.params.cssMode) return;
						const {
							params: o,
							wrapperEl: s,
							rtlTranslate: a,
							snapGrid: c,
							touchEventsData: h
						} = t, u = l() - h.touchStartTime;
						if (i < -t.minTranslate()) t.slideTo(t.activeIndex);
						else if (i > -t.maxTranslate()) t.slides.length < c.length ? t.slideTo(c.length - 1) : t.slideTo(t.slides.length - 1);
						else {
							if (o.freeMode.momentum) {
								if (h.velocities.length > 1) {
									const e = h.velocities.pop(),
										i = h.velocities.pop(),
										n = e.position - i.position,
										r = e.time - i.time;
									t.velocity = n / r, t.velocity /= 2, Math.abs(t.velocity) < o.freeMode.minimumVelocity && (t.velocity = 0), (r > 150 || l() - e.time > 300) && (t.velocity = 0)
								} else t.velocity = 0;
								t.velocity *= o.freeMode.momentumVelocityRatio, h.velocities.length = 0;
								let e = 1e3 * o.freeMode.momentumRatio;
								const i = t.velocity * e;
								let u = t.translate + i;
								a && (u = -u);
								let d, p = !1;
								const f = 20 * Math.abs(t.velocity) * o.freeMode.momentumBounceRatio;
								let m;
								if (u < t.maxTranslate()) o.freeMode.momentumBounce ? (u + t.maxTranslate() < -f && (u = t.maxTranslate() - f), d = t.maxTranslate(), p = !0, h.allowMomentumBounce = !0) : u = t.maxTranslate(), o.loop && o.centeredSlides && (m = !0);
								else if (u > t.minTranslate()) o.freeMode.momentumBounce ? (u - t.minTranslate() > f && (u = t.minTranslate() + f), d = t.minTranslate(), p = !0, h.allowMomentumBounce = !0) : u = t.minTranslate(), o.loop && o.centeredSlides && (m = !0);
								else if (o.freeMode.sticky) {
									let e;
									for (let t = 0; t < c.length; t += 1)
										if (c[t] > -u) {
											e = t;
											break
										} u = Math.abs(c[e] - u) < Math.abs(c[e - 1] - u) || "next" === t.swipeDirection ? c[e] : c[e - 1], u = -u
								}
								if (m && r("transitionEnd", () => {
										t.loopFix()
									}), 0 !== t.velocity) {
									if (e = a ? Math.abs((-u - t.translate) / t.velocity) : Math.abs((u - t.translate) / t.velocity), o.freeMode.sticky) {
										const i = Math.abs((a ? -u : u) - t.translate),
											n = t.slidesSizesGrid[t.activeIndex];
										e = i < n ? o.speed : i < 2 * n ? 1.5 * o.speed : 2.5 * o.speed
									}
								} else if (o.freeMode.sticky) return void t.slideToClosest();
								o.freeMode.momentumBounce && p ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(u), t.transitionStart(!0, t.swipeDirection), t.animating = !0, _(s, () => {
									t && !t.destroyed && h.allowMomentumBounce && (n("momentumBounce"), t.setTransition(o.speed), setTimeout(() => {
										t.setTranslate(d), _(s, () => {
											t && !t.destroyed && t.transitionEnd()
										})
									}, 0))
								})) : t.velocity ? (n("_freeModeNoMomentumRelease"), t.updateProgress(u), t.setTransition(e), t.setTranslate(u), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, _(s, () => {
									t && !t.destroyed && t.transitionEnd()
								}))) : t.updateProgress(u), t.updateActiveIndex(), t.updateSlidesClasses()
							} else {
								if (o.freeMode.sticky) return void t.slideToClosest();
								o.freeMode && n("_freeModeNoMomentumRelease")
							}(!o.freeMode.momentum || u >= o.longSwipesMs) && (n("_freeModeStaticRelease"), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
						}
					}
				}
			})
		}, function(e) {
			let t, i, n, r, {
				swiper: o,
				extendParams: s,
				on: a
			} = e;
			s({
				grid: {
					rows: 1,
					fill: "column"
				}
			});
			const l = () => {
				let e = o.params.spaceBetween;
				return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * o.size : "string" == typeof e && (e = parseFloat(e)), e
			};
			a("init", () => {
				r = o.params.grid && o.params.grid.rows > 1
			}), a("update", () => {
				const {
					params: e,
					el: t
				} = o, i = e.grid && e.grid.rows > 1;
				r && !i ? (t.classList.remove(e.containerModifierClass + "grid", e.containerModifierClass + "grid-column"), n = 1, o.emitContainerClasses()) : !r && i && (t.classList.add(e.containerModifierClass + "grid"), "column" === e.grid.fill && t.classList.add(e.containerModifierClass + "grid-column"), o.emitContainerClasses()), r = i
			}), o.grid = {
				initSlides: e => {
					const {
						slidesPerView: r
					} = o.params, {
						rows: s,
						fill: a
					} = o.params.grid, l = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : e.length;
					n = Math.floor(l / s), t = Math.floor(l / s) === l / s ? l : Math.ceil(l / s) * s, "auto" !== r && "row" === a && (t = Math.max(t, r * s)), i = t / s
				},
				unsetSlides: () => {
					o.slides && o.slides.forEach(e => {
						e.swiperSlideGridSet && (e.style.height = "", e.style[o.getDirectionLabel("margin-top")] = "")
					})
				},
				updateSlide: (e, r, s) => {
					const {
						slidesPerGroup: a
					} = o.params, c = l(), {
						rows: h,
						fill: u
					} = o.params.grid, d = o.virtual && o.params.virtual.enabled ? o.virtual.slides.length : s.length;
					let p, f, m;
					if ("row" === u && a > 1) {
						const i = Math.floor(e / (a * h)),
							n = e - h * a * i,
							o = 0 === i ? a : Math.min(Math.ceil((d - i * h * a) / h), a);
						m = Math.floor(n / o), f = n - m * o + i * a, p = f + m * t / h, r.style.order = p
					} else "column" === u ? (f = Math.floor(e / h), m = e - f * h, (f > n || f === n && m === h - 1) && (m += 1, m >= h && (m = 0, f += 1))) : (m = Math.floor(e / i), f = e - m * i);
					r.row = m, r.column = f, r.style.height = `calc((100% - ${(h-1)*c}px) / ${h})`, r.style[o.getDirectionLabel("margin-top")] = 0 !== m ? c && c + "px" : "", r.swiperSlideGridSet = !0
				},
				updateWrapperSize: (e, i) => {
					const {
						centeredSlides: n,
						roundLengths: r
					} = o.params, s = l(), {
						rows: a
					} = o.params.grid;
					if (o.virtualSize = (e + s) * t, o.virtualSize = Math.ceil(o.virtualSize / a) - s, o.params.cssMode || (o.wrapperEl.style[o.getDirectionLabel("width")] = o.virtualSize + s + "px"), n) {
						const e = [];
						for (let t = 0; t < i.length; t += 1) {
							let n = i[t];
							r && (n = Math.floor(n)), i[t] < o.virtualSize + i[0] && e.push(n)
						}
						i.splice(0, i.length), i.push(...e)
					}
				}
			}
		}, function(e) {
			let {
				swiper: t
			} = e;
			Object.assign(t, {
				appendSlide: ie.bind(t),
				prependSlide: ne.bind(t),
				addSlide: re.bind(t),
				removeSlide: oe.bind(t),
				removeAllSlides: se.bind(t)
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				fadeEffect: {
					crossFade: !1
				}
			}), ae({
				effect: "fade",
				swiper: t,
				on: n,
				setTranslate: () => {
					const {
						slides: e
					} = t;
					t.params.fadeEffect;
					for (let i = 0; i < e.length; i += 1) {
						const e = t.slides[i];
						let n = -e.swiperSlideOffset;
						t.params.virtualTranslate || (n -= t.translate);
						let r = 0;
						t.isHorizontal() || (r = n, n = 0);
						const o = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0),
							s = le(0, e);
						s.style.opacity = o, s.style.transform = `translate3d(${n}px, ${r}px, 0px)`
					}
				},
				setTransition: e => {
					const i = t.slides.map(e => f(e));
					i.forEach(t => {
						t.style.transitionDuration = e + "ms"
					}), ce({
						swiper: t,
						duration: e,
						transformElements: i,
						allSlides: !0
					})
				},
				overwriteParams: () => ({
					slidesPerView: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: !0,
					spaceBetween: 0,
					virtualTranslate: !t.params.cssMode
				})
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				cubeEffect: {
					slideShadows: !0,
					shadow: !0,
					shadowOffset: 20,
					shadowScale: .94
				}
			});
			const r = (e, t, i) => {
				let n = i ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
					r = i ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
				n || (n = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "left" : "top")).split(" ")), e.append(n)), r || (r = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (i ? "right" : "bottom")).split(" ")), e.append(r)), n && (n.style.opacity = Math.max(-t, 0)), r && (r.style.opacity = Math.max(t, 0))
			};
			ae({
				effect: "cube",
				swiper: t,
				on: n,
				setTranslate: () => {
					const {
						el: e,
						wrapperEl: i,
						slides: n,
						width: o,
						height: s,
						rtlTranslate: a,
						size: l,
						browser: c
					} = t, h = S(t), u = t.params.cubeEffect, d = t.isHorizontal(), p = t.virtual && t.params.virtual.enabled;
					let f, m = 0;
					u.shadow && (d ? (f = t.wrapperEl.querySelector(".swiper-cube-shadow"), f || (f = v("div", "swiper-cube-shadow"), t.wrapperEl.append(f)), f.style.height = o + "px") : (f = e.querySelector(".swiper-cube-shadow"), f || (f = v("div", "swiper-cube-shadow"), e.append(f))));
					for (let e = 0; e < n.length; e += 1) {
						const t = n[e];
						let i = e;
						p && (i = parseInt(t.getAttribute("data-swiper-slide-index"), 10));
						let o = 90 * i,
							s = Math.floor(o / 360);
						a && (o = -o, s = Math.floor(-o / 360));
						const c = Math.max(Math.min(t.progress, 1), -1);
						let f = 0,
							g = 0,
							v = 0;
						i % 4 == 0 ? (f = 4 * -s * l, v = 0) : (i - 1) % 4 == 0 ? (f = 0, v = 4 * -s * l) : (i - 2) % 4 == 0 ? (f = l + 4 * s * l, v = l) : (i - 3) % 4 == 0 && (f = -l, v = 3 * l + 4 * l * s), a && (f = -f), d || (g = f, f = 0);
						const y = `rotateX(${h(d?0:-o)}deg) rotateY(${h(d?o:0)}deg) translate3d(${f}px, ${g}px, ${v}px)`;
						c <= 1 && c > -1 && (m = 90 * i + 90 * c, a && (m = 90 * -i - 90 * c)), t.style.transform = y, u.slideShadows && r(t, c, d)
					}
					if (i.style.transformOrigin = `50% 50% -${l/2}px`, i.style["-webkit-transform-origin"] = `50% 50% -${l/2}px`, u.shadow)
						if (d) f.style.transform = `translate3d(0px, ${o/2+u.shadowOffset}px, ${-o/2}px) rotateX(89.99deg) rotateZ(0deg) scale(${u.shadowScale})`;
						else {
							const e = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90),
								t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
								i = u.shadowScale,
								n = u.shadowScale / t,
								r = u.shadowOffset;
							f.style.transform = `scale3d(${i}, 1, ${n}) translate3d(0px, ${s/2+r}px, ${-s/2/n}px) rotateX(-89.99deg)`
						} const g = (c.isSafari || c.isWebView) && c.needPerspectiveFix ? -l / 2 : 0;
					i.style.transform = `translate3d(0px,0,${g}px) rotateX(${h(t.isHorizontal()?0:m)}deg) rotateY(${h(t.isHorizontal()?-m:0)}deg)`, i.style.setProperty("--swiper-cube-translate-z", g + "px")
				},
				setTransition: e => {
					const {
						el: i,
						slides: n
					} = t;
					if (n.forEach(t => {
							t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
								t.style.transitionDuration = e + "ms"
							})
						}), t.params.cubeEffect.shadow && !t.isHorizontal()) {
						const t = i.querySelector(".swiper-cube-shadow");
						t && (t.style.transitionDuration = e + "ms")
					}
				},
				recreateShadows: () => {
					const e = t.isHorizontal();
					t.slides.forEach(t => {
						const i = Math.max(Math.min(t.progress, 1), -1);
						r(t, i, e)
					})
				},
				getEffectParams: () => t.params.cubeEffect,
				perspective: () => !0,
				overwriteParams: () => ({
					slidesPerView: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: !0,
					resistanceRatio: 0,
					spaceBetween: 0,
					centeredSlides: !1,
					virtualTranslate: !0
				})
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				flipEffect: {
					slideShadows: !0,
					limitRotation: !0
				}
			});
			const r = (e, i) => {
				let n = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
					r = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
				n || (n = he("flip", e, t.isHorizontal() ? "left" : "top")), r || (r = he("flip", e, t.isHorizontal() ? "right" : "bottom")), n && (n.style.opacity = Math.max(-i, 0)), r && (r.style.opacity = Math.max(i, 0))
			};
			ae({
				effect: "flip",
				swiper: t,
				on: n,
				setTranslate: () => {
					const {
						slides: e,
						rtlTranslate: i
					} = t, n = t.params.flipEffect, o = S(t);
					for (let s = 0; s < e.length; s += 1) {
						const a = e[s];
						let l = a.progress;
						t.params.flipEffect.limitRotation && (l = Math.max(Math.min(a.progress, 1), -1));
						const c = a.swiperSlideOffset;
						let h = -180 * l,
							u = 0,
							d = t.params.cssMode ? -c - t.translate : -c,
							p = 0;
						t.isHorizontal() ? i && (h = -h) : (p = d, d = 0, u = -h, h = 0), a.style.zIndex = -Math.abs(Math.round(l)) + e.length, n.slideShadows && r(a, l);
						const f = `translate3d(${d}px, ${p}px, 0px) rotateX(${o(u)}deg) rotateY(${o(h)}deg)`;
						le(0, a).style.transform = f
					}
				},
				setTransition: e => {
					const i = t.slides.map(e => f(e));
					i.forEach(t => {
						t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
							t.style.transitionDuration = e + "ms"
						})
					}), ce({
						swiper: t,
						duration: e,
						transformElements: i
					})
				},
				recreateShadows: () => {
					t.params.flipEffect, t.slides.forEach(e => {
						let i = e.progress;
						t.params.flipEffect.limitRotation && (i = Math.max(Math.min(e.progress, 1), -1)), r(e, i)
					})
				},
				getEffectParams: () => t.params.flipEffect,
				perspective: () => !0,
				overwriteParams: () => ({
					slidesPerView: 1,
					slidesPerGroup: 1,
					watchSlidesProgress: !0,
					spaceBetween: 0,
					virtualTranslate: !t.params.cssMode
				})
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				coverflowEffect: {
					rotate: 50,
					stretch: 0,
					depth: 100,
					scale: 1,
					modifier: 1,
					slideShadows: !0
				}
			}), ae({
				effect: "coverflow",
				swiper: t,
				on: n,
				setTranslate: () => {
					const {
						width: e,
						height: i,
						slides: n,
						slidesSizesGrid: r
					} = t, o = t.params.coverflowEffect, s = t.isHorizontal(), a = t.translate, l = s ? e / 2 - a : i / 2 - a, c = s ? o.rotate : -o.rotate, h = o.depth, u = S(t);
					for (let e = 0, t = n.length; e < t; e += 1) {
						const t = n[e],
							i = r[e],
							a = (l - t.swiperSlideOffset - i / 2) / i,
							d = "function" == typeof o.modifier ? o.modifier(a) : a * o.modifier;
						let p = s ? c * d : 0,
							f = s ? 0 : c * d,
							m = -h * Math.abs(d),
							g = o.stretch;
						"string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(o.stretch) / 100 * i);
						let v = s ? 0 : g * d,
							y = s ? g * d : 0,
							b = 1 - (1 - o.scale) * Math.abs(d);
						Math.abs(y) < .001 && (y = 0), Math.abs(v) < .001 && (v = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(f) < .001 && (f = 0), Math.abs(b) < .001 && (b = 0);
						const w = `translate3d(${y}px,${v}px,${m}px)  rotateX(${u(f)}deg) rotateY(${u(p)}deg) scale(${b})`;
						if (le(0, t).style.transform = w, t.style.zIndex = 1 - Math.abs(Math.round(d)), o.slideShadows) {
							let e = s ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top"),
								i = s ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom");
							e || (e = he("coverflow", t, s ? "left" : "top")), i || (i = he("coverflow", t, s ? "right" : "bottom")), e && (e.style.opacity = d > 0 ? d : 0), i && (i.style.opacity = -d > 0 ? -d : 0)
						}
					}
				},
				setTransition: e => {
					t.slides.map(e => f(e)).forEach(t => {
						t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
							t.style.transitionDuration = e + "ms"
						})
					})
				},
				perspective: () => !0,
				overwriteParams: () => ({
					watchSlidesProgress: !0
				})
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				creativeEffect: {
					limitProgress: 1,
					shadowPerProgress: !1,
					progressMultiplier: 1,
					perspective: !0,
					prev: {
						translate: [0, 0, 0],
						rotate: [0, 0, 0],
						opacity: 1,
						scale: 1
					},
					next: {
						translate: [0, 0, 0],
						rotate: [0, 0, 0],
						opacity: 1,
						scale: 1
					}
				}
			});
			const r = e => "string" == typeof e ? e : e + "px";
			ae({
				effect: "creative",
				swiper: t,
				on: n,
				setTranslate: () => {
					const {
						slides: e,
						wrapperEl: i,
						slidesSizesGrid: n
					} = t, o = t.params.creativeEffect, {
						progressMultiplier: s
					} = o, a = t.params.centeredSlides, l = S(t);
					if (a) {
						const e = n[0] / 2 - t.params.slidesOffsetBefore || 0;
						i.style.transform = `translateX(calc(50% - ${e}px))`
					}
					for (let i = 0; i < e.length; i += 1) {
						const n = e[i],
							c = n.progress,
							h = Math.min(Math.max(n.progress, -o.limitProgress), o.limitProgress);
						let u = h;
						a || (u = Math.min(Math.max(n.originalProgress, -o.limitProgress), o.limitProgress));
						const d = n.swiperSlideOffset,
							p = [t.params.cssMode ? -d - t.translate : -d, 0, 0],
							f = [0, 0, 0];
						let m = !1;
						t.isHorizontal() || (p[1] = p[0], p[0] = 0);
						let g = {
							translate: [0, 0, 0],
							rotate: [0, 0, 0],
							scale: 1,
							opacity: 1
						};
						h < 0 ? (g = o.next, m = !0) : h > 0 && (g = o.prev, m = !0), p.forEach((e, t) => {
							p[t] = `calc(${e}px + (${r(g.translate[t])} * ${Math.abs(h*s)}))`
						}), f.forEach((e, t) => {
							let i = g.rotate[t] * Math.abs(h * s);
							f[t] = i
						}), n.style.zIndex = -Math.abs(Math.round(c)) + e.length;
						const v = p.join(", "),
							y = `rotateX(${l(f[0])}deg) rotateY(${l(f[1])}deg) rotateZ(${l(f[2])}deg)`,
							b = u < 0 ? `scale(${1+(1-g.scale)*u*s})` : `scale(${1-(1-g.scale)*u*s})`,
							w = u < 0 ? 1 + (1 - g.opacity) * u * s : 1 - (1 - g.opacity) * u * s,
							x = `translate3d(${v}) ${y} ${b}`;
						if (m && g.shadow || !m) {
							let e = n.querySelector(".swiper-slide-shadow");
							if (!e && g.shadow && (e = he("creative", n)), e) {
								const t = o.shadowPerProgress ? h * (1 / o.limitProgress) : h;
								e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1)
							}
						}
						const _ = le(0, n);
						_.style.transform = x, _.style.opacity = w, g.origin && (_.style.transformOrigin = g.origin)
					}
				},
				setTransition: e => {
					const i = t.slides.map(e => f(e));
					i.forEach(t => {
						t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow").forEach(t => {
							t.style.transitionDuration = e + "ms"
						})
					}), ce({
						swiper: t,
						duration: e,
						transformElements: i,
						allSlides: !0
					})
				},
				perspective: () => t.params.creativeEffect.perspective,
				overwriteParams: () => ({
					watchSlidesProgress: !0,
					virtualTranslate: !t.params.cssMode
				})
			})
		}, function(e) {
			let {
				swiper: t,
				extendParams: i,
				on: n
			} = e;
			i({
				cardsEffect: {
					slideShadows: !0,
					rotate: !0,
					perSlideRotate: 2,
					perSlideOffset: 8
				}
			}), ae({
				effect: "cards",
				swiper: t,
				on: n,
				setTranslate: () => {
					const {
						slides: e,
						activeIndex: i,
						rtlTranslate: n
					} = t, r = t.params.cardsEffect, {
						startTranslate: o,
						isTouched: s
					} = t.touchEventsData, a = n ? -t.translate : t.translate;
					for (let l = 0; l < e.length; l += 1) {
						const c = e[l],
							h = c.progress,
							u = Math.min(Math.max(h, -4), 4);
						let d = c.swiperSlideOffset;
						t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (d -= e[0].swiperSlideOffset);
						let p = t.params.cssMode ? -d - t.translate : -d,
							f = 0;
						const m = -100 * Math.abs(u);
						let g = 1,
							v = -r.perSlideRotate * u,
							y = r.perSlideOffset - .75 * Math.abs(u);
						const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + l : l,
							w = (b === i || b === i - 1) && u > 0 && u < 1 && (s || t.params.cssMode) && a < o,
							x = (b === i || b === i + 1) && u < 0 && u > -1 && (s || t.params.cssMode) && a > o;
						if (w || x) {
							const e = (1 - Math.abs((Math.abs(u) - .5) / .5)) ** .5;
							v += -28 * u * e, g += -.5 * e, y += 96 * e, f = -25 * e * Math.abs(u) + "%"
						}
						if (p = u < 0 ? `calc(${p}px ${n?"-":"+"} (${y*Math.abs(u)}%))` : u > 0 ? `calc(${p}px ${n?"-":"+"} (-${y*Math.abs(u)}%))` : p + "px", !t.isHorizontal()) {
							const e = f;
							f = p, p = e
						}
						const _ = u < 0 ? "" + (1 + (1 - g) * u) : "" + (1 - (1 - g) * u),
							E = `\n        translate3d(${p}, ${f}, ${m}px)\n        rotateZ(${r.rotate?n?-v:v:0}deg)\n        scale(${_})\n      `;
						if (r.slideShadows) {
							let e = c.querySelector(".swiper-slide-shadow");
							e || (e = he("cards", c)), e && (e.style.opacity = Math.min(Math.max((Math.abs(u) - .5) / .5, 0), 1))
						}
						c.style.zIndex = -Math.abs(Math.round(h)) + e.length, le(0, c).style.transform = E
					}
				},
				setTransition: e => {
					const i = t.slides.map(e => f(e));
					i.forEach(t => {
						t.style.transitionDuration = e + "ms", t.querySelectorAll(".swiper-slide-shadow").forEach(t => {
							t.style.transitionDuration = e + "ms"
						})
					}), ce({
						swiper: t,
						duration: e,
						transformElements: i
					})
				},
				perspective: () => !0,
				overwriteParams: () => ({
					_loopSwapReset: !1,
					watchSlidesProgress: !0,
					loopAdditionalSlides: 3,
					centeredSlides: !0,
					virtualTranslate: !t.params.cssMode
				})
			})
		}];
		return $.use(ue), $
	}(),
	_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
		return typeof e
	} : function(e) {
		return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
	};
! function(e) {
	"function" == typeof define && define.amd ? define(["jquery"], e) : "object" === ("undefined" == typeof module ? "undefined" : _typeof(module)) && module.exports ? module.exports = function(t, i) {
		return void 0 === i && (i = "undefined" != typeof window ? require("jquery") : require("jquery")(t)), e(i), i
	} : e(jQuery)
}((function(e) {
	return e.fn.tilt = function(t) {
		var i = function() {
				this.ticking || (requestAnimationFrame(h.bind(this)), this.ticking = !0)
			},
			n = function() {
				e(this).on("mousemove", a), e(this).on("mouseenter", o), this.settings.reset && e(this).on("mouseleave", l), this.settings.glare && e(window).on("resize", d.bind(this))
			},
			r = function() {
				var t = this;
				void 0 !== this.timeout && clearTimeout(this.timeout), e(this).css({
					transition: this.settings.speed + "ms " + this.settings.easing
				}), this.settings.glare && this.glareElement.css({
					transition: "opacity " + this.settings.speed + "ms " + this.settings.easing
				}), this.timeout = setTimeout((function() {
					e(t).css({
						transition: ""
					}), t.settings.glare && t.glareElement.css({
						transition: ""
					})
				}), this.settings.speed)
			},
			o = function(t) {
				this.ticking = !1, e(this).css({
					"will-change": "transform"
				}), r.call(this), e(this).trigger("tilt.mouseEnter")
			},
			s = function(t) {
				return void 0 === t && (t = {
					pageX: e(this).offset().left + e(this).outerWidth() / 2,
					pageY: e(this).offset().top + e(this).outerHeight() / 2
				}), {
					x: t.pageX,
					y: t.pageY
				}
			},
			a = function(e) {
				this.mousePositions = s(e), i.call(this)
			},
			l = function() {
				r.call(this), this.reset = !0, i.call(this), e(this).trigger("tilt.mouseLeave")
			},
			c = function() {
				var t = e(this).outerWidth(),
					i = e(this).outerHeight(),
					n = e(this).offset().left,
					r = e(this).offset().top,
					o = (this.mousePositions.x - n) / t,
					s = (this.mousePositions.y - r) / i;
				return {
					tiltX: (this.settings.maxTilt / 2 - o * this.settings.maxTilt).toFixed(2),
					tiltY: (s * this.settings.maxTilt - this.settings.maxTilt / 2).toFixed(2),
					percentageX: 100 * o,
					percentageY: 100 * s,
					angle: Math.atan2(this.mousePositions.x - (n + t / 2), -(this.mousePositions.y - (r + i / 2))) * (180 / Math.PI)
				}
			},
			h = function() {
				return this.transforms = c.call(this), this.reset ? (this.reset = !1, e(this).css("transform", "perspective(" + this.settings.perspective + "px) rotateX(0deg) rotateY(0deg)"), void(this.settings.glare && (this.glareElement.css("transform", "rotate(180deg) translate(-50%, -50%)"), this.glareElement.css("opacity", "0")))) : (e(this).css("transform", "perspective(" + this.settings.perspective + "px) rotateX(" + ("x" === this.settings.disableAxis ? 0 : this.transforms.tiltY) + "deg) rotateY(" + ("y" === this.settings.disableAxis ? 0 : this.transforms.tiltX) + "deg) scale3d(" + this.settings.scale + "," + this.settings.scale + "," + this.settings.scale + ")"), this.settings.glare && (this.glareElement.css("transform", "rotate(" + this.transforms.angle + "deg) translate(-50%, -50%)"), this.glareElement.css("opacity", "" + this.transforms.percentageY * this.settings.maxGlare / 100)), e(this).trigger("change", [this.transforms]), void(this.ticking = !1))
			},
			u = function() {
				var t = this.settings.glarePrerender;
				t || e(this).append('<div class="js-tilt-glare"><div class="js-tilt-glare-inner"></div></div>'), this.glareElementWrapper = e(this).find(".js-tilt-glare"), this.glareElement = e(this).find(".js-tilt-glare-inner"), t || (this.glareElementWrapper.css({
					position: "absolute",
					top: "0",
					left: "0",
					width: "100%",
					height: "100%"
				}).css({
					overflow: "hidden",
					"pointer-events": "none"
				}), this.glareElement.css({
					position: "absolute",
					top: "50%",
					left: "50%",
					"background-image": "linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)",
					width: "" + 2 * e(this).outerWidth(),
					height: "" + 2 * e(this).outerWidth(),
					transform: "rotate(180deg) translate(-50%, -50%)",
					"transform-origin": "0% 0%",
					opacity: "0"
				}))
			},
			d = function() {
				this.glareElement.css({
					width: "" + 2 * e(this).outerWidth(),
					height: "" + 2 * e(this).outerWidth()
				})
			};
		return e.fn.tilt.destroy = function() {
			e(this).each((function() {
				e(this).find(".js-tilt-glare").remove(), e(this).css({
					"will-change": "",
					transform: ""
				}), e(this).off("mousemove mouseenter mouseleave")
			}))
		}, e.fn.tilt.getValues = function() {
			var t = [];
			return e(this).each((function() {
				this.mousePositions = s.call(this), t.push(c.call(this))
			})), t
		}, e.fn.tilt.reset = function() {
			e(this).each((function() {
				var t = this;
				this.mousePositions = s.call(this), this.settings = e(this).data("settings"), l.call(this), setTimeout((function() {
					t.reset = !1
				}), this.settings.transition)
			}))
		}, this.each((function() {
			var i = this;
			this.settings = e.extend({
				maxTilt: e(this).is("[data-tilt-max]") ? e(this).data("tilt-max") : 20,
				perspective: e(this).is("[data-tilt-perspective]") ? e(this).data("tilt-perspective") : 300,
				easing: e(this).is("[data-tilt-easing]") ? e(this).data("tilt-easing") : "cubic-bezier(.03,.98,.52,.99)",
				scale: e(this).is("[data-tilt-scale]") ? e(this).data("tilt-scale") : "1",
				speed: e(this).is("[data-tilt-speed]") ? e(this).data("tilt-speed") : "400",
				transition: !e(this).is("[data-tilt-transition]") || e(this).data("tilt-transition"),
				disableAxis: e(this).is("[data-tilt-disable-axis]") ? e(this).data("tilt-disable-axis") : null,
				axis: e(this).is("[data-tilt-axis]") ? e(this).data("tilt-axis") : null,
				reset: !e(this).is("[data-tilt-reset]") || e(this).data("tilt-reset"),
				glare: !!e(this).is("[data-tilt-glare]") && e(this).data("tilt-glare"),
				maxGlare: e(this).is("[data-tilt-maxglare]") ? e(this).data("tilt-maxglare") : 1
			}, t), null !== this.settings.axis && (console.warn("Tilt.js: the axis setting has been renamed to disableAxis. See https://github.com/gijsroge/tilt.js/pull/26 for more information"), this.settings.disableAxis = this.settings.axis), this.init = function() {
				e(i).data("settings", i.settings), i.settings.glare && u.call(i), n.call(i)
			}, this.init()
		}))
	}, e("[data-tilt]").tilt(), !0
}));